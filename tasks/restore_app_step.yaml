---
# Restore a single app on the test VM and record the result.
# Called in a loop from test_backup_restore.yaml Play 4.
#
# Expects (from caller loop/scope):
#   _test_app         — app name (loop_var from test_backup_restore.yaml)
#   _stack_archive_map — dict: app → stack archive path (set in Play 1)
#   _db_archive_map   — dict: db_name → db archive path (set in Play 1)
#   _app_restore_results — list to append {app, passed, detail} entries
# Inherits from play scope:
#   app_definitions, backup_base_dir, db_password,
#   semaphore_check vars (controller_fqdn, etc.)

- name: Resolve stack assignment for {{ _test_app }}
  ansible.builtin.set_fact:
    _cur_stack: "{{ app_definitions[_test_app].stack }}"

- block:
    - name: Create restore staging directory for {{ _test_app }}
      ansible.builtin.file:
        path: "/tmp/restore_{{ _test_app }}"
        state: directory
        mode: "0755"
      become: true
      when: not ansible_check_mode

    - name: Deploy databases stack (dependency for DB restore)
      include_tasks: tasks/deploy_single_stack.yaml
      vars:
        _current_stack: databases
        _test_mode: true
      when:
        - app_definitions[_test_app].db_names | default([]) | length > 0
        - _cur_stack != 'databases'

    - name: Reset DB passwords to match vault (restored data may differ)
      include_tasks: tasks/reset_db_auth.yaml
      vars:
        _db_mariadb_password: "{{ db_password }}"
        _db_postgres_password: "{{ docker_postgres_password }}"
      when:
        - app_definitions[_test_app].db_names | default([]) | length > 0
        - _cur_stack != 'databases'

    - name: Wait for database containers to be healthy
      ansible.builtin.shell: |
        found_any=false
        for i in $(seq 1 60); do
          all_ready=true
          # Check each running DB container in the databases stack
          if docker ps -q --filter "name=postgres" | grep -q .; then
            found_any=true
            docker exec postgres pg_isready -U postgres >/dev/null 2>&1 || all_ready=false
          fi
          if docker ps -q --filter "name=mariadb" | grep -q .; then
            found_any=true
            docker exec mariadb mysqladmin ping -h localhost >/dev/null 2>&1 || all_ready=false
          fi
          if $found_any && $all_ready; then
            echo "ready"
            exit 0
          fi
          sleep 2
        done
        echo "timeout — found_any=$found_any"
        exit 1
      become: true
      changed_when: false
      when:
        - app_definitions[_test_app].db_names | default([]) | length > 0
        - _cur_stack != 'databases'

    - name: Deploy {{ _cur_stack }} stack for {{ _test_app }} restore
      include_tasks: tasks/deploy_single_stack.yaml
      vars:
        _current_stack: "{{ _cur_stack }}"
        _test_mode: true

    - name: Discover app restore config from container labels — {{ _test_app }}
      become: true
      ansible.builtin.shell: |
        ids=$(docker ps -q \
          --filter "label=com.docker.compose.project={{ _cur_stack }}" \
          --filter "label=homelab.restore.app={{ _test_app }}")
        [ -z "$ids" ] && exit 0
        echo "$ids" | xargs docker inspect \
          --format '{% raw %}{{index .Config.Labels "homelab.restore.db_config"}}|{{index .Config.Labels "homelab.restore.db_names"}}|{{index .Config.Labels "homelab.restore.health_url"}}|{{index .Config.Labels "homelab.restore.health_status"}}{% endraw %}'
      register: _app_label_raw
      changed_when: false

    - name: Parse app config from labels — {{ _test_app }}
      ansible.builtin.set_fact:
        _cur_db_config: "{{ (_app_label_raw.stdout_lines[0] | default('|||')).split('|')[0] }}"
        _cur_db_names: >-
          {{ ((_app_label_raw.stdout_lines[0] | default('|||')).split('|')[1])
             .split(',') | reject('eq', '') | list }}
        _cur_health_url:    "{{ (_app_label_raw.stdout_lines[0] | default('|||')).split('|')[2] }}"
        _cur_health_status: "{{ (_app_label_raw.stdout_lines[0] | default('|||')).split('|')[3] or '200' }}"

    - name: Load DB engine config for {{ _test_app }}
      ansible.builtin.include_vars:
        file: "vars/{{ _cur_db_config }}.yaml"
      when: _cur_db_config | default('') | length > 0

    - name: Stop {{ _cur_stack }} stack before restore
      include_tasks: tasks/docker_stop.yaml
      vars:
        _docker_selective_stacks: ["{{ _cur_stack }}"]

    - name: Copy production DB backup to test VM staging — {{ _db_name_item }}
      ansible.builtin.synchronize:
        src: "{{ _db_archive_map[_db_name_item] }}"
        dest: "/tmp/restore_{{ _test_app }}/{{ _db_archive_map[_db_name_item] | basename }}"
        compress: false
        rsync_opts:
          - "--timeout=300"
          - "--whole-file"
      become: true
      ignore_errors: true
      register: _db_rsync_result
      loop: "{{ _cur_db_names | default([]) }}"
      loop_control:
        loop_var: _db_name_item
      when:
        - _cur_db_names | default([]) | length > 0
        - not ansible_check_mode

    - name: "Rsync stalled — copy DB backup via Ansible — {{ _db_name_item }}"
      ansible.builtin.copy:
        src: "{{ _db_archive_map[_db_name_item] }}"
        dest: "/tmp/restore_{{ _test_app }}/{{ _db_archive_map[_db_name_item] | basename }}"
        mode: "0644"
      become: true
      loop: "{{ _cur_db_names | default([]) }}"
      loop_control:
        loop_var: _db_name_item
      when:
        - _cur_db_names | default([]) | length > 0
        - not ansible_check_mode
        - _db_rsync_result is failed

    - name: Restore DB on test VM — {{ _db_name_item }}
      include_tasks: tasks/db_restore.yaml
      loop: "{{ _cur_db_names | default([]) }}"
      loop_control:
        loop_var: _db_name_item
      vars:
        _db_name: "{{ _db_name_item }}"
        _db_container: "{{ db_container_name }}"
        _db_username: "{{ db_username }}"
        _db_password: "{{ db_password | default('') }}"
        _db_source_file: "/tmp/restore_{{ _test_app }}/{{ _db_archive_map[_db_name_item] | basename }}"
        _db_is_postgres: "{{ is_postgres | default(false) }}"
        _db_is_mariadb: "{{ is_mariadb | default(false) }}"
        _db_is_influxdb: "{{ is_influxdb | default(false) }}"
        _db_tmp_dir: "/tmp/restore_{{ _test_app }}"
      when:
        - _cur_db_names | default([]) | length > 0
        - not ansible_check_mode

    - name: Restore appdata on test VM — {{ _test_app }}
      include_tasks: tasks/restore_appdata.yaml
      vars:
        backup_tmp_dir: "/tmp/restore_{{ _test_app }}"
        _restore_archive_path: "{{ _stack_archive_map[_test_app] }}"
        _restore_app_name: "{{ _test_app }}"

    - name: Start {{ _cur_stack }} stack after restore
      include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_stacks: ["{{ _cur_stack }}"]

    - name: Verify container health — {{ _test_app }}
      include_tasks: tasks/verify_docker_health.yaml
      vars:
        _test_mode: true

    - name: Verify HTTP health — {{ _test_app }}
      include_tasks: tasks/verify_app_http.yaml
      vars:
        _health_check_urls:
          - name: "{{ _test_app }}"
            url: "{{ _cur_health_url }}"
            status_code: "{{ _cur_health_status | default('200') }}"
      when:
        - _cur_health_url | default('') | length > 0
        - not ansible_check_mode

    - name: Record successful restore for {{ _test_app }}
      ansible.builtin.set_fact:
        _app_restore_results: >-
          {{ _app_restore_results + [{'app': _test_app, 'passed': true,
             'detail': _restore_detail | default('healthy')}] }}

  rescue:
    - name: Check for OOM kill events — {{ _test_app }}
      ansible.builtin.shell: dmesg | grep -i "out of memory\|oom-kill\|Killed process" | tail -1
      register: _oom_check
      failed_when: false
      changed_when: false
      become: true

    - name: Record failed restore for {{ _test_app }}
      ansible.builtin.set_fact:
        _app_restore_results: >-
          {{ _app_restore_results + [{'app': _test_app, 'passed': false,
             'oom': _oom_check.stdout | default('') | length > 0,
             'detail': (ansible_failed_result.msg | default('check Semaphore logs')) ~ ((' | ' + (ansible_failed_result.stdout | default('') | trim)) if ansible_failed_result.stdout | default('') | trim | length > 0 else '')}] }}

    - name: Restart stack after failure (best effort) — {{ _test_app }}
      include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_stacks: ["{{ _cur_stack }}"]
        _docker_ignore_errors: true

  always:
    - name: Clean up restore staging directory for {{ _test_app }}
      ansible.builtin.file:
        path: "/tmp/restore_{{ _test_app }}"
        state: absent
      become: true
      when: not ansible_check_mode
