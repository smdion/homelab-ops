---
# Restore a single app on the test VM and record the result.
# Called in a loop from test_backup_restore.yaml Play 4.
#
# Expects (from caller loop/scope):
#   _test_app         — app name (loop_var from test_backup_restore.yaml)
#   _stack_archive_map — dict: app → stack archive path (set in Play 1)
#   _db_archive_map   — dict: db_name → db archive path (set in Play 1)
#   _app_restore_results — list to append {app, passed, detail} entries
# Inherits from play scope:
#   app_info, backup_base_dir, db_password,
#   semaphore_check vars (controller_fqdn, etc.)

- name: Set stack for {{ _test_app }}
  ansible.builtin.set_fact:
    _cur_stack: "{{ app_info[_test_app].stack }}"

- block:
    - name: Ensure staging dir for {{ _test_app }}
      ansible.builtin.file:
        path: "/tmp/restore_{{ _test_app }}"
        state: directory
        mode: "0755"
      become: true
      when: not ansible_check_mode

    - name: Deploy stack — {{ _cur_stack }}
      include_tasks: tasks/deploy_single_stack.yaml
      vars:
        _current_stack: "{{ _cur_stack }}"
        _test_mode: true

    - name: Discover app restore config from container labels — {{ _test_app }}
      become: true
      ansible.builtin.shell: |
        ids=$(docker ps -q \
          --filter "label=com.docker.compose.project={{ _cur_stack }}" \
          --filter "label=homelab.restore.app={{ _test_app }}")
        [ -z "$ids" ] && exit 0
        echo "$ids" | xargs docker inspect \
          --format '{% raw %}{{index .Config.Labels "homelab.restore.db_config"}}|{{index .Config.Labels "homelab.restore.db_names"}}|{{index .Config.Labels "homelab.restore.health_url"}}|{{index .Config.Labels "homelab.restore.health_status"}}{% endraw %}'
      register: _app_label_raw
      changed_when: false

    - name: Parse app config from labels — {{ _test_app }}
      ansible.builtin.set_fact:
        _cur_db_config: "{{ (_app_label_raw.stdout_lines[0] | default('|||')).split('|')[0] }}"
        _cur_db_names: >-
          {{ ((_app_label_raw.stdout_lines[0] | default('|||')).split('|')[1])
             .split(',') | reject('eq', '') | list }}
        _cur_health_url:    "{{ (_app_label_raw.stdout_lines[0] | default('|||')).split('|')[2] }}"
        _cur_health_status: "{{ (_app_label_raw.stdout_lines[0] | default('|||')).split('|')[3] or '200' }}"

    - name: Load DB engine config for {{ _test_app }}
      ansible.builtin.include_vars:
        file: "vars/{{ _cur_db_config }}.yaml"
      when: _cur_db_config | default('') | length > 0

    - name: Stop stack — {{ _cur_stack }}
      include_tasks: tasks/docker_stop.yaml
      vars:
        _docker_selective_stacks: ["{{ _cur_stack }}"]

    - name: Copy DB backup to staging — {{ _db_name_item }}
      ansible.builtin.copy:
        src: "{{ _db_archive_map[_db_name_item] }}"
        dest: "/tmp/restore_{{ _test_app }}/{{ _db_name_item }}.sql.gz"
      become: true
      loop: "{{ _cur_db_names | default([]) }}"
      loop_control:
        loop_var: _db_name_item
      when:
        - _cur_db_names | default([]) | length > 0
        - not ansible_check_mode

    - name: Restore DB — {{ _db_name_item }}
      include_tasks: tasks/db_restore.yaml
      loop: "{{ _cur_db_names | default([]) }}"
      loop_control:
        loop_var: _db_name_item
      vars:
        _db_name: "{{ _db_name_item }}"
        _db_container: "{{ db_container_name }}"
        _db_username: "{{ db_username }}"
        _db_password: "{{ db_password | default('') }}"
        _db_source_file: "/tmp/restore_{{ _test_app }}/{{ _db_name_item }}.sql.gz"
        _db_is_postgres: "{{ is_postgres | default(false) }}"
        _db_is_mariadb: "{{ is_mariadb | default(false) }}"
        _db_is_influxdb: "{{ is_influxdb | default(false) }}"
        _db_tmp_dir: "/tmp/restore_{{ _test_app }}"
      when:
        - _cur_db_names | default([]) | length > 0
        - not ansible_check_mode

    - name: Restore appdata inplace — {{ _test_app }}
      include_tasks: tasks/restore_appdata.yaml
      vars:
        backup_tmp_dir: "/tmp/restore_{{ _test_app }}"
        _restore_archive_path: "{{ _stack_archive_map[_test_app] }}"
        _restore_mode: inplace
        _restore_app_name: "{{ _test_app }}"

    - name: Start stack — {{ _cur_stack }}
      include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_stacks: ["{{ _cur_stack }}"]

    - name: Verify container health — {{ _test_app }}
      include_tasks: tasks/verify_docker_health.yaml
      vars:
        _test_mode: true

    - name: Verify HTTP health — {{ _test_app }}
      include_tasks: tasks/verify_app_http.yaml
      vars:
        _health_check_urls:
          - url: "{{ _cur_health_url }}"
            status_code: "{{ _cur_health_status | default('200') }}"
      when:
        - _cur_health_url | default('') | length > 0
        - not ansible_check_mode

    - name: Record success — {{ _test_app }}
      ansible.builtin.set_fact:
        _app_restore_results: >-
          {{ _app_restore_results + [{'app': _test_app, 'passed': true,
             'detail': _restore_detail | default('healthy')}] }}

  rescue:
    - name: Check for OOM kill events — {{ _test_app }}
      ansible.builtin.shell: dmesg | grep -i "out of memory\|oom-kill\|Killed process" | tail -1
      register: _oom_check
      failed_when: false
      changed_when: false
      become: true

    - name: Record failure — {{ _test_app }}
      ansible.builtin.set_fact:
        _app_restore_results: >-
          {{ _app_restore_results + [{'app': _test_app, 'passed': false,
             'oom': _oom_check.stdout | default('') | length > 0,
             'detail': (ansible_failed_result.msg | default('check Semaphore logs')) ~ ((' | ' + (ansible_failed_result.stdout | default('') | trim)) if ansible_failed_result.stdout | default('') | trim | length > 0 else '')}] }}

    - name: Restart stack after failure (best effort) — {{ _test_app }}
      include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_stacks: ["{{ _cur_stack }}"]
        _docker_ignore_errors: true

  always:
    - name: Cleanup staging dir — {{ _test_app }}
      ansible.builtin.file:
        path: "/tmp/restore_{{ _test_app }}"
        state: absent
      become: true
      when: not ansible_check_mode
