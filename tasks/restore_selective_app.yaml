---
# Restore a single app from a monolithic backup archive.
# Supports optional coordinated DB restore via cross-host delegate_to.
# Extracted from restore_hosts.yaml.
#
# App config is read from app_definitions.yaml (containers, db_config,
# db_host, db_stack, db_names).
#
# Expects (from caller scope):
#   restore_app            — app name to restore
#   backup_base_dir        — controller-side backup root
#   backup_tmp_dir         — temp directory on target host
# Optional:
#   with_databases         — 'yes' to also restore databases cross-host
#   restore_date           — date filter for archive selection
# Sets:
#   restore_failed, _restore_source_file, _restore_detail

- name: Resolve app config from app_definitions
  ansible.builtin.set_fact:
    _app_cfg: "{{ app_definitions[restore_app] }}"

- name: Assert app has containers defined for selective restore
  ansible.builtin.assert:
    that: _app_cfg.containers is defined
    fail_msg: >-
      App '{{ restore_app }}' in app_definitions does not have 'containers' defined.
      Selective restore requires containers to stop/start.

- block:
    - name: Find backup archive on controller
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_*{{ restore_date | default('') }}*.tar.gz
        2>/dev/null | head -1
      register: _archive_file
      delegate_to: localhost
      become: false
      changed_when: false
      check_mode: false

    - name: Assert backup archive exists
      ansible.builtin.assert:
        that: _archive_file.stdout | length > 0
        fail_msg: "No backup archive found for {{ inventory_hostname }}"

    - name: Set source file fact
      ansible.builtin.set_fact:
        _restore_source_file: "{{ _archive_file.stdout | basename }}"

    - name: Verify archive integrity
      ansible.builtin.shell: |
        {{ _gz_detect }}
        $_gz -t "{{ _archive_file.stdout }}"
      delegate_to: localhost
      become: false
      changed_when: false
      check_mode: false

    - name: Compute extract path for selective app restore
      ansible.builtin.set_fact:
        _extract_path: "{{ (src_raw_files[0] | regex_replace('^/', '')) + '/' + restore_app }}"

    - name: Verify app directory exists in archive
      ansible.builtin.shell: |
        {{ _gz_detect }}
        tar -I "$_gz" -tf "{{ _archive_file.stdout }}" | grep -q "^{{ _extract_path }}/"
      delegate_to: localhost
      become: false
      changed_when: false
      check_mode: false

    # ===== STOP CONTAINERS =====
    - include_tasks: tasks/docker_stop.yaml
      vars:
        _docker_selective_containers: "{{ _app_cfg.containers }}"
      when:
        - _app_cfg.containers is defined
        - not ansible_check_mode

    # ===== COORDINATED DB RESTORE (cross-host via delegate_to) =====
    - name: Load DB vars into namespace
      ansible.builtin.include_vars:
        file: "vars/{{ _app_cfg.db_config }}.yaml"
        name: _db_vars
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_config is defined

    - name: Find DB backup files on controller
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ _app_cfg.db_stack }}/backup_{{ item }}_{{ restore_date | default('*') }}.{{ _db_vars.backup_ext | default('sql.gz') }}
        2>/dev/null | head -1
      loop: "{{ _app_cfg.db_names }}"
      register: _db_backup_files
      delegate_to: localhost
      become: false
      changed_when: false
      check_mode: false
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_names is defined

    - name: Assert DB backup files exist
      ansible.builtin.assert:
        that: _db_backup_files.results[idx].stdout | length > 0
        fail_msg: "No backup found for database {{ item }}"
      loop: "{{ _app_cfg.db_names }}"
      loop_control:
        index_var: idx
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_names is defined

    - name: Copy DB backup files to DB host
      ansible.builtin.copy:
        src: "{{ _db_backup_files.results[idx].stdout }}"
        dest: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.{{ _db_vars.backup_ext | default('sql.gz') }}"
      loop: "{{ _app_cfg.db_names }}"
      loop_control:
        index_var: idx
      delegate_to: "{{ _app_cfg.db_host }}"
      become: true
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_names is defined
        - not ansible_check_mode

    - name: Create pre-restore safety backup on DB host
      include_tasks: tasks/pre_restore_safety_dump.yaml
      vars:
        _safety_db_list: "{{ _app_cfg.db_names }}"
        _safety_container: "{{ _db_vars.db_container_name }}"
        _safety_username: "{{ _db_vars.db_username }}"
        _safety_password: "{{ db_password }}"
        _safety_dest_dir: "{{ _db_vars.backup_tmp_dir }}"
        _safety_ext: "{{ _db_vars.backup_ext | default('sql.gz') }}"
        _safety_is_postgres: "{{ _db_vars.is_postgres | default(false) }}"
        _safety_is_mariadb: "{{ _db_vars.is_mariadb | default(false) }}"
        _safety_is_influxdb: false
        _safety_delegate_host: "{{ _app_cfg.db_host }}"
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_names is defined
        - not (skip_pre_backup | default(false) | bool)
        - not ansible_check_mode

    - name: Restore databases on DB host
      include_tasks: tasks/db_restore.yaml
      loop: "{{ _app_cfg.db_names }}"
      vars:
        _db_name: "{{ item }}"
        _db_container: "{{ _db_vars.db_container_name }}"
        _db_username: "{{ _db_vars.db_username }}"
        _db_password: "{{ db_password }}"
        _db_source_file: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.{{ _db_vars.backup_ext | default('sql.gz') }}"
        _db_is_postgres: "{{ _db_vars.is_postgres | default(false) }}"
        _db_is_mariadb: "{{ _db_vars.is_mariadb | default(false) }}"
        _db_is_influxdb: false
        _db_tmp_dir: "{{ _db_vars.backup_tmp_dir }}"
      delegate_to: "{{ _app_cfg.db_host }}"
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_names is defined
        - not ansible_check_mode

    - name: Validate restored databases on DB host
      include_tasks: tasks/db_count.yaml
      loop: "{{ _app_cfg.db_names }}"
      vars:
        _db_name: "{{ item }}"
        _db_container: "{{ _db_vars.db_container_name }}"
        _db_username: "{{ _db_vars.db_username }}"
        _db_password: "{{ db_password }}"
        _db_is_postgres: "{{ _db_vars.is_postgres | default(false) }}"
        _db_is_mariadb: "{{ _db_vars.is_mariadb | default(false) }}"
        _db_is_influxdb: false
      delegate_to: "{{ _app_cfg.db_host }}"
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_names is defined
        - not ansible_check_mode

    - name: Clean up DB temp files on DB host
      ansible.builtin.file:
        path: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.{{ _db_vars.backup_ext | default('sql.gz') }}"
        state: absent
      loop: "{{ _app_cfg.db_names }}"
      delegate_to: "{{ _app_cfg.db_host }}"
      become: true
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_names is defined

    # ===== RESTORE APPDATA =====
    - include_tasks: tasks/restore_appdata.yaml
      vars:
        _restore_archive_path: "{{ _archive_file.stdout }}"
        _restore_extract_path: "{{ _extract_path }}"
        _restore_app_name: "{{ restore_app }}"

    - name: Append DB restore detail
      ansible.builtin.set_fact:
        _restore_detail: >-
          {{ _restore_detail }}
          + {{ _app_cfg.db_names | join(', ') }} DB(s) restored
      when:
        - with_databases | default('') == 'yes'
        - _app_cfg.db_names is defined
        - not ansible_check_mode

    # ===== START CONTAINERS =====
    - include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_containers: "{{ _app_cfg.containers }}"
      when:
        - _app_cfg.containers is defined
        - not ansible_check_mode

    # ===== CLEANUP =====
    - name: Clean up temp archive
      ansible.builtin.file:
        path: "{{ backup_tmp_dir }}/restore.tar.gz"
        state: absent
      become: true

  rescue:
    - name: Set restore failed flag
      ansible.builtin.set_fact:
        restore_failed: true

    - include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_containers: "{{ _app_cfg.containers | default([]) }}"
        _docker_ignore_errors: true
      when:
        - _app_cfg.containers is defined
