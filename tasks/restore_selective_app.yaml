---
# Restore a single app from a monolithic backup archive.
# Supports optional coordinated DB restore via cross-host delegate_to.
# Extracted from restore_hosts.yaml.
#
# Expects (from caller scope):
#   restore_app            — app name to restore
#   backup_base_dir        — controller-side backup root
#   backup_tmp_dir         — temp directory on target host
# Optional:
#   with_databases         — 'yes' to also restore databases cross-host
#   restore_date           — date filter for archive selection
# Sets:
#   restore_failed, _restore_source_file, _restore_detail

- block:
    - name: Find backup archive on controller
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_*{{ restore_date | default('') }}*.tar.gz
        2>/dev/null | head -1
      register: _archive_file
      delegate_to: localhost
      become: false
      changed_when: false
      check_mode: false

    - name: Assert backup archive exists
      ansible.builtin.assert:
        that: _archive_file.stdout | length > 0
        fail_msg: "No backup archive found for {{ inventory_hostname }}"

    - name: Set source file fact
      ansible.builtin.set_fact:
        _restore_source_file: "{{ _archive_file.stdout | basename }}"

    - name: Verify archive integrity
      ansible.builtin.shell: gunzip -t "{{ _archive_file.stdout }}"
      delegate_to: localhost
      become: false
      changed_when: false
      check_mode: false

    - name: Compute extract path for selective app restore
      ansible.builtin.set_fact:
        _extract_path: "{{ (src_raw_files[0] | regex_replace('^/', '')) + '/' + restore_app }}"

    - name: Verify app directory exists in archive
      ansible.builtin.shell: tar tzf "{{ _archive_file.stdout }}" | grep -q "^{{ _extract_path }}/"
      delegate_to: localhost
      become: false
      changed_when: false
      check_mode: false

    # ===== STOP CONTAINERS =====
    - include_tasks: tasks/docker_stop.yaml
      vars:
        _docker_selective_containers: "{{ app_restore[restore_app].containers }}"
      when:
        - app_restore is defined
        - app_restore[restore_app] is defined
        - not ansible_check_mode

    # ===== COORDINATED DB RESTORE (cross-host via delegate_to) =====
    - name: Load DB vars into namespace
      ansible.builtin.include_vars:
        file: "vars/{{ app_restore[restore_app].db_config_file }}.yaml"
        name: _db_vars
      when:
        - with_databases | default('') == 'yes'
        - app_restore is defined
        - app_restore[restore_app] is defined

    - name: Find DB backup files on controller
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ app_restore[restore_app].db_backup_stack | default(app_restore[restore_app].db_host) }}/backup_{{ item }}_{{ restore_date | default('*') }}.sql
        2>/dev/null | head -1
      loop: "{{ app_restore[restore_app].db_names }}"
      register: _db_backup_files
      delegate_to: localhost
      become: false
      changed_when: false
      check_mode: false
      when:
        - with_databases | default('') == 'yes'
        - app_restore is defined
        - app_restore[restore_app] is defined

    - name: Assert DB backup files exist
      ansible.builtin.assert:
        that: _db_backup_files.results[idx].stdout | length > 0
        fail_msg: "No backup found for database {{ item }}"
      loop: "{{ app_restore[restore_app].db_names }}"
      loop_control:
        index_var: idx
      when:
        - with_databases | default('') == 'yes'
        - app_restore is defined
        - app_restore[restore_app] is defined

    - name: Copy DB backup files to DB host
      ansible.builtin.copy:
        src: "{{ _db_backup_files.results[idx].stdout }}"
        dest: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.sql"
      loop: "{{ app_restore[restore_app].db_names }}"
      loop_control:
        index_var: idx
      delegate_to: "{{ app_restore[restore_app].db_host }}"
      become: true
      when:
        - with_databases | default('') == 'yes'
        - app_restore is defined
        - app_restore[restore_app] is defined
        - not ansible_check_mode

    - name: Restore databases on DB host
      include_tasks: tasks/db_restore.yaml
      loop: "{{ app_restore[restore_app].db_names }}"
      vars:
        _db_name: "{{ item }}"
        _db_container: "{{ _db_vars.db_container_name }}"
        _db_username: "{{ _db_vars.db_username }}"
        _db_password: "{{ db_password }}"
        _db_source_file: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.sql"
        _db_is_postgres: "{{ _db_vars.is_postgres | default(false) }}"
        _db_is_mariadb: "{{ _db_vars.is_mariadb | default(false) }}"
        _db_is_influxdb: false
        _db_tmp_dir: "{{ _db_vars.backup_tmp_dir }}"
      delegate_to: "{{ app_restore[restore_app].db_host }}"
      when:
        - with_databases | default('') == 'yes'
        - app_restore is defined
        - app_restore[restore_app] is defined
        - not ansible_check_mode

    - name: Validate restored databases on DB host
      include_tasks: tasks/db_count.yaml
      loop: "{{ app_restore[restore_app].db_names }}"
      vars:
        _db_name: "{{ item }}"
        _db_container: "{{ _db_vars.db_container_name }}"
        _db_username: "{{ _db_vars.db_username }}"
        _db_password: "{{ db_password }}"
        _db_is_postgres: "{{ _db_vars.is_postgres | default(false) }}"
        _db_is_mariadb: "{{ _db_vars.is_mariadb | default(false) }}"
        _db_is_influxdb: false
      delegate_to: "{{ app_restore[restore_app].db_host }}"
      when:
        - with_databases | default('') == 'yes'
        - app_restore is defined
        - app_restore[restore_app] is defined
        - not ansible_check_mode

    - name: Clean up DB temp files on DB host
      ansible.builtin.file:
        path: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.sql"
        state: absent
      loop: "{{ app_restore[restore_app].db_names }}"
      delegate_to: "{{ app_restore[restore_app].db_host }}"
      become: true
      when:
        - with_databases | default('') == 'yes'
        - app_restore is defined
        - app_restore[restore_app] is defined

    # ===== RESTORE APPDATA =====
    - include_tasks: tasks/restore_appdata.yaml
      vars:
        _restore_archive_path: "{{ _archive_file.stdout }}"
        _restore_extract_path: "{{ _extract_path }}"
        _restore_app_name: "{{ restore_app }}"

    - name: Append DB restore detail
      ansible.builtin.set_fact:
        _restore_detail: >-
          {{ _restore_detail }}
          + {{ app_restore[restore_app].db_names | join(', ') }} DB(s) restored
      when:
        - with_databases | default('') == 'yes'
        - app_restore is defined
        - app_restore[restore_app] is defined
        - not ansible_check_mode

    # ===== START CONTAINERS =====
    - include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_containers: "{{ app_restore[restore_app].containers }}"
      when:
        - app_restore is defined
        - app_restore[restore_app] is defined
        - not ansible_check_mode

    # ===== CLEANUP =====
    - name: Clean up temp archive
      ansible.builtin.file:
        path: "{{ backup_tmp_dir }}/restore.tar.gz"
        state: absent
      become: true

  rescue:
    - name: Set restore failed flag
      ansible.builtin.set_fact:
        restore_failed: true

    - include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_containers: "{{ app_restore[restore_app].containers | default([]) }}"
        _docker_ignore_errors: true
      when:
        - app_restore is defined
        - app_restore[restore_app] is defined
