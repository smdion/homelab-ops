---
# Provision a VM on Proxmox via cloud-init template clone.
# Extracted from build_ubuntu.yaml Play 1 CREATE path.
#
# Expects:
#   _vm                      — dict from vm_definitions (vm_id, vm_name, vm_hostname, vm_ip, etc.)
#   pve_api_host, pve_api_user, pve_api_token_id, pve_api_token_secret — PVE API credentials
#   pve_template_vmid, pve_template_node, pve_template_name — cloud-init template config
#   pve_cloud_image_url, pve_storage, pve_bridge — infrastructure defaults
#   vm_user, pve_vm_password, ansible_user_ssh_pubkey — VM user credentials
#   vm_cidr, vm_gateway, vm_dns, vm_search_domain — network config
# Optional:
#   _provision_target_group  — inventory group name for the new VM (default: 'build_target')
# Sets:
#   _vm_ip fact, adds host to _provision_target_group with _needs_bootstrap: true

# --- Ensure cloud-init template exists (one-time per cluster) ---
- name: Add PVE host to in-memory inventory
  ansible.builtin.add_host:
    name: pve_builder
    ansible_host: "{{ pve_api_host }}"
    ansible_user: ansible

- name: Ensure cloud-init template exists on Ceph storage
  delegate_to: pve_builder
  become: true
  ansible.builtin.shell: |
    if [ -f /etc/pve/qemu-server/{{ pve_template_vmid }}.conf ]; then
      echo "Template already exists"
      exit 0
    fi
    set -e
    cd /tmp
    wget -q "{{ pve_cloud_image_url }}" -O ubuntu-cloud.img
    qm create {{ pve_template_vmid }} \
      --name {{ pve_template_name }} \
      --memory {{ vm_template_memory }} --cores {{ vm_template_cores }} \
      --net0 virtio,bridge={{ pve_bridge }}
    qm importdisk {{ pve_template_vmid }} ubuntu-cloud.img {{ pve_storage }}
    qm set {{ pve_template_vmid }} \
      --scsi0 {{ pve_storage }}:vm-{{ pve_template_vmid }}-disk-0 \
      --scsihw virtio-scsi-single
    qm set {{ pve_template_vmid }} \
      --ide2 {{ pve_storage }}:cloudinit \
      --boot order=scsi0
    qm template {{ pve_template_vmid }}
    rm -f ubuntu-cloud.img
    echo "Template created"
  register: _template_result
  changed_when: "'Template created' in _template_result.stdout"

# --- Check if VMID already exists anywhere in the cluster (partial/failed prior run) ---
- name: Check if VMID already exists in cluster
  ansible.builtin.uri:
    url: "https://{{ pve_api_host }}:8006/api2/json/cluster/resources?type=vm"
    method: GET
    headers:
      Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
    validate_certs: false
  register: _cluster_vms
  no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

- name: Set VM pre-exists fact
  ansible.builtin.set_fact:
    _vm_already_exists: "{{ _cluster_vms.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | length > 0 }}"

# --- Auto-advance slot if selected VMID is currently running ---
# Applies to any VM in the test pool (vm_test_slot_base to slot_base+count-1).
# Named VMs outside that range are not auto-advanced.
- name: Auto-advance slot if selected VMID is running
  when: >-
    _vm_already_exists | bool and
    (_vm.vm_id | int) >= (vm_test_slot_base | int) and
    (_vm.vm_id | int) <= ((vm_test_slot_base + vm_test_slot_count - 1) | int) and
    (_cluster_vms.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int)
     | selectattr('status', 'equalto', 'running') | list | length > 0)
  block:
    - name: Assert a free slot exists
      ansible.builtin.assert:
        that: >-
          (range(vm_test_slot_base | int, (vm_test_slot_base + vm_test_slot_count) | int) | list)
          | difference(
              _cluster_vms.json.data
              | selectattr('status', 'equalto', 'running')
              | map(attribute='vmid') | map('int') | list
            ) | length > 0
        fail_msg: >-
          VMID {{ _vm.vm_id }} ({{ _vm.vm_name }}) is running and all slots
          (VMIDs {{ vm_test_slot_base }}–{{ vm_test_slot_base + vm_test_slot_count - 1 }})
          are also running. Stop a slot first, or pass vm_index= explicitly.

    - name: Resolve next free VMID
      ansible.builtin.set_fact:
        _next_free_vmid: >-
          {{ ((range(vm_test_slot_base | int, (vm_test_slot_base + vm_test_slot_count) | int) | list)
              | difference(
                  _cluster_vms.json.data
                  | selectattr('status', 'equalto', 'running')
                  | map(attribute='vmid') | map('int') | list
                ) | map('int') | sort | first) | int }}

    - name: Compute new slot index
      ansible.builtin.set_fact:
        _new_vm_index: "{{ (_next_free_vmid | int) - (vm_test_slot_base | int) }}"

    - name: Update _vm to next free slot
      ansible.builtin.set_fact:
        vm_index: "{{ _new_vm_index }}"
        _vm: >-
          {{ _vm | combine({
            'vm_id': _next_free_vmid | int,
            'vm_name': (_vm.vm_name | regex_replace('[0-9]+$', '')) ~ _new_vm_index,
            'vm_hostname': (_vm.vm_name | regex_replace('[0-9]+$', '')) ~ _new_vm_index ~ (_vm.vm_hostname | regex_replace('^[^.]+', '')),
            'vm_ip': vault_test_vm_ip_prefix ~ (((vault_test_vm_ip_offset | int) + (_new_vm_index | int)) | string)
          }) }}
        _vm_already_exists: >-
          {{ _cluster_vms.json.data | selectattr('vmid', 'equalto', _next_free_vmid | int) | list | length > 0 }}

    - name: Show auto-advanced slot
      ansible.builtin.debug:
        msg: >-
          Auto-advanced to vm_index={{ _new_vm_index }}
          (VMID {{ _vm.vm_id }}, IP {{ _vm.vm_ip }}) — previous slot was running.

# --- Clone, configure, resize, start —
#     grouped block: rescue fires on any step failure with a debug hint ---
- block:
    # Clone template to new VM (skip if VMID already exists from a prior partial run)
    - name: Clone VM from cloud-init template
      community.general.proxmox_kvm:
        api_host: "{{ pve_api_host }}"
        api_user: "{{ pve_api_user }}"
        api_token_id: "{{ pve_api_token_id }}"
        api_token_secret: "{{ pve_api_token_secret }}"
        node: "{{ pve_template_node }}"
        clone: "{{ pve_template_name }}"
        newid: "{{ _vm.vm_id }}"
        name: "{{ _vm.vm_name }}"
        full: true
        storage: "{{ pve_storage }}"
        target: "{{ _vm.pve_target_node }}"
        timeout: 300
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when: not _vm_already_exists

    # Wait for cloned VM to appear in cluster (any node)
    - name: Wait for cloned VM to be ready
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/cluster/resources?type=vm"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      register: _clone_ready
      until: _clone_ready.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | length > 0
      retries: 30
      delay: 5
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when: not _vm_already_exists and not ansible_check_mode

    # Resolve actual node the VM landed on (may differ from pve_target_node via VIP)
    - name: Resolve actual VM node from cluster resources
      ansible.builtin.set_fact:
        _vm_actual_node: >-
          {{ (_clone_ready.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | first).node
             if not _vm_already_exists
             else (_cluster_vms.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | first).node }}

    # Configure hardware and cloud-init
    - name: Configure VM hardware and cloud-init
      community.general.proxmox_kvm:
        api_host: "{{ pve_api_host }}"
        api_user: "{{ pve_api_user }}"
        api_token_id: "{{ pve_api_token_id }}"
        api_token_secret: "{{ pve_api_token_secret }}"
        node: "{{ _vm_actual_node }}"
        vmid: "{{ _vm.vm_id }}"
        name: "{{ _vm.vm_name }}"
        cores: "{{ _vm.vm_cores }}"
        memory: "{{ _vm.vm_memory_mb }}"
        agent: "enabled=1"
        ciuser: "{{ vm_user }}"
        cipassword: "{{ pve_vm_password }}"
        sshkeys: "{{ ansible_user_ssh_pubkey }}"
        ipconfig:
          ipconfig0: "ip={{ _vm.vm_ip }}/{{ vm_cidr }},gw={{ _vm.vm_gateway | default(vm_gateway) }}"
        nameservers: "{{ _vm.vm_dns | default(vm_dns) }}"
        searchdomains: "{{ vm_search_domain }}"
        update: true
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

    # Verify cloud-init IP was applied before starting (fail fast, not after 5-min SSH timeout)
    - name: Read back VM config to verify cloud-init IP
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ _vm.vm_id }}/config"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      register: _vm_config_check
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

    - name: Assert cloud-init IP matches expected
      ansible.builtin.assert:
        that: "'ip=' ~ _vm.vm_ip in (_vm_config_check.json.data.ipconfig0 | default(''))"
        fail_msg: >-
          cloud-init ipconfig0 does not contain expected IP {{ _vm.vm_ip }}.
          Actual: {{ _vm_config_check.json.data.ipconfig0 | default('not set') }}
          Check that vault_test_vm_ip_prefix and vault_test_vm_ip_offset resolve to a valid subnet IP.

    # Resize disk from cloud image (~3.5G) to target size
    - name: Resize VM disk
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ _vm.vm_id }}/resize"
        method: PUT
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        body_format: form-urlencoded
        body:
          disk: scsi0
          size: "{{ _vm.vm_disk_gb }}G"
        validate_certs: false
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when: not _vm_already_exists and not ansible_check_mode

    # Set VLAN tag if vm_vlan_tag is defined (test VM isolation)
    - name: Set VLAN tag on VM net0
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ _vm.vm_id }}/config"
        method: PUT
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        body_format: form-urlencoded
        body:
          net0: "virtio,bridge={{ pve_bridge }},tag={{ _vm.vm_vlan_tag }}"
        validate_certs: false
      when: _vm.vm_vlan_tag is defined and not ansible_check_mode
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

    # Start VM
    - name: Start VM
      community.general.proxmox_kvm:
        api_host: "{{ pve_api_host }}"
        api_user: "{{ pve_api_user }}"
        api_token_id: "{{ pve_api_token_id }}"
        api_token_secret: "{{ pve_api_token_secret }}"
        node: "{{ _vm_actual_node }}"
        vmid: "{{ _vm.vm_id }}"
        state: started
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

    - name: Assert SSH port reachable (firewall check)
      ansible.builtin.wait_for:
        host: "{{ _vm.vm_ip }}"
        port: 22
        delay: 10
        timeout: 30
        msg: >-
          Port 22 unreachable on {{ _vm.vm_ip }} after 30s — likely a firewall issue.
          Check that the controller IP is permitted to reach {{ _vm.vm_ip }}:22
          (e.g. Unifi zone policy allowing Semaphore IP to test VLAN, or UFW on the VM).
      when: not ansible_check_mode

    - name: Wait for SSH
      ansible.builtin.wait_for:
        host: "{{ _vm.vm_ip }}"
        port: 22
        delay: 0
        timeout: 270
      when: not ansible_check_mode

    - name: Set VM IP fact
      ansible.builtin.set_fact:
        _vm_ip: "{{ _vm.vm_ip }}"

    - name: Add new VM to in-memory inventory
      ansible.builtin.add_host:
        name: "{{ _vm.vm_hostname }}"
        ansible_host: "{{ _vm.vm_ip }}"
        ansible_user: "{{ vm_user }}"
        groups: "{{ _provision_target_group | default('build_target') }}"
        _needs_bootstrap: true

    - name: Add VM to test pool
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/pools/{{ pve_pool_test }}"
        method: PUT
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        body_format: form-urlencoded
        body:
          vms: "{{ _vm.vm_id }}"
        validate_certs: false
      register: _pool_add_result
      failed_when: >-
        _pool_add_result.status | default(0) not in [200] and
        'already a pool member' not in (_pool_add_result.json.message | default(''))
      when: pve_pool_test is defined and not ansible_check_mode
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

  rescue:
    - ansible.builtin.fail:
        msg: >-
          VM provisioning failed for VMID {{ _vm.vm_id }} ({{ _vm.vm_name }}).
          Re-run with -e debug_no_log=yes for full output.
          If VMID already exists in a broken state, delete it from Proxmox and retry.
