---
# Shared restore-deploy-verify pipeline for test_restore and dr_rebuild.
# Extracts appdata, patches SWAG, deploys stacks, restores DBs, and runs health checks.
#
# Called inside a block: in the caller's play — caller retains rescue:/always: for
# notification, logging, and cleanup.
#
# Required facts (set by caller's Play 1 on localhost):
#   hostvars['localhost']._archive_files     — list of appdata archive paths
#   hostvars['localhost']._stacks            — list of stacks to deploy
#   hostvars['localhost']._db_archive_map    — dict of db_name -> archive path
#   hostvars['localhost']._db_postgres_names — list of postgres DB names to restore
#   hostvars['localhost']._db_mariadb_names  — list of mariadb DB names to restore
#   hostvars['localhost']._db_postgres_container — postgres container name
#   hostvars['localhost']._db_mariadb_container  — mariadb container name
#   hostvars['localhost']._db_postgres_username  — postgres username
#   hostvars['localhost']._db_mariadb_username   — mariadb username
#   hostvars['localhost']._vm                    — VM definition dict
#
# Optional vars (pass via vars: on include_tasks):
#   _test_mode — true for test_restore (adjusts deploy/health), false/absent for dr_rebuild

# ===== EXTRACT APPDATA FROM BACKUP =====
- name: Ensure backup_tmp_dir exists
  ansible.builtin.file:
    path: "{{ backup_tmp_dir }}"
    state: directory
    mode: '0755'
  become: true

- name: Compute selective extract path for {{ restore_app | default('') }}
  ansible.builtin.set_fact:
    _extract_path: "{{ (src_raw_files[0] | regex_replace('^/', '')) + '/' + restore_app }}"
  when: restore_app | default('') | length > 0

- name: Restore appdata from production backup
  include_tasks: tasks/restore_appdata.yaml
  loop: "{{ hostvars['localhost']._archive_files }}"
  loop_control:
    loop_var: _current_archive
  vars:
    _restore_archive_path: "{{ _current_archive }}"
    _restore_extract_path: "{{ _extract_path | default('') }}"
    _restore_app_name: "{{ restore_app | default('') }}"

# ===== PATCH SWAG SITE-CONFS FOR NEW VM LAYOUT =====
- name: Resolve effective VIPs for SWAG patches
  include_tasks: tasks/resolve_effective_vips.yaml
  when: "'auth' in hostvars['localhost']._stacks"

- name: Patch SWAG site-confs for core/apps/dev layout
  include_tasks: tasks/patch_swag_confs.yaml
  when: "'auth' in hostvars['localhost']._stacks"

# ===== DEPLOY DATABASES STACK FIRST =====
# DB containers must be running and populated before app stacks start,
# otherwise apps (authentik, jellyseerr, etc.) connect to empty databases.
- name: Deploy databases stack first
  include_tasks: tasks/deploy_single_stack.yaml
  vars:
    _current_stack: databases
    _test_mode: "{{ _test_mode | default(false) }}"
    patch_compose_networks: true
    _apps_vip: >-
      {% if _role_injected | default(false) %}{{ ansible_default_ipv4.address.rsplit('.', 1)[0] }}.{{ docker_test_vip_offsets['apps'] }}{% else %}{{ vault_apps_vip }}{% endif %}
  when: "'databases' in hostvars['localhost']._stacks"

- name: Reset DB passwords to match vault (restored data may differ)
  include_tasks: tasks/reset_db_auth.yaml
  vars:
    _db_mariadb_password: "{{ db_password }}"
    _db_postgres_password: "{{ docker_postgres_password }}"
    _db_mariadb_container: "{{ hostvars['localhost']._db_mariadb_container | default('mariadb') }}"
    _db_postgres_container: "{{ hostvars['localhost']._db_postgres_container | default('postgres') }}"
  when: "'databases' in hostvars['localhost']._stacks"

# ===== RESTORE SQL DUMPS =====
- name: Wait for database containers to accept authenticated connections
  ansible.builtin.shell: |
    found_any=false
    for i in $(seq 1 60); do
      all_ready=true
      if [ -n "$PG_CONTAINER" ] && docker ps -q --filter "name=$PG_CONTAINER" | grep -q .; then
        found_any=true
        docker exec "$PG_CONTAINER" pg_isready -U "$PG_USER" >/dev/null 2>&1 || all_ready=false
      fi
      if [ -n "$MARIA_CONTAINER" ] && docker ps -q --filter "name=$MARIA_CONTAINER" | grep -q .; then
        found_any=true
        docker exec -e MYSQL_PWD="$DB_PASSWORD" "$MARIA_CONTAINER" mysql -u "$MARIA_USER" -e "SELECT 1" >/dev/null 2>&1 || all_ready=false
      fi
      if [ -n "$PG2_CONTAINER" ] && docker ps -q --filter "name=$PG2_CONTAINER" | grep -q .; then
        found_any=true
        docker exec "$PG2_CONTAINER" pg_isready -U "$PG2_USER" >/dev/null 2>&1 || all_ready=false
      fi
      if $found_any && $all_ready; then
        echo "ready"
        exit 0
      fi
      sleep 2
    done
    echo "timeout — found_any=$found_any"
    exit 1
  environment:
    DB_PASSWORD: "{{ db_password | default('') }}"
    PG_CONTAINER: "{{ hostvars['localhost']._db_postgres_container | default('') }}"
    PG_USER: "{{ hostvars['localhost']._db_postgres_username | default('postgres') }}"
    MARIA_CONTAINER: "{{ hostvars['localhost']._db_mariadb_container | default('') }}"
    MARIA_USER: "{{ hostvars['localhost']._db_mariadb_username | default('root') }}"
    PG2_CONTAINER: "{{ hostvars['localhost']._db_secondary_postgres_container | default('') }}"
    PG2_USER: "{{ hostvars['localhost']._db_secondary_postgres_username | default('postgres') }}"
  become: true
  changed_when: false
  when: hostvars['localhost']._db_archive_map | default({}) | length > 0

- name: Create DB restore staging directory
  ansible.builtin.file:
    path: /tmp/db_restore_staging
    state: directory
    mode: '0755'
  become: true
  when: hostvars['localhost']._db_archive_map | default({}) | length > 0

- name: Copy production DB backup — {{ item.key }}
  ansible.builtin.synchronize:
    src: "{{ item.value }}"
    dest: "/tmp/db_restore_staging/{{ item.value | basename }}"
    compress: false
    rsync_opts:
      - "--timeout=300"
      - "--whole-file"
  become: true
  ignore_errors: true
  register: _db_rsync_result
  loop: "{{ hostvars['localhost']._db_archive_map | default({}) | dict2items }}"
  loop_control:
    label: "{{ item.key }}"
  when: hostvars['localhost']._db_archive_map | default({}) | length > 0

- name: "Rsync stalled — copy DB backup via Ansible — {{ item.key }}"
  ansible.builtin.copy:
    src: "{{ item.value }}"
    dest: "/tmp/db_restore_staging/{{ item.value | basename }}"
    mode: "0644"
  become: true
  loop: "{{ hostvars['localhost']._db_archive_map | default({}) | dict2items }}"
  loop_control:
    label: "{{ item.key }}"
  when:
    - hostvars['localhost']._db_archive_map | default({}) | length > 0
    - _db_rsync_result is failed

- name: Restore postgres database — {{ _db_item }}
  include_tasks: tasks/db_restore.yaml
  loop: "{{ hostvars['localhost']._db_postgres_names | default([]) }}"
  loop_control:
    loop_var: _db_item
  vars:
    _db_name: "{{ _db_item }}"
    _db_container: "{{ hostvars['localhost']._db_postgres_container }}"
    _db_username: "{{ hostvars['localhost']._db_postgres_username }}"
    _db_password: "{{ db_password | default('') }}"
    _db_source_file: "/tmp/db_restore_staging/{{ hostvars['localhost']._db_archive_map[_db_item] | basename }}"
    _db_is_postgres: true
    _db_is_mariadb: false
    _db_is_influxdb: false
    _db_tmp_dir: "/tmp/db_restore_staging"
  when: hostvars['localhost']._db_postgres_names | default([]) | length > 0

- name: Restore mariadb database — {{ _db_item }}
  include_tasks: tasks/db_restore.yaml
  loop: "{{ hostvars['localhost']._db_mariadb_names | default([]) }}"
  loop_control:
    loop_var: _db_item
  vars:
    _db_name: "{{ _db_item }}"
    _db_container: "{{ hostvars['localhost']._db_mariadb_container }}"
    _db_username: "{{ hostvars['localhost']._db_mariadb_username }}"
    _db_password: "{{ db_password | default('') }}"
    _db_source_file: "/tmp/db_restore_staging/{{ hostvars['localhost']._db_archive_map[_db_item] | basename }}"
    _db_is_postgres: false
    _db_is_mariadb: true
    _db_is_influxdb: false
    _db_tmp_dir: "/tmp/db_restore_staging"
  when: hostvars['localhost']._db_mariadb_names | default([]) | length > 0

- name: Restore secondary postgres database — {{ _db_item }}
  include_tasks: tasks/db_restore.yaml
  loop: "{{ hostvars['localhost']._db_secondary_postgres_names | default([]) }}"
  loop_control:
    loop_var: _db_item
  vars:
    _db_name: "{{ _db_item }}"
    _db_container: "{{ hostvars['localhost']._db_secondary_postgres_container }}"
    _db_username: "{{ hostvars['localhost']._db_secondary_postgres_username }}"
    _db_password: "{{ db_password | default('') }}"
    _db_source_file: "/tmp/db_restore_staging/{{ hostvars['localhost']._db_archive_map[_db_item] | basename }}"
    _db_is_postgres: true
    _db_is_mariadb: false
    _db_is_influxdb: false
    _db_tmp_dir: "/tmp/db_restore_staging"
  when: hostvars['localhost']._db_secondary_postgres_names | default([]) | length > 0

- name: Clean up DB restore staging directory
  ansible.builtin.file:
    path: /tmp/db_restore_staging
    state: absent
  become: true
  when: hostvars['localhost']._db_archive_map | default({}) | length > 0

# ===== DEPLOY REMAINING STACKS =====
- name: "Deploy stack — {{ _current_stack }}"
  include_tasks: tasks/deploy_single_stack.yaml
  loop: "{{ hostvars['localhost']._stacks | reject('equalto', 'databases') | list }}"
  loop_control:
    loop_var: _current_stack
  vars:
    _test_mode: "{{ _test_mode | default(false) }}"
    patch_compose_networks: true
    _apps_vip: >-
      {% if _role_injected | default(false) %}{{ ansible_default_ipv4.address.rsplit('.', 1)[0] }}.{{ docker_test_vip_offsets['apps'] }}{% else %}{{ vault_apps_vip }}{% endif %}

# ===== HEALTH CHECK =====
- name: Verify container health
  include_tasks: tasks/verify_docker_health.yaml
  vars:
    _test_mode: "{{ _test_mode | default(false) }}"

# ===== NETWORK VERIFICATION =====
- name: Verify Docker network connectivity
  include_tasks: tasks/verify_docker_network.yaml
  vars:
    _db_service_names:
      - "{{ hostvars['localhost']._db_postgres_container | default('postgres') }}"
      - "{{ hostvars['localhost']._db_mariadb_container | default('mariadb') }}"
    _db_service_ports:
      "{{ hostvars['localhost']._db_postgres_container | default('postgres') }}": 5432
      "{{ hostvars['localhost']._db_mariadb_container | default('mariadb') }}": 3306

# ===== NETWORK ISOLATION VERIFICATION =====
- name: Verify test VLAN isolation from production
  include_tasks: tasks/verify_network_isolation.yaml
  vars:
    _vm: "{{ hostvars['localhost']._vm }}"

# ===== VIP VERIFICATION =====
- name: Verify VIP is active
  include_tasks: tasks/verify_vip.yaml

- name: Record success detail
  ansible.builtin.set_fact:
    _restore_test_detail: >-
      {{ restore_app | default('full') }} restore verified
      — {{ hostvars['localhost']._stacks | join(', ') }} stack(s)
