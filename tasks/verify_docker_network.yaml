---
# Verify Docker network connectivity: membership, DNS resolution, and TCP reachability.
# Tests representative consumers → DB services (not O(n^2) mesh).
# Uses getent hosts (libc-level) with ping fallback — avoids nslookup which
# is missing from most third-party container images.
#
# Optional:
#   _network_name      — Docker network to verify (default: 'homelab')
#   _db_service_names  — list of DB container names (default: ['postgres', 'mariadb'])
#   _db_service_ports  — dict of container name → port (default: {postgres: 5432, mariadb: 3306})
# Sets:
#   _network_summary — human-readable verification result for logging

- name: Verify Docker network connectivity
  become: true
  ansible.builtin.shell:
    cmd: |
      set -e
      network="{{ _network_name | default('homelab') }}"
      errors=0

      # DB service names and ports (passed from caller or defaults)
      IFS=',' read -ra db_names <<< "$DB_SERVICE_NAMES"
      IFS=',' read -ra db_ports <<< "$DB_SERVICE_PORTS"

      # --- 1. Network membership ---
      containers=$(docker network inspect "$network" \
        --format '{% raw %}{{range .Containers}}{{.Name}} {{end}}{% endraw %}' 2>/dev/null | xargs)
      if [ -z "$containers" ]; then
        echo "FAIL: No containers on '$network' network"
        exit 1
      fi
      count=$(echo "$containers" | wc -w)
      echo "NETWORK: $count container(s) on '$network': $containers"

      # --- 2. DNS resolution (key consumers → DB services) ---
      echo ""
      echo "DNS RESOLUTION:"
      db_services=""
      for db in "${db_names[@]}"; do
        echo "$containers" | grep -qw "$db" && db_services="$db_services $db"
      done

      if [ -z "$db_services" ]; then
        echo "  SKIP: no database services on '$network' network"
      else
        # Pick up to 3 non-DB containers as representative consumers
        consumers=""
        for c in $containers; do
          is_db=false
          for db in "${db_names[@]}"; do
            [ "$c" = "$db" ] && is_db=true && break
          done
          $is_db && continue
          case "$c" in adminer|dockerproxy|dozzle|dozzle-agent|beszel-agent|rickroll|cloudflareddns) continue;; esac
          consumers="$consumers $c"
          count_c=$(echo "$consumers" | wc -w)
          [ "$count_c" -ge 3 ] && break
        done

        for src in $consumers; do
          for dst in $db_services; do
            if docker exec "$src" getent hosts "$dst" >/dev/null 2>&1; then
              echo "  OK: $src -> $dst (getent)"
            elif docker exec "$src" ping -c 1 -W 2 "$dst" >/dev/null 2>&1; then
              echo "  OK: $src -> $dst (ping)"
            else
              echo "  FAIL: $src cannot resolve '$dst'"
              errors=$((errors + 1))
            fi
          done
        done
      fi

      # --- 3. TCP connectivity for DB services (check via published host ports) ---
      echo ""
      echo "TCP CONNECTIVITY:"
      for i in "${!db_names[@]}"; do
        db="${db_names[$i]}"
        port="${db_ports[$i]}"
        if echo "$containers" | grep -qw "$db"; then
          if timeout 3 bash -c "echo > /dev/tcp/127.0.0.1/$port" 2>/dev/null; then
            echo "  OK: $db:$port reachable"
          else
            echo "  FAIL: $db:$port not reachable"
            errors=$((errors + 1))
          fi
        else
          echo "  SKIP: $db not on '$network' network"
        fi
      done

      echo ""
      if [ "$errors" -gt 0 ]; then
        echo "RESULT: $errors failure(s) — cross-stack networking is broken"
        exit 1
      fi
      echo "RESULT: All DNS and TCP checks passed"
    executable: /bin/bash
  environment:
    DB_SERVICE_NAMES: "{{ (_db_service_names | default(['postgres', 'mariadb'])) | join(',') }}"
    DB_SERVICE_PORTS: "{{ (_db_service_names | default(['postgres', 'mariadb'])) | map('extract', _db_service_ports | default({'postgres': 5432, 'mariadb': 3306})) | join(',') }}"
  register: _network_check
  changed_when: false
  when: not ansible_check_mode

- name: Display network verification results
  ansible.builtin.debug:
    msg: "{{ _network_check.stdout }}"
  when: not ansible_check_mode

- name: Set network summary fact
  ansible.builtin.set_fact:
    _network_summary: "{{ _network_check.stdout_lines | last | default('check mode — skipped') }}"
  when: not ansible_check_mode

- name: Set network summary fact (check mode)
  ansible.builtin.set_fact:
    _network_summary: "check mode — skipped"
  when: ansible_check_mode
