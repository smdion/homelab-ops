---
# Back up a single Docker Compose stack's appdata.
# Called in a loop from backup_hosts.yaml with loop_var: _backup_stack.
#
# Stops the stack, archives its appdata + compose dir, verifies integrity,
# starts the stack, and records the result. On failure the stack is restarted
# and the failure is recorded (not re-raised — caller checks _stack_backup_results).
#
# Required (from caller scope):
#   _backup_stack         — stack name (e.g. 'auth', 'vpn')
#   backup_tmp_dir        — temp directory for archive creation
#   ansible_date_time     — gathered fact
#   _stack_backup_results — list to append results to (caller initializes to [])
#   backup_base_dir       — controller-side backup root (for fetch dest)

- name: Set archive filename for {{ _backup_stack }}
  ansible.builtin.set_fact:
    _stack_archive_name: "backup_{{ _backup_stack }}_{{ ansible_date_time.date }}.tar.gz"
  tags: [always]

- block:
    - name: Stop {{ _backup_stack }} stack
      include_tasks: tasks/docker_stop.yaml
      vars:
        _docker_selective_stacks: ["{{ _backup_stack }}"]

    - name: Discover backup paths from container labels for {{ _backup_stack }}
      become: true
      ansible.builtin.shell: |
        ids=$(docker ps -a -q \
          --filter "label=com.docker.compose.project={{ _backup_stack }}" \
          --filter "label=homelab.backup.paths")
        [ -z "$ids" ] && exit 0
        echo "$ids" | xargs docker inspect \
          --format '{% raw %}{{index .Config.Labels "homelab.backup.paths"}}{% endraw %}' \
          | tr ',' '\n' | sed '/^$/d' | sort -u
      register: _label_backup_paths
      changed_when: false
      check_mode: false

    - name: Compute archive paths for {{ _backup_stack }}
      ansible.builtin.set_fact:
        _backup_archive_paths: >-
          {{ (_label_backup_paths.stdout_lines | default([]) | reject('eq', '') | list)
             + ['/opt/stacks/' + _backup_stack] }}

    - name: Filter to existing paths for {{ _backup_stack }}
      ansible.builtin.stat:
        path: "{{ item }}"
      loop: "{{ _backup_archive_paths }}"
      register: _backup_paths_stat

    - name: Set validated paths for {{ _backup_stack }}
      ansible.builtin.set_fact:
        _validated_archive_paths: >-
          {{ _backup_paths_stat.results
             | selectattr('stat', 'defined')
             | selectattr('stat.exists')
             | map(attribute='item') | list }}

    - name: Create compressed archive for {{ _backup_stack }}
      become: true
      ansible.builtin.shell: >
        tar czf "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
        -C /
        {{ _validated_archive_paths | map('regex_replace', '^/', '') | join(' ') }}
      timeout: "{{ stack_backup_timeout | default(1800) }}"

    - name: Verify archive integrity for {{ _backup_stack }}
      become: true
      ansible.builtin.shell: gunzip -t "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
      changed_when: false
      check_mode: false

    - name: Get archive file size for {{ _backup_stack }}
      ansible.builtin.stat:
        path: "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
      register: _stack_file_size
      changed_when: false

    - name: Fetch {{ _backup_stack }} archive to controller
      ansible.builtin.fetch:
        src: "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
        dest: "{{ backup_base_dir }}/{{ inventory_hostname }}/{{ _stack_archive_name }}"
        flat: true
      become: false

    - name: Record success for {{ _backup_stack }}
      ansible.builtin.set_fact:
        _stack_backup_results: >-
          {{ _stack_backup_results + [{'stack': _backup_stack,
             'file': _stack_archive_name,
             'file_size': _stack_file_size.stat.size | default(0),
             'failed': false}] }}

  rescue:
    - name: Record failure for {{ _backup_stack }}
      ansible.builtin.set_fact:
        _stack_backup_results: >-
          {{ _stack_backup_results + [{'stack': _backup_stack,
             'file': _stack_archive_name,
             'file_size': 0,
             'failed': true}] }}

  always:
    - name: Start {{ _backup_stack }} stack
      include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_stacks: ["{{ _backup_stack }}"]
        _docker_ignore_errors: true

    - name: Delete temp archive for {{ _backup_stack }}
      become: true
      ansible.builtin.file:
        path: "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
        state: absent
