---
# Back up a single Docker Compose stack's appdata.
# Called in a loop from backup_hosts.yaml with loop_var: _backup_stack.
#
# Stops the stack, archives its appdata + compose dir, restarts the stack,
# then fetches the archive to the controller (stack is back online during transfer).
# On failure the stack is restarted and the failure is recorded
# (not re-raised — caller checks _stack_backup_results).
#
# Required (from caller scope):
#   _backup_stack         — stack name (e.g. 'auth', 'vpn')
#   backup_tmp_dir        — temp directory for archive creation
#   ansible_date_time     — gathered fact
#   _stack_backup_results — list to append results to (caller initializes to [])
#   backup_base_dir       — controller-side backup root (for fetch dest)

- name: Set archive filename for {{ _backup_stack }}
  ansible.builtin.set_fact:
    _stack_archive_name: "backup_{{ _backup_stack }}_{{ ansible_date_time.date }}.tar.gz"

- block:
    - name: Stop {{ _backup_stack }} stack
      include_tasks: tasks/docker_stop.yaml
      vars:
        _docker_selective_stacks: ["{{ _backup_stack }}"]

    - name: Discover backup paths from container labels for {{ _backup_stack }}
      become: true
      ansible.builtin.shell: |
        ids=$(docker ps -a -q \
          --filter "label=com.docker.compose.project={{ _backup_stack }}" \
          --filter "label=homelab.backup.paths")
        [ -z "$ids" ] && exit 0
        echo "$ids" | xargs docker inspect \
          --format '{% raw %}{{index .Config.Labels "homelab.backup.paths"}}{% endraw %}' \
          | tr ',' '\n' | sed '/^$/d' | sort -u
      register: _label_backup_paths
      changed_when: false
      check_mode: false

    - name: Discover backup excludes from container labels for {{ _backup_stack }}
      become: true
      ansible.builtin.shell: |
        ids=$(docker ps -a -q \
          --filter "label=com.docker.compose.project={{ _backup_stack }}" \
          --filter "label=homelab.backup.exclude")
        [ -z "$ids" ] && exit 0
        echo "$ids" | xargs docker inspect \
          --format '{% raw %}{{index .Config.Labels "homelab.backup.exclude"}}{% endraw %}' \
          | tr ',' '\n' | sed '/^$/d' | sort -u
      register: _label_backup_excludes
      changed_when: false
      check_mode: false

    - name: Compute archive paths for {{ _backup_stack }}
      ansible.builtin.set_fact:
        _backup_archive_paths: >-
          {{ (_label_backup_paths.stdout_lines | default([]) | reject('eq', '') | list)
             + ['/opt/stacks/' + _backup_stack] }}

    - name: Filter to existing paths for {{ _backup_stack }}
      ansible.builtin.stat:
        path: "{{ item }}"
      loop: "{{ _backup_archive_paths }}"
      register: _backup_paths_stat

    - name: Set validated paths for {{ _backup_stack }}
      ansible.builtin.set_fact:
        _validated_archive_paths: >-
          {{ _backup_paths_stat.results
             | selectattr('stat', 'defined')
             | selectattr('stat.exists')
             | map(attribute='item') | list }}

    - name: Create compressed archive for {{ _backup_stack }}
      become: true
      ansible.builtin.shell: >
        _gz=$(command -v pigz >/dev/null 2>&1 && echo pigz || echo gzip);
        tar -I "$_gz -1" -cf "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
        {% for excl in (_label_backup_excludes.stdout_lines | default([]) | reject('eq', '') | list) %}
        --exclude='{{ excl }}'
        {% endfor %}
        -C /
        {{ _validated_archive_paths | map('regex_replace', '^/', '') | join(' ') }}
      timeout: "{{ stack_backup_timeout | default(1800) }}"

    - name: Get archive file size for {{ _backup_stack }}
      ansible.builtin.stat:
        path: "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
      register: _stack_file_size
      changed_when: false

    - name: Start {{ _backup_stack }} stack (reduce downtime during fetch)
      include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_stacks: ["{{ _backup_stack }}"]
        _docker_ignore_errors: true

    - name: Ensure stack backup directory on controller for {{ _backup_stack }}
      ansible.builtin.file:
        path: "{{ backup_base_dir }}/{{ _backup_stack }}"
        state: directory
      delegate_to: localhost
      become: false

    - name: Delete stale archive on controller for {{ _backup_stack }}
      ansible.builtin.file:
        path: "{{ backup_base_dir }}/{{ _backup_stack }}/{{ _stack_archive_name }}"
        state: absent
      delegate_to: localhost
      become: false

    - name: Fetch {{ _backup_stack }} archive to controller
      ansible.builtin.fetch:
        src: "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
        dest: "{{ backup_base_dir }}/{{ _backup_stack }}/{{ _stack_archive_name }}"
        flat: true
      become: false

    - name: Record success for {{ _backup_stack }}
      ansible.builtin.set_fact:
        _stack_backup_results: >-
          {{ _stack_backup_results + [{'stack': _backup_stack,
             'file': _stack_archive_name,
             'file_size': _stack_file_size.stat.size | default(0),
             'failed': false}] }}

  rescue:
    - name: Record failure for {{ _backup_stack }}
      ansible.builtin.set_fact:
        _stack_backup_results: >-
          {{ _stack_backup_results + [{'stack': _backup_stack,
             'file': _stack_archive_name,
             'file_size': 0,
             'failed': true}] }}

  always:
    - name: Start {{ _backup_stack }} stack
      include_tasks: tasks/docker_start.yaml
      vars:
        _docker_selective_stacks: ["{{ _backup_stack }}"]
        _docker_ignore_errors: true

    - name: Delete temp archive for {{ _backup_stack }}
      become: true
      ansible.builtin.file:
        path: "{{ backup_tmp_dir }}/{{ _stack_archive_name }}"
        state: absent
