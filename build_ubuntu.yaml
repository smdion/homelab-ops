---
# Provision Ubuntu VMs on Proxmox via API.
# Play 1 (localhost): Ensure cloud-init template, clone/configure/boot VM,
#   or destroy if vm_state=absent.
# Play 2 (new VM): Bootstrap Ubuntu with Docker and security hardening.
# Deploy stacks separately via deploy_stacks.yaml after provisioning.
#
# The cloud-init template is created automatically on first run (one-time per cluster).
# It downloads the Ubuntu Noble cloud image and converts it to a Proxmox template
# on Ceph (replicated) storage, accessible from all nodes.
#
# Usage:
#   ansible-playbook build_ubuntu.yaml -e vm_name=test-vm
#   ansible-playbook build_ubuntu.yaml -e vm_name=test-vm -e vm_state=absent
#
# Required extra vars:
#   vm_name — key in vm_definitions (tantiveiv, odyssey, amp, test-vm)
#
# Optional extra vars:
#   vm_state=absent — destroy VM instead of creating

# ═══════════════════════════════════════════════════════════════════
# Play 1 — Provision or destroy VM on Proxmox
# ═══════════════════════════════════════════════════════════════════
- name: Provision Ubuntu VM on Proxmox
  hosts: localhost
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
  vars:
    maintenance_name: "Ubuntu"
    maintenance_type: "Servers"
    maintenance_subtype: "Build"

  pre_tasks:
    - name: Assert vm_name is defined and exists in vm_definitions
      ansible.builtin.assert:
        that:
          - vm_name is defined
          - vm_name in vm_definitions
        fail_msg: >-
          vm_name '{{ vm_name | default('undefined') }}' not found in vm_definitions.
          Valid names: {{ vm_definitions.keys() | list | join(', ') }}

    - name: Resolve VM definition
      ansible.builtin.set_fact:
        _vm: "{{ vm_definitions[vm_name] }}"
        _vm_state: "{{ vm_state | default('present') }}"

    - name: Assert MariaDB logging database is reachable
      include_tasks: tasks/assert_db_connectivity.yaml

  tasks:
    - name: Initialize build state
      ansible.builtin.set_fact:
        build_failed: false
        _build_detail: ""

    - block:
        # ═════════════════════════════════════════════════════════
        # CREATE PATH — vm_state == 'present' (default)
        # ═════════════════════════════════════════════════════════

        # --- Ensure cloud-init template exists (one-time per cluster) ---
        - name: Add PVE host to in-memory inventory
          ansible.builtin.add_host:
            name: pve_builder
            ansible_host: "{{ pve_api_host }}"
            ansible_user: ansible
          when: _vm_state == 'present'

        - name: Ensure cloud-init template exists on Ceph storage
          delegate_to: pve_builder
          become: true
          ansible.builtin.shell: |
            if [ -f /etc/pve/qemu-server/{{ pve_template_vmid }}.conf ]; then
              echo "Template already exists"
              exit 0
            fi
            set -e
            cd /tmp
            wget -q "{{ pve_cloud_image_url }}" -O ubuntu-cloud.img
            qm create {{ pve_template_vmid }} \
              --name {{ pve_template_name }} \
              --memory 2048 --cores 2 \
              --net0 virtio,bridge={{ pve_bridge }}
            qm importdisk {{ pve_template_vmid }} ubuntu-cloud.img {{ pve_storage }}
            qm set {{ pve_template_vmid }} \
              --scsi0 {{ pve_storage }}:vm-{{ pve_template_vmid }}-disk-0 \
              --scsihw virtio-scsi-single
            qm set {{ pve_template_vmid }} \
              --ide2 {{ pve_storage }}:cloudinit \
              --boot order=scsi0
            qm template {{ pve_template_vmid }}
            rm -f ubuntu-cloud.img
            echo "Template created"
          register: _template_result
          changed_when: "'Template created' in _template_result.stdout"
          when: _vm_state == 'present'

        # --- Clone template to new VM ---
        - name: Clone VM from cloud-init template
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ pve_template_node }}"
            clone: "{{ pve_template_name }}"
            newid: "{{ _vm.vm_id }}"
            name: "{{ _vm.vm_name }}"
            full: true
            storage: "{{ pve_storage }}"
            target: "{{ _vm.pve_target_node }}"
            timeout: 300
          no_log: true
          when: _vm_state == 'present'

        # --- Configure hardware and cloud-init ---
        - name: Configure VM hardware and cloud-init
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ _vm.pve_target_node }}"
            vmid: "{{ _vm.vm_id }}"
            cores: "{{ _vm.vm_cores }}"
            memory: "{{ _vm.vm_memory_mb }}"
            ciuser: "{{ vm_user }}"
            cipassword: "{{ vm_password }}"
            sshkeys: "{{ ansible_user_ssh_pubkey }}"
            ipconfig:
              ipconfig0: "ip={{ _vm.vm_ip }}/{{ vm_cidr }},gw={{ vm_gateway }}"
            nameservers: "{{ vm_dns }}"
            searchdomains: "{{ vm_search_domain }}"
            update: true
          no_log: true
          when: _vm_state == 'present'

        # --- Resize disk from cloud image (~3.5G) to target size ---
        - name: Resize VM disk
          ansible.builtin.uri:
            url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ _vm.pve_target_node }}/qemu/{{ _vm.vm_id }}/resize"
            method: PUT
            headers:
              Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
            body_format: form-urlencoded
            body:
              disk: scsi0
              size: "{{ _vm.vm_disk_gb }}G"
            validate_certs: false
          no_log: true
          when: _vm_state == 'present'

        # --- Start and wait ---
        - name: Start VM
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ _vm.pve_target_node }}"
            vmid: "{{ _vm.vm_id }}"
            state: started
          no_log: true
          when: _vm_state == 'present'

        - name: Wait for SSH
          ansible.builtin.wait_for:
            host: "{{ _vm.vm_ip }}"
            port: 22
            delay: 10
            timeout: 300
          when: _vm_state == 'present'

        - name: Add new VM to in-memory inventory
          ansible.builtin.add_host:
            name: "{{ _vm.vm_hostname }}"
            ansible_host: "{{ _vm.vm_ip }}"
            ansible_user: "{{ vm_user }}"
            groups: build_target
          when: _vm_state == 'present'

        # ═════════════════════════════════════════════════════════
        # DESTROY PATH — vm_state == 'absent'
        # ═════════════════════════════════════════════════════════
        - name: Stop VM
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ _vm.pve_target_node }}"
            vmid: "{{ _vm.vm_id }}"
            state: stopped
            force: true
          no_log: true
          when: _vm_state == 'absent'

        - name: Remove VM
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ _vm.pve_target_node }}"
            vmid: "{{ _vm.vm_id }}"
            state: absent
          no_log: true
          when: _vm_state == 'absent'

        - name: Record build detail
          ansible.builtin.set_fact:
            _build_detail: >-
              {{ 'VM destroyed' if _vm_state == 'absent' else 'VM provisioned' }}:
              {{ _vm.vm_name }} ({{ _vm.vm_ip }}) on {{ _vm.pve_target_node }}

      rescue:
        - name: Set build failed flag
          ansible.builtin.set_fact:
            build_failed: true
            _build_detail: "{{ ansible_failed_result.msg | default('check Semaphore logs') }}"

      always:
        - name: Send Discord notification
          include_tasks: tasks/notify_discord.yaml
          vars:
            discord_title: "{{ maintenance_name }}"
            discord_description: "{{ _vm_state | capitalize }} {{ 'Failed' if build_failed else 'Successful' }}"
            discord_color: "{{ 16711680 if build_failed else 32768 }}"
            discord_url: "{{ semaphore_ext_url }}"
            discord_author: "{{ controller_fqdn }}"
            discord_fields:
              - name: "Description"
                value: "Ubuntu VM {{ _vm_state }}"
              - name: "VM Name"
                value: "{{ _vm.vm_name }}"
              - name: "Host IP"
                value: "{{ _vm.vm_ip }}"
              - name: "Proxmox Node"
                value: "{{ _vm.pve_target_node }}"
              - name: "Detail"
                value: "{{ _build_detail }}"

        - name: Log build to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          vars:
            log_table: maintenance
            log_application: "{{ maintenance_name }}"
            log_hostname: "{{ controller_fqdn }}"
            log_type: "{{ maintenance_type }}"
            log_subtype: "{{ maintenance_subtype }}"
            log_status: "{{ 'failed' if build_failed else 'success' }}"

        - name: Fail play if build failed
          ansible.builtin.fail:
            msg: "Build failed: {{ _build_detail }}"
          when: build_failed

# ═══════════════════════════════════════════════════════════════════
# Play 2 — Bootstrap Ubuntu (skipped when vm_state=absent)
# ═══════════════════════════════════════════════════════════════════
- name: Bootstrap Ubuntu VM
  hosts: build_target
  become: true
  gather_facts: true
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
  vars:
    maintenance_name: "Ubuntu"
    maintenance_type: "Servers"
    maintenance_subtype: "Build"

  tasks:
    - name: Initialize bootstrap state
      ansible.builtin.set_fact:
        bootstrap_failed: false
        _bootstrap_detail: ""

    - block:
        - name: Wait for cloud-init to finish
          ansible.builtin.command: cloud-init status --wait
          register: _cloud_init
          changed_when: false
          failed_when: "'status: done' not in _cloud_init.stdout"

        - name: Wait for apt lock to be released
          ansible.builtin.shell: while fuser /var/lib/dpkg/lock-frontend >/dev/null 2>&1; do sleep 5; done
          changed_when: false

        - name: Update and upgrade apt packages
          ansible.builtin.apt:
            update_cache: true
            upgrade: dist

        - name: Install base packages
          ansible.builtin.apt:
            name:
              - docker.io
              - docker-compose-v2
              - python3-pip
              - python3-docker
              - nfs-common
              - curl
              - htop
              - unattended-upgrades
            state: present

        - name: Enable Docker service
          ansible.builtin.systemd:
            name: docker
            enabled: true
            state: started

        - name: Add user to docker and sudo groups
          ansible.builtin.user:
            name: "{{ vm_user }}"
            groups: docker,sudo
            append: true

        - name: Grant passwordless sudo
          ansible.builtin.copy:
            content: |
              # Passwordless sudo for Ansible automation — required for playbooks to
              # execute privileged tasks (apt, docker, systemctl, etc.) without prompts.
              {{ vm_user }} ALL=(ALL) NOPASSWD: ALL
            dest: "/etc/sudoers.d/{{ vm_user }}"
            mode: "0440"
            owner: root
            group: root
            validate: /usr/sbin/visudo -cf %s

        - name: Harden SSH configuration
          ansible.builtin.lineinfile:
            path: /etc/ssh/sshd_config
            regexp: "{{ item.regexp }}"
            line: "{{ item.line }}"
            state: present
          loop:
            - { regexp: '^#?PermitRootLogin', line: 'PermitRootLogin prohibit-password' }
            - { regexp: '^#?PasswordAuthentication', line: 'PasswordAuthentication no' }
            - { regexp: '^#?PubkeyAcceptedAlgorithms', line: 'PubkeyAcceptedAlgorithms +ssh-rsa' }
          register: _ssh_config

        - name: Restart sshd
          ansible.builtin.systemd:
            name: ssh
            state: restarted
          when: _ssh_config is changed

        - name: Enable UFW with default deny incoming
          community.general.ufw:
            state: enabled
            default: deny
            direction: incoming

        - name: Allow SSH through UFW
          community.general.ufw:
            rule: allow
            port: "22"
            proto: tcp

        - name: Record bootstrap detail
          ansible.builtin.set_fact:
            _bootstrap_detail: "Bootstrap complete — Docker, security hardening"

      rescue:
        - name: Set bootstrap failed flag
          ansible.builtin.set_fact:
            bootstrap_failed: true
            _bootstrap_detail: "{{ ansible_failed_result.msg | default('check Semaphore logs') }}"

      always:
        - name: Send Discord notification
          include_tasks: tasks/notify_discord.yaml
          vars:
            discord_title: "{{ maintenance_name }}"
            discord_description: "Bootstrap {{ 'Failed' if bootstrap_failed else 'Complete' }}"
            discord_color: "{{ 16711680 if bootstrap_failed else 32768 }}"
            discord_url: "{{ semaphore_ext_url }}"
            discord_fields:
              - name: "Description"
                value: "Ubuntu VM bootstrap"
              - name: "Host"
                value: "{{ inventory_hostname }}"
              - name: "Detail"
                value: "{{ _bootstrap_detail }}"

        - name: Log bootstrap to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          vars:
            log_table: maintenance
            log_application: "{{ maintenance_name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_type: "{{ maintenance_type }}"
            log_subtype: "{{ maintenance_subtype }}"
            log_status: "{{ 'failed' if bootstrap_failed else 'success' }}"

        - name: Fail play if bootstrap failed
          ansible.builtin.fail:
            msg: "Bootstrap failed: {{ _bootstrap_detail }}"
          when: bootstrap_failed
