---
# Automated restore testing on a disposable VM.
# Builds VM if needed, restores source host's appdata, deploys stacks,
# verifies container health, and reverts to clean state.
# Also serves as a DR recovery tool via -e dr_mode=yes.
#
# Usage:
#   # Test a role's stacks (vm_name defaults to test-vm, vm_index auto-detected)
#   ansible-playbook test_restore.yaml -e role=apps
#
#   # Persistent DR recovery (keeps restored state, no revert)
#   ansible-playbook test_restore.yaml -e role=apps -e dr_mode=yes
#
#   # Test single app restore
#   ansible-playbook test_restore.yaml -e role=core -e restore_app=authentik
#
#   # Deploy SSH key for cross-host delegate_to (e.g. DB restores)
#   ansible-playbook test_restore.yaml -e role=core -e deploy_ssh_key=yes
#
#   # Test a specific host's stacks (legacy — prefer role=)
#   ansible-playbook test_restore.yaml -e source_host=<controller-fqdn>
#
# Extra vars:
#   vm_name      — VM key from vm_definitions (default: test-vm).
#                  Do NOT use permanent VM keys (core, apps, dev).
#   source_host  — inventory_hostname in stack_assignments (OR use role instead)
#   role         — stack role name (e.g. core, apps, dev) — alternative to source_host
#   deploy_ssh_key=yes — install ansible SSH private key on VM (for cross-host operations)
#
# VM lifecycle (provision_vm.yaml is idempotent):
#   - If the VMID doesn't exist, the VM is provisioned from the cloud-init template
#   - If the VMID already exists (e.g. from a prior partial run), clone is skipped and
#     provisioning resumes from configure/start — no manual cleanup needed
#   - Node resolution uses the cluster resources API — VIP-safe regardless of which
#     PVE node is currently MASTER
#   - After restore: snapshot is reverted, VM stays running and ready for next test
#   - In dr_mode=yes: no revert — VM keeps the restored state for real DR recovery
#
# Optional extra vars:
#   vm_index=N    — test-vm slot 0..9; auto-detected (lowest non-running slot) if omitted
#   restore_app   — single app name to selectively extract from archive
#   stack         — single stack to deploy (instead of all assigned stacks)
#   dr_mode=yes   — DR recovery mode (skip snapshot/revert, keep state)
#   skip_dbs      — comma-separated DB names to skip restoring (e.g. -e skip_dbs=nextcloud)

# ═══════════════════════════════════════════════════════════════════
# Play 1 — Prepare: Validate, find backup, build VM if needed, snapshot
# ═══════════════════════════════════════════════════════════════════
- name: Prepare test restore
  hosts: localhost
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/proxmox.yaml
    - vars/docker_stacks.yaml
    - vars/vm_definitions.yaml
    - vars/app_definitions.yaml
    - vars/semaphore_check.yaml
  vars:
    maintenance_name: "Docker"
    maintenance_type: "Servers"
    maintenance_subtype: "Test Restore"

  pre_tasks:
    - name: Default vm_name to test-vm
      ansible.builtin.set_fact:
        vm_name: "{{ vm_name | default('test-vm') }}"

    - name: Run shared test pre-flight assertions
      include_tasks: tasks/pre_test_assertions.yaml
      vars:
        _require_source_or_role: true

    - name: Run standard pre-flight assertions for test_restore
      include_tasks: tasks/pre_task_assertions.yaml
      vars:
        pre_playbook: "test_restore.yaml"
        pre_hostname: "{{ controller_fqdn }}"
        pre_run_vars: "{{ {'vm_name': vm_name | default('')} | to_json }}"

  tasks:
    - name: Auto-detect free vm_index for test-vm pool
      include_tasks: tasks/resolve_test_vm_index.yaml
      when: vm_name == 'test-vm'

    - name: Resolve test VM and target stack configuration
      ansible.builtin.set_fact:
        _vm: "{{ vm_definitions[vm_name] }}"
        _stacks: >-
          {{ [stack] if stack is defined
             else stack_roles[role] if role is defined and source_host is not defined
             else stack_assignments[source_host] }}

    # ===== FIND BACKUP ARCHIVES =====
    # Requires the container user to have read access to the /backup/ bind
    # mount (e.g. via group_add: 100 for the users group on unRAID).
    - name: Find per-stack backup archives from production backups (read-only)
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ item }}/backup_{{ item }}_*.tar.gz 2>/dev/null | head -1
      loop: "{{ _stacks }}"
      register: _per_stack_archives
      become: false
      changed_when: false
      check_mode: false

    - name: Set per-stack archive list
      ansible.builtin.set_fact:
        _archive_files: "{{ _per_stack_archives.results | selectattr('stdout', 'ne', '') | map(attribute='stdout') | list }}"

    - name: Assert backup archives exist
      ansible.builtin.assert:
        that: _archive_files | length > 0
        fail_msg: "No per-stack backup archives found in {{ backup_base_dir }}/ for stacks: {{ _stacks | join(', ') }}"

    # ===== FIND DB SQL DUMP ARCHIVES =====
    # Load each DB vars file and capture config into explicit facts (include_vars
    # with name: has scoping issues where the namespaced dict is empty in
    # subsequent loop expressions).
    # Only restore DBs whose container is defined in one of the deployed stacks
    # (e.g. postgres-immich on Unraid is skipped when restoring core).
    - name: Collect container names from deployed stacks
      ansible.builtin.shell: >
        grep -h 'container_name:' {% for s in _stacks %}stacks/{{ s }}/docker-compose.yaml {% endfor %}
        2>/dev/null | awk '{print $2}' | sort -u
      register: _stack_containers
      changed_when: false

    - name: Load postgres DB config from vars
      ansible.builtin.include_vars:
        file: vars/db_primary_postgres.yaml
      when: "'databases' in _stacks"

    - name: Save postgres DB config to Ansible facts
      ansible.builtin.set_fact:
        _db_postgres_all_names: "{{ db_names }}"
        _db_postgres_container: "{{ db_container_name }}"
        _db_postgres_username: "{{ db_username }}"
      when:
        - "'databases' in _stacks"
        - db_container_name in _stack_containers.stdout_lines

    - name: Load mariadb DB config from vars
      ansible.builtin.include_vars:
        file: vars/db_primary_mariadb.yaml
      when: "'databases' in _stacks"

    - name: Save mariadb DB config to Ansible facts
      ansible.builtin.set_fact:
        _db_mariadb_all_names: "{{ db_names }}"
        _db_mariadb_container: "{{ db_container_name }}"
        _db_mariadb_username: "{{ db_username }}"
      when:
        - "'databases' in _stacks"
        - db_container_name in _stack_containers.stdout_lines

    - name: Load secondary postgres DB config from vars
      ansible.builtin.include_vars:
        file: vars/db_secondary_postgres.yaml
      when: "'databases' in _stacks"

    - name: Save secondary postgres DB config to Ansible facts
      ansible.builtin.set_fact:
        _db_secondary_postgres_all_names: "{{ db_names }}"
        _db_secondary_postgres_container: "{{ db_container_name }}"
        _db_secondary_postgres_username: "{{ db_username }}"
      when:
        - "'databases' in _stacks"
        - db_container_name in _stack_containers.stdout_lines

    - name: Filter skipped DBs from restore lists
      ansible.builtin.set_fact:
        _db_postgres_all_names: "{{ _db_postgres_all_names | difference(skip_dbs.split(',')) }}"
        _db_mariadb_all_names: "{{ _db_mariadb_all_names | difference(skip_dbs.split(',')) }}"
        _db_secondary_postgres_all_names: "{{ _db_secondary_postgres_all_names | difference(skip_dbs.split(',')) }}"
      when:
        - skip_dbs | default('') | length > 0
        - "'databases' in _stacks"

    - name: Default DB facts when databases stack absent
      ansible.builtin.set_fact:
        _db_postgres_all_names: []
        _db_mariadb_all_names: []
        _db_secondary_postgres_all_names: []
        _db_postgres_container: ""
        _db_mariadb_container: ""
        _db_secondary_postgres_container: ""
        _db_postgres_username: ""
        _db_mariadb_username: ""
        _db_secondary_postgres_username: ""
      when: "'databases' not in _stacks"

    - name: Find latest SQL dump per database — {{ item }}
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/databases/backup_{{ item }}_*.sql {{ backup_base_dir }}/databases/backup_{{ item }}_*.sql.gz 2>/dev/null | head -1
      loop: "{{ _db_postgres_all_names + _db_mariadb_all_names + _db_secondary_postgres_all_names }}"
      register: _db_dump_results
      become: false
      changed_when: false
      check_mode: false
      when: (_db_postgres_all_names + _db_mariadb_all_names + _db_secondary_postgres_all_names) | length > 0

    - name: Build DB archive map and name lists
      ansible.builtin.set_fact:
        _db_archive_map: >-
          {{ dict(_db_dump_results.results | default([])
                  | selectattr('stdout', 'defined')
                  | selectattr('stdout', 'ne', '')
                  | map(attribute='item') | list
                  | zip(_db_dump_results.results | default([])
                        | selectattr('stdout', 'defined')
                        | selectattr('stdout', 'ne', '')
                        | map(attribute='stdout') | list)) }}
        _db_postgres_names: >-
          {{ _db_dump_results.results | default([])
             | selectattr('stdout', 'defined')
             | selectattr('stdout', 'ne', '')
             | map(attribute='item') | list
             | intersect(_db_postgres_all_names) }}
        _db_mariadb_names: >-
          {{ _db_dump_results.results | default([])
             | selectattr('stdout', 'defined')
             | selectattr('stdout', 'ne', '')
             | map(attribute='item') | list
             | intersect(_db_mariadb_all_names) }}
        _db_secondary_postgres_names: >-
          {{ _db_dump_results.results | default([])
             | selectattr('stdout', 'defined')
             | selectattr('stdout', 'ne', '')
             | map(attribute='item') | list
             | intersect(_db_secondary_postgres_all_names) }}

    - name: Report DB backup discovery
      ansible.builtin.debug:
        msg: >-
          DB dumps found: {{ _db_archive_map | length }}/{{ (_db_postgres_all_names + _db_mariadb_all_names + _db_secondary_postgres_all_names) | length }}.
          Postgres: {{ _db_postgres_names | join(', ') or 'none' }}.
          MariaDB: {{ _db_mariadb_names | join(', ') or 'none' }}.
          Secondary Postgres: {{ _db_secondary_postgres_names | join(', ') or 'none' }}.
          {{ _db_archive_map | to_nice_yaml if _db_archive_map | length > 0 else '' }}

    - name: Verify archive integrity
      ansible.builtin.shell: |
        {{ _gz_detect }}
        $_gz -t "{{ item }}"
      loop: "{{ _archive_files }}"
      become: false
      changed_when: false
      check_mode: false

    # ===== RESOLVE OR PROVISION VM =====
    - name: Resolve or provision test VM
      include_tasks: tasks/resolve_or_provision_vm.yaml
      vars:
        _provision_target_group: test_target

# ═══════════════════════════════════════════════════════════════════
# Play 2 — Bootstrap (new VM or Docker missing)
# ═══════════════════════════════════════════════════════════════════
- name: Bootstrap test VM
  hosts: test_target
  become: true
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/docker_vips.yaml

  tasks:
    - name: Wait for test VM system boot to complete
      ansible.builtin.wait_for_connection:
        delay: 5
        timeout: 300

    - name: Gather Ansible facts for test VM
      ansible.builtin.setup:

    - name: Resolve Docker stack scope via role injection
      include_tasks: tasks/resolve_scope.yaml

    - name: Inject VRRP priority for unmapped hosts (test VMs)
      ansible.builtin.set_fact:
        vault_docker_vrrp_priorities: >-
          {{ vault_docker_vrrp_priorities | default({})
             | combine({inventory_hostname.split('.')[0]: 100}) }}
      when: _role_injected | default(false)

    - name: Check if Docker is installed on test VM
      ansible.builtin.command: docker --version
      register: _docker_check
      failed_when: false
      changed_when: false
      become: false

    - name: Bootstrap Ubuntu with Docker and security hardening
      include_tasks: tasks/bootstrap_vm.yaml
      vars:
        _vm: "{{ hostvars['localhost']._vm }}"
      when: hostvars[inventory_hostname]._needs_bootstrap | default(false) or _docker_check.rc != 0

# ═══════════════════════════════════════════════════════════════════
# Play 3 — Snapshot clean post-bootstrap state for revert
# ═══════════════════════════════════════════════════════════════════
- name: Create pre-test snapshot
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - vars/proxmox.yaml
    - vars/vm_definitions.yaml

  tasks:
    - name: Get existing Proxmox snapshots for test VM
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:{{ pve_api_port }}/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ vm_definitions[vm_name].vm_id }}/snapshot"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      register: _vm_snapshots
      when: not (dr_mode | default('') == 'yes')

    - name: Delete existing pre-test snapshot if present
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:{{ pve_api_port }}/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ vm_definitions[vm_name].vm_id }}/snapshot/pre-test-restore"
        method: DELETE
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when:
        - not (dr_mode | default('') == 'yes')
        - _vm_snapshots.json.data | selectattr('name', 'equalto', 'pre-test-restore') | list | length > 0

    - name: Wait for VM lock to clear after snapshot delete
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:{{ pve_api_port }}/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ vm_definitions[vm_name].vm_id }}/status/current"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      register: _vm_lock_status
      until: _vm_lock_status.json.data.lock is not defined
      retries: 20
      delay: 3
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when:
        - not (dr_mode | default('') == 'yes')
        - _vm_snapshots.json.data | selectattr('name', 'equalto', 'pre-test-restore') | list | length > 0

    - name: Create pre-test snapshot (post-bootstrap clean state)
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:{{ pve_api_port }}/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ vm_definitions[vm_name].vm_id }}/snapshot"
        method: POST
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        body_format: form-urlencoded
        body:
          snapname: pre-test-restore
          vmstate: 0
        validate_certs: false
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when: not (dr_mode | default('') == 'yes')

# ═══════════════════════════════════════════════════════════════════
# Play 4 — Deploy, Restore, and Health Check
# ═══════════════════════════════════════════════════════════════════
- name: Test restore on VM
  hosts: test_target
  become: true
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/proxmox.yaml
    - vars/docker_stacks.yaml
    - vars/docker_vips.yaml
    - vars/vm_definitions.yaml
    - vars/container_definitions.yaml
    - vars/semaphore_check.yaml
  vars:
    maintenance_name: "Docker"
    maintenance_type: "Servers"
    maintenance_subtype: "Test Restore"
    backup_tmp_dir: "/tmp"

  tasks:
    - name: Assert sufficient disk space on /tmp (staging)
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: /tmp
        assert_disk_min_gb: 2

    - name: Assert sufficient disk space on /opt (appdata)
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: /opt
        assert_disk_min_gb: 5

    - name: Resolve Docker stack scope via role injection
      include_tasks: tasks/resolve_scope.yaml

    - name: Inject VRRP priority for unmapped hosts (test VMs)
      ansible.builtin.set_fact:
        vault_docker_vrrp_priorities: >-
          {{ vault_docker_vrrp_priorities | default({})
             | combine({inventory_hostname.split('.')[0]: 100}) }}
      when: _role_injected | default(false)

    - name: Initialize test restore state variables
      ansible.builtin.set_fact:
        _restore_test_failed: false
        _restore_test_detail: ""

    - name: Ensure shared Docker network exists on test VM
      community.docker.docker_network:
        name: "{{ docker_network_name }}"
        state: present
      become: true

    - block:
        - name: Run restore-deploy-verify pipeline
          include_tasks: tasks/restore_and_deploy.yaml
          vars:
            _test_mode: true

      rescue:
        - name: Set restore test failed flag (rescue)
          ansible.builtin.set_fact:
            _restore_test_failed: true
            _restore_test_detail: "{{ ansible_failed_result.msg | default('check Semaphore logs') }}{{ (' | ' + ansible_failed_result.stdout | trim) if ansible_failed_result.stdout | default('') | trim | length > 0 else '' }}"

      always:
        - name: Clean up temp restore archive on test VM
          ansible.builtin.file:
            path: "/tmp/restore_inplace.tar.gz"
            state: absent

        - name: Send test restore notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ maintenance_name }}"
            discord_operation: "Restore Test"
            discord_status: "{{ 'failed' if _restore_test_failed else 'successful' }}"
            discord_detail: >-
              {{ source_host | default(role | default('unknown')) }}{{ ' (' + restore_app + ')' if restore_app | default('') | length > 0 else '' }}
            discord_color: "{{ discord_color_failure if _restore_test_failed else discord_color_success }}"
            discord_url: "{{ semaphore_ext_url }}"
            discord_author: "{{ controller_fqdn }}"
            discord_fields:
              - name: "Source"
                value: "{{ source_host | default('role: ' + role | default('unknown')) }}"
                inline: true
              - name: "Test VM"
                value: "{{ hostvars['localhost']._vm.vm_name }}"
                inline: true
              - name: "Stacks"
                value: "{{ hostvars['localhost']._stacks | join(', ') }}"
              - name: "Detail"
                value: "{{ _restore_test_detail }}"

        - name: Log test restore to restores table
          include_tasks: tasks/log_restore.yaml
          vars:
            log_hostname: "{{ controller_fqdn }}"
            restore_application: "{{ maintenance_name }}"
            restore_source_file: "{{ hostvars['localhost']._archive_files | map('basename') | join(', ') }}"
            restore_type: "{{ maintenance_type }}"
            restore_subtype: "Appdata"
            restore_operation: "test_restore"
            restore_status: "{{ 'failed' if _restore_test_failed else 'success' }}"
            restore_detail: "{{ _restore_test_detail | default('check Semaphore logs') }}"

# ═══════════════════════════════════════════════════════════════════
# Play 5 — Revert to clean state (skipped in DR mode)
# ═══════════════════════════════════════════════════════════════════
- name: Revert test VM to clean state
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - vars/proxmox.yaml
    - vars/vm_definitions.yaml

  tasks:
    - name: Skip revert in DR mode
      ansible.builtin.debug:
        msg: "DR mode — keeping restored state on {{ vm_definitions[vm_name].vm_name }}"
      when: dr_mode | default('') == 'yes'

    - name: Revert test VM to pre-test snapshot
      block:
        - name: Stop test VM
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ _vm_actual_node }}"
            vmid: "{{ vm_definitions[vm_name].vm_id }}"
            state: stopped
            force: true
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
          ignore_errors: true

        - name: Revert to pre-test snapshot
          ansible.builtin.uri:
            url: "https://{{ pve_api_host }}:{{ pve_api_port }}/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ vm_definitions[vm_name].vm_id }}/snapshot/pre-test-restore/rollback"
            method: POST
            headers:
              Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
            validate_certs: false
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

        - name: Wait for test VM snapshot rollback to complete
          ansible.builtin.pause:
            seconds: 20

        - name: Delete pre-test snapshot
          ansible.builtin.uri:
            url: "https://{{ pve_api_host }}:{{ pve_api_port }}/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ vm_definitions[vm_name].vm_id }}/snapshot/pre-test-restore"
            method: DELETE
            headers:
              Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
            validate_certs: false
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when: not (dr_mode | default('') == 'yes')

    - name: Fail if test restore failed
      ansible.builtin.fail:
        msg: "Test restore failed: {{ hostvars[vm_definitions[vm_name].vm_hostname]._restore_test_detail | default('check Semaphore logs') }}"
      when: hostvars[vm_definitions[vm_name].vm_hostname]._restore_test_failed | default(false)
