---
# Update OS packages and Docker containers.
# Handles apt upgrade (Ubuntu/Proxmox), PiKVM update, AMP update,
# Docker Compose pull+recreate, and unRAID container updates.
# Saves a rollback snapshot before Docker Compose updates (see rollback_docker.yaml).
# Sends Discord notification and logs version changes to MariaDB.
#
# Usage:
#   ansible-playbook update_systems.yaml -e hosts_variable=ubuntu       (OS scope — auto-detected)
#   ansible-playbook update_systems.yaml -e hosts_variable=docker_stacks (Docker scope — auto-detected)
#   ansible-playbook update_systems.yaml -e hosts_variable=amp          (Software scope — auto-detected)
#
# Scope is auto-derived from hosts_variable:
#   docker_stacks, docker_run → docker | amp → software | everything else → os
#   Override: -e update_scope=os|docker|software

- name: Update OS packages and Docker containers
  gather_facts: true
  serial: 1
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/host_definitions.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"
    _version_scope: >-
      {{ update_scope | default(
           'software' if config_file in (_sw_version_commands | default({})).keys()
           else 'docker' if config_file in ['docker_stacks', 'docker_run']
           else 'os'
         ) }}
    _os_version_commands:
      pikvm:  "pacman -Q | grep 'kvmd ' | cut -c 6-"
      ubuntu: "uname -r | sed 's/-generic//'"
      pve:    "pveversion | awk -F'/' '{print $2}'"
      pbs:    "dpkg-query -W -f='${Version}' proxmox-backup-server"
    _sw_version_commands:
      amp:    "ampinstmgr -version | sed -n 's/.*\\(v[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+\\).*/\\1/p'"
  hosts: "{{ hosts_variable }}"

  pre_tasks:
    - name: Put device in RW mode
      raw: rw
      when:
        - _version_scope == 'os'
        - inventory_hostname in groups["pikvm"]
        - not ansible_check_mode

    - name: Assert sufficient disk space for update
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: /
        assert_disk_min_gb: "{{ backup_assert_disk_min_gb | default(2) }}"

    - name: Run standard pre-flight assertions
      include_tasks: tasks/pre_task_assertions.yaml
      vars:
        pre_assert_config_file: true
        pre_playbook: "update_systems.yaml"

    - name: Check Proxmox cluster quorum before update
      when: inventory_hostname in groups['pve'] | default([])
      block:
        - name: Get cluster quorum status
          become: true
          ansible.builtin.shell: pvecm status 2>/dev/null
          register: _pvecm_pre
          changed_when: false
          failed_when: false
          check_mode: false
        - name: Abort if cluster is not quorate
          ansible.builtin.fail:
            msg: "PVE cluster is not quorate — aborting update to avoid instability. Run: pvecm status"
          when: (_pvecm_pre.stdout | regex_search('Quorate:\\s+Yes')) is none

    - name: Deploy get_push_epoch helper script
      ansible.builtin.copy:
        src: files/get_push_epoch.sh
        dest: /tmp/get_push_epoch.sh
        mode: "0644"
      when:
        - _version_scope == 'docker'
        - inventory_hostname in groups["docker_stacks"] | default([]) or
          inventory_hostname in groups["docker_run"] | default([])
        - update_delay_days | default(0) | int > 0

    - name: Assert unRAID update_container script exists
      ansible.builtin.stat:
        path: /usr/local/emhttp/plugins/dynamix.docker.manager/scripts/update_container
      register: _unraid_update_script
      when:
        - _version_scope == 'docker'
        - inventory_hostname in groups["docker_run"] | default([])

    - name: Fail if update_container script missing
      ansible.builtin.fail:
        msg: "unRAID update_container script not found — install the Dynamix Docker Manager plugin"
      when:
        - _version_scope == 'docker'
        - inventory_hostname in groups["docker_run"] | default([])
        - not (_unraid_update_script.stat.exists | default(false))

  tasks:
    - name: Initialize update state
      ansible.builtin.set_fact:
        current_version: "N/A"
        update_failed: false
        previous_version: ""
        _is_docker_update: "{{ config_file in ['docker_stacks', 'docker_run'] }}"
        docker_update_results: []

    - block:
        - name: Get previous version from DB
          vars:
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          become: false
          connection: local
          community.mysql.mysql_query:
            login_host: "{{ logging_db_host }}"
            login_port: "{{ logging_db_port }}"
            login_user: "{{ logging_db_user }}"
            login_password: "{{ logging_db_password }}"
            login_db: "{{ logging_db_name }}"
            query: >-
              SELECT version FROM updates
              WHERE application = %s AND hostname = %s
              ORDER BY id DESC LIMIT 1
            positional_args:
              - "{{ update_name }}"
              - "{{ inventory_hostname }}"
          register: previous_version_result
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
          changed_when: false
          check_mode: false

        - name: Set previous version fact
          ansible.builtin.set_fact:
            previous_version: "{{ previous_version_result.query_result[0][0].version | trim if previous_version_result.query_result[0] | length > 0 else '' }}"

        - name: Update PiKVM
          ansible.builtin.shell: pikvm-update --no-reboot
          register: pikvm_update_result
          failed_when: pikvm_update_result.rc not in [0, 100]
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups["pikvm"]

        - name: Upgrade packages via apt
          become: true
          ansible.builtin.apt:
            update_cache: true
            upgrade: "{{ 'full' if (inventory_hostname in groups['pve'] or inventory_hostname in groups['pbs']) else 'yes' }}"
          when:
            - _version_scope == 'os'
            - >-
              inventory_hostname in groups["ubuntu"] or
              inventory_hostname in groups["pve"] or
              inventory_hostname in groups["pbs"]

        - name: Check if a reboot is required
          ansible.builtin.stat:
            path: /var/run/reboot-required
          register: reboot_required_file
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups["ubuntu"] or inventory_hostname in groups["pve"] or inventory_hostname in groups["pbs"]
          changed_when: false

        - name: Enable PVE node maintenance mode (HA migration)
          ansible.builtin.shell: ha-manager crm-command node-maintenance enable {{ ansible_hostname }}
          become: true
          register: _pve_maint_enabled
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups['pve'] | default([])
            - reboot_required_file.stat.exists | default(false)

        - name: Wait for HA guests to migrate off this node
          ansible.builtin.shell: |
            for i in $(seq 1 36); do
              remaining=$(ha-manager status 2>/dev/null | grep -c "node {{ ansible_hostname }},") || remaining=0
              [ "$remaining" -eq 0 ] && echo "ALL_MIGRATED" && exit 0
              sleep 5
            done
            echo "TIMEOUT: $(ha-manager status 2>/dev/null | grep 'node {{ ansible_hostname }},')"
            exit 1
          register: _ha_migrate_wait
          changed_when: false
          become: true
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups['pve'] | default([])
            - _pve_maint_enabled is not skipped

        - name: Set Ceph maintenance flags before PVE reboot
          ansible.builtin.shell: ceph osd set noout; ceph osd set nobackfill; ceph osd set norebalance
          become: true
          register: _ceph_noout_set
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups['pve'] | default([])
            - _pve_maint_enabled is not skipped

        - name: Reboot machines that require
          ansible.builtin.reboot:
          become: true
          when:
            - _version_scope == 'os'
            - >-
              (reboot_required_file.stat.exists | default(false)) or
              (inventory_hostname in groups["pikvm"] and pikvm_update_result.rc | default(0) == 100)

        - name: Wait for Ceph health to recover after PVE reboot
          ansible.builtin.shell: |
            for i in $(seq 1 30); do
              ceph health 2>/dev/null | grep -qE "^HEALTH_OK" && echo "HEALTH_OK" && exit 0
              sleep 10
            done
            echo "TIMEOUT: $(ceph health 2>/dev/null)"
            exit 1
          register: _ceph_post_reboot
          changed_when: false
          become: true
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups['pve'] | default([])
            - _ceph_noout_set is defined
            - not (_ceph_noout_set is skipped)

        - name: Unset Ceph maintenance flags after PVE reboot
          ansible.builtin.shell: ceph osd unset noout; ceph osd unset nobackfill; ceph osd unset norebalance
          become: true
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups['pve'] | default([])
            - _ceph_noout_set is defined
            - not (_ceph_noout_set is skipped)

        - name: Disable PVE node maintenance mode
          ansible.builtin.shell: ha-manager crm-command node-maintenance disable {{ ansible_hostname }}
          become: true
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups['pve'] | default([])
            - _pve_maint_enabled is defined
            - not (_pve_maint_enabled is skipped)

        - name: Update AMP
          become: true
          become_user: amp
          become_method: su
          become_exe: sudo su -l
          ansible.builtin.shell: >-
            {{ 'ampinstmgr UpgradeInstance ' + amp_instance_filter
               if amp_instance_filter is defined
               else 'ampinstmgr upgradeall' }}
          when:
            - _version_scope == 'software'
            - inventory_hostname in groups["amp"]
          timeout: "{{ amp_upgrade_timeout | default(3600) }}"

        # --- Docker Stacks (compose) update ---
        # Stack mode: enumerate per-stack and build service map
        - name: Enumerate stack services (stack mode)
          become: true
          ansible.builtin.shell: docker compose config --services
          args:
            chdir: "/opt/stacks/{{ item }}"
          register: _stack_services_raw
          changed_when: false
          check_mode: false
          loop: "{{ stack_assignments[inventory_hostname] | default([]) }}"
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_stacks"] | default([])
            - inventory_hostname in (stack_assignments | default({}))

        - name: Build stack-to-services map (stack mode)
          ansible.builtin.set_fact:
            _stack_service_map: >-
              {{ dict(_stack_services_raw.results
                      | selectattr('stdout_lines', 'defined')
                      | map(attribute='item')
                      | zip(_stack_services_raw.results
                            | selectattr('stdout_lines', 'defined')
                            | map(attribute='stdout_lines'))) }}
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_stacks"] | default([])
            - inventory_hostname in (stack_assignments | default({}))

        - name: Set target services from stacks (stack mode)
          ansible.builtin.set_fact:
            _docker_target_services: >-
              {{ _stack_service_map.values() | flatten
                 | difference(update_exclude_services | default([])) }}
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_stacks"] | default([])
            - inventory_hostname in (stack_assignments | default({}))

        # Stack mode: per-stack rollback snapshots
        - name: Save Docker rollback snapshot (stack mode)
          become: true
          ansible.builtin.shell: |
            echo '{'
            echo '  "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",'
            echo '  "containers": {'
            first=true
            for svc in {{ (_stack_service_map[item] | default([])) | difference(update_exclude_services | default([])) | join(' ') }}; do
              cid=$(docker compose ps -q "$svc" 2>/dev/null)
              if [ -n "$cid" ]; then
                img=$(docker inspect --format {% raw %}'{{.Config.Image}}'{% endraw %} "$cid")
                iid=$(docker inspect --format {% raw %}'{{.Image}}'{% endraw %} "$cid")
                version=""
                for label in "org.opencontainers.image.version" "org.label-schema.version" "version"; do
                  version=$(docker inspect --format {% raw %}'{{index .Config.Labels "'{% endraw %}${label}{% raw %}'"}}'{% endraw %} "$cid" 2>/dev/null)
                  [ -n "$version" ] && [ "$version" != "<no value>" ] && break
                  version=""
                done
                if [ -z "$version" ]; then
                  case "$img" in *:*) version="${img##*:}" ;; *) version="latest" ;; esac
                fi
                $first || echo ','
                first=false
                printf '    "%s": {"image": "%s", "image_id": "%s", "version": "%s"}' "$svc" "$img" "$iid" "$version"
              fi
            done
            echo ''
            echo '  }'
            echo '}'
          args:
            chdir: "/opt/stacks/{{ item }}"
          register: _docker_snapshot_stacks
          loop: "{{ stack_assignments[inventory_hostname] | default([]) }}"
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_stacks"] | default([])
            - inventory_hostname in (stack_assignments | default({}))
            - (_stack_service_map[item] | default([])) | difference(update_exclude_services | default([])) | length > 0
            - not ansible_check_mode

        - name: Write rollback snapshot per stack (stack mode)
          become: true
          ansible.builtin.copy:
            content: "{{ item.stdout }}"
            dest: "/opt/stacks/{{ item.item }}/.rollback_snapshot.json"
            mode: '0600'
          loop: "{{ _docker_snapshot_stacks.results | default([]) | selectattr('stdout', 'defined') | list }}"
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_stacks"] | default([])
            - inventory_hostname in (stack_assignments | default({}))

        # Stack mode: per-stack pull/recreate
        - name: Pull, recreate, and compare compose containers (stack mode)
          become: true
          ansible.builtin.shell: |
            [ -f /tmp/get_push_epoch.sh ] && . /tmp/get_push_epoch.sh
            before_file=$(mktemp)
            trap 'rm -f "$before_file"' EXIT
            delay_days={{ update_delay_days | default(0) }}
            if [ "$delay_days" -gt 0 ]; then
              threshold_epoch=$(date -d "-${delay_days} days" +%s)
            fi
            target_services="{{ (_stack_service_map[item] | default([])) | difference(update_exclude_services | default([])) | join(' ') }}"
            for svc in $target_services; do
              cid=$(docker compose ps -q "$svc" 2>/dev/null)
              if [ -n "$cid" ]; then
                iid=$(docker inspect --format {% raw %}'{{.Image}}'{% endraw %} "$cid" | cut -c8-19)
                echo "${svc}|${iid}" >> "$before_file"
              fi
            done
            pull_failed=false
            docker compose pull $target_services >&2 || pull_failed=true
            approved=""
            for svc in $target_services; do
              if [ "$delay_days" -le 0 ]; then
                approved="$approved $svc"
              else
                cid=$(docker compose ps -q "$svc" 2>/dev/null)
                old_iid=$(docker inspect --format {% raw %}'{{.Image}}'{% endraw %} "$cid" 2>/dev/null)
                img=$(docker inspect --format {% raw %}'{{.Config.Image}}'{% endraw %} "$cid" 2>/dev/null)
                new_iid=$(docker image inspect --format {% raw %}'{{.Id}}'{% endraw %} "$img" 2>/dev/null)
                if [ "$old_iid" = "$new_iid" ]; then
                  approved="$approved $svc"
                else
                  push_epoch=$(get_push_epoch "$img")
                  if [ "$push_epoch" -le "$threshold_epoch" ]; then
                    approved="$approved $svc"
                  fi
                fi
              fi
            done
            if [ -n "$approved" ]; then
              docker compose up -d $approved >&2
            fi
            echo '['
            first=true
            for svc in $target_services; do
              cid=$(docker compose ps -q "$svc" 2>/dev/null)
              if [ -n "$cid" ]; then
                img=$(docker inspect --format {% raw %}'{{.Config.Image}}'{% endraw %} "$cid")
                new_id=$(docker inspect --format {% raw %}'{{.Image}}'{% endraw %} "$cid" | cut -c8-19)
                old_id=$(grep "^${svc}|" "$before_file" | cut -d'|' -f2)
                version=""
                for label in "org.opencontainers.image.version" "org.label-schema.version" "version"; do
                  version=$(docker inspect --format {% raw %}'{{index .Config.Labels "'{% endraw %}${label}{% raw %}'"}}'{% endraw %} "$cid" 2>/dev/null)
                  [ -n "$version" ] && [ "$version" != "<no value>" ] && break
                  version=""
                done
                if [ -z "$version" ]; then
                  case "$img" in *:*) version="${img##*:}" ;; *) version="latest" ;; esac
                fi
                updated=false
                [ -n "$old_id" ] && [ "$old_id" != "$new_id" ] && updated=true
                $first || echo ','
                first=false
                printf '{"name":"%s","image":"%s","old_id":"%s","new_id":"%s","tag":"%s","updated":%s,"pull_failed":%s}' \
                  "$svc" "$img" "$old_id" "$new_id" "$version" "$updated" "$pull_failed"
              fi
            done
            echo ']'
          args:
            chdir: "/opt/stacks/{{ item }}"
          register: _compose_update_stacks
          changed_when: true
          loop: "{{ stack_assignments[inventory_hostname] | default([]) }}"
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_stacks"] | default([])
            - inventory_hostname in (stack_assignments | default({}))
            - (_stack_service_map[item] | default([])) | difference(update_exclude_services | default([])) | length > 0
            - not ansible_check_mode

        - name: Set compose update results (stack mode)
          ansible.builtin.set_fact:
            docker_update_results: >-
              {{ _compose_update_stacks.results | default([])
                 | selectattr('stdout', 'defined')
                 | map(attribute='stdout')
                 | map('from_json')
                 | flatten }}
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_stacks"] | default([])
            - inventory_hostname in (stack_assignments | default({}))

        # --- Docker Run (unRAID) update ---
        - name: Enumerate unRAID containers
          become: true
          ansible.builtin.shell: >
            docker ps --format {% raw %}'{{.Names}}'{% endraw %}
            {% if update_exclude_containers | default([]) | length > 0 %}| grep -viE '({{ update_exclude_containers | join("|") }})'{% endif %}
          register: _unraid_containers_raw
          changed_when: false
          check_mode: false
          failed_when: false
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_run"] | default([])

        - name: Set target unRAID containers
          ansible.builtin.set_fact:
            _docker_target_containers: "{{ _unraid_containers_raw.stdout_lines | default([]) }}"
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_run"] | default([])

        - name: Pull, update, and compare unRAID containers
          become: true
          ansible.builtin.shell: |
            [ -f /tmp/get_push_epoch.sh ] && . /tmp/get_push_epoch.sh
            delay_days={{ update_delay_days | default(0) }}
            if [ "$delay_days" -gt 0 ]; then
              threshold_epoch=$(date -d "-${delay_days} days" +%s)
            fi
            # Batch pull all images first (faster than sequential per-container pulls)
            pull_failed=false
            images=""
            for name in {{ _docker_target_containers | join(' ') }}; do
              images="$images $(docker inspect --format {% raw %}'{{.Config.Image}}'{% endraw %} "$name")"
            done
            for img in $(echo "$images" | tr ' ' '\n' | sort -u); do
              [ -n "$img" ] && docker pull "$img" >&2 || pull_failed=true
            done
            echo '['
            first=true
            for name in {{ _docker_target_containers | join(' ') }}; do
              img=$(docker inspect --format {% raw %}'{{.Config.Image}}'{% endraw %} "$name")
              old_id=$(docker inspect --format {% raw %}'{{.Image}}'{% endraw %} "$name" | cut -c8-19)
              new_img_id=$(docker image inspect --format {% raw %}'{{.Id}}'{% endraw %} "$img" 2>/dev/null | cut -c8-19)
              if [ "$old_id" != "$new_img_id" ]; then
                apply_update=true
                if [ "$delay_days" -gt 0 ]; then
                  push_epoch=$(get_push_epoch "$img")
                  [ "$push_epoch" -gt "$threshold_epoch" ] && apply_update=false
                fi
                if $apply_update; then
                  if /usr/bin/php -q /usr/local/emhttp/plugins/dynamix.docker.manager/scripts/update_container "$name" >&2; then
                    new_id=$(docker inspect --format {% raw %}'{{.Image}}'{% endraw %} "$name" | cut -c8-19)
                    updated=true
                  else
                    new_id="$old_id"
                    updated=false
                  fi
                else
                  new_id="$old_id"
                  updated=false
                fi
              else
                new_id="$old_id"
                updated=false
              fi
              version=""
              for label in "org.opencontainers.image.version" "org.label-schema.version" "version"; do
                version=$(docker inspect --format {% raw %}'{{index .Config.Labels "'{% endraw %}${label}{% raw %}'"}}'{% endraw %} "$name" 2>/dev/null)
                [ -n "$version" ] && [ "$version" != "<no value>" ] && break
                version=""
              done
              if [ -z "$version" ]; then
                case "$img" in *:*) version="${img##*:}" ;; *) version="latest" ;; esac
              fi
              $first || echo ','
              first=false
              printf '{"name":"%s","image":"%s","old_id":"%s","new_id":"%s","tag":"%s","updated":%s,"pull_failed":%s}' \
                "$name" "$img" "$old_id" "$new_id" "$version" "$updated" "$pull_failed"
            done
            echo ']'
          register: _unraid_update_raw
          changed_when: true
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_run"] | default([])
            - _docker_target_containers | default([]) | length > 0
            - not ansible_check_mode

        - name: Set unRAID update results
          ansible.builtin.set_fact:
            docker_update_results: "{{ _unraid_update_raw.stdout | from_json }}"
          when:
            - _version_scope == 'docker'
            - inventory_hostname in groups["docker_run"] | default([])
            - _unraid_update_raw is not skipped

        - name: Get current version
          ansible.builtin.shell: "{{ _os_version_commands[group_names | select('in', _os_version_commands) | first] }}"
          register: _version_raw_os
          changed_when: false
          check_mode: false
          when:
            - _version_scope == 'os'
            - group_names | select('in', _os_version_commands) | list | length > 0

        - name: Set current_version
          ansible.builtin.set_fact:
            current_version: "{{ _version_raw_os.stdout | trim }}"
          when:
            - _version_scope == 'os'
            - group_names | select('in', _os_version_commands) | list | length > 0

        - name: Get current version
          ansible.builtin.shell: "{{ _sw_version_commands[group_names | select('in', _sw_version_commands) | first] }}"
          register: _version_raw_sw
          changed_when: false
          check_mode: false
          when:
            - _version_scope == 'software'
            - group_names | select('in', _sw_version_commands) | list | length > 0

        - name: Set current_version
          ansible.builtin.set_fact:
            current_version: "{{ _version_raw_sw.stdout | trim }}"
          when:
            - _version_scope == 'software'
            - group_names | select('in', _sw_version_commands) | list | length > 0

      rescue:
        - name: Set update failed flag
          ansible.builtin.set_fact:
            update_failed: true

        - name: Best-effort cleanup — unset Ceph flags and disable node maintenance
          ansible.builtin.shell: |
            ceph osd unset noout; ceph osd unset nobackfill; ceph osd unset norebalance
            ha-manager crm-command node-maintenance disable {{ ansible_hostname }}
          become: true
          failed_when: false
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups['pve'] | default([])
            - _pve_maint_enabled is defined
            - not (_pve_maint_enabled is skipped)

      always:
        - name: Clean up get_push_epoch helper script
          ansible.builtin.file:
            path: /tmp/get_push_epoch.sh
            state: absent
          when: _version_scope == 'docker'

        - name: Send Discord notification
          include_tasks: tasks/notify.yaml
          when: (not _is_docker_update | bool) and (update_failed or current_version != previous_version)
          vars:
            discord_name: "{{ update_name }}"
            discord_operation: "Update"
            discord_status: "{{ 'failed' if update_failed else 'successful' }}"
            discord_color: "{{ discord_color_failure if update_failed else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Version"
                value: "{{ previous_version + ' → ' + current_version }}"

        - name: Log update to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          when: (not _is_docker_update | bool) and (update_failed or current_version != previous_version)
          vars:
            log_table: updates
            log_application: "{{ update_name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_version: "{{ 'FAILED' if update_failed else current_version }}"
            log_status: "{{ 'failed' if update_failed else 'success' }}"

        - name: Return PiKVM to RO mode
          raw: ro
          when:
            - _version_scope == 'os'
            - inventory_hostname in groups["pikvm"]
            - pikvm_update_result.rc | default(0) != 100
            - not ansible_check_mode

        - name: Send Docker update notification
          include_tasks: tasks/notify.yaml
          when:
            - _is_docker_update | bool
            - update_failed or (docker_update_results | selectattr('updated') | list | length > 0)
              or (docker_update_results | selectattr('pull_failed', 'defined') | selectattr('pull_failed') | list | length > 0)
          vars:
            _pull_failed: "{{ docker_update_results | selectattr('pull_failed', 'defined') | selectattr('pull_failed') | list | length > 0 }}"
            discord_name: "{{ update_name }}"
            discord_operation: "Update"
            discord_status: "{{ 'failed' if update_failed else 'partial' if _pull_failed | bool else 'successful' }}"
            discord_detail: "{{ 'images may be stale' if _pull_failed | bool and not update_failed else '' }}"
            discord_color: "{{ discord_color_failure if update_failed or (_pull_failed | bool) else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Updated"
                value: "{{ docker_update_results | selectattr('updated') | map(attribute='name') | join(', ') | default('None', true) }}"

        - name: Log container updates to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          loop: "{{ docker_update_results | selectattr('updated') | list }}"
          when:
            - _is_docker_update | bool
            - docker_update_results | selectattr('updated') | list | length > 0
          vars:
            log_table: updates
            log_application: "{{ item.name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_version: "{{ item.tag }} ({{ item.new_id }})"
            log_status: "success"

        - name: Log Docker update failure
          include_tasks: tasks/log_mariadb.yaml
          when:
            - _is_docker_update | bool
            - update_failed
          vars:
            log_table: updates
            log_application: "{{ update_name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_version: "FAILED"
            log_status: "failed"
