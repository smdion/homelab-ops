---
# One-time setup for test VM network isolation on Unifi UDM.
# Creates test-isolation VLAN network + two LAN_IN firewall rules.
# Idempotent — safe to re-run; skips resources that already exist.
#
# PREREQUISITE (manual, one-time — too risky to automate):
#   Add vault_test_vlan_id to the Proxmox uplink port profile in Unifi UI before running:
#     Devices → Switch → Ports → click a Proxmox uplink port → note profile name
#     Settings → Profiles → Port Profiles → <profile> → Tagged Networks → add VLAN
#   Save — additive change, no outage.
#   Record the profile name as vault_pve_port_profile_name in vault.
#
# Usage:
#   ansible-playbook setup_test_network.yaml --vault-password-file ~/.vault_pass
#   ansible-playbook setup_test_network.yaml --check --vault-password-file ~/.vault_pass
#     --check — runs all GETs and prereq checks, skips all writes, prints what would change
#
# Firewall rule mode (use_zone_rules, default true):
#   use_zone_rules=true  — zone-based rules (consistent with existing rules in Unifi UI)
#                          NOTE: homedwellers_test is in the Guest zone alongside homedwellers_guest.
#                          Zone rules apply to ALL Guest networks. To scope to test only,
#                          create a dedicated "Test" zone in Unifi and move homedwellers_test there.
#   use_zone_rules=false — address-based rules (Semaphore IP → test subnet, test subnet → prod LAN)
#                          More precise but deviates from existing rule convention.
#
# Required vault vars:
#   vault_test_vlan_id           — VLAN ID (e.g. 3)
#   vault_test_vlan_gateway      — gateway IP on test VLAN (e.g. 192.168.3.1)
#   vault_test_vlan_subnet       — network CIDR (e.g. 192.168.3.0/24)
#   vault_pve_port_profile_name  — Unifi switch port profile used by Proxmox uplinks
#   unifi_network_api_key        — Unifi Network API key (already in vault)
#
# Derived (no additional vault vars needed):
#   Semaphore IP   — extracted from semaphore_host_url (already in vault)
#   Prod LAN CIDR  — derived from vault_vm_gateway + vm_cidr (already in vault)

- name: Setup test VM network isolation on Unifi
  hosts: unifi_network
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/semaphore_check.yaml
  vars:
    _unifi_api: "https://{{ inventory_hostname }}/proxy/network/api/s/default"
    _semaphore_ip: "{{ semaphore_host_url | urlsplit('hostname') }}"
    _prod_lan_subnet: "{{ vault_vm_gateway | regex_replace('(\\d+\\.\\d+\\.\\d+)\\.\\d+', '\\1.0') }}/{{ vm_cidr }}"
    use_zone_rules: true
    _semaphore_zone_name: "Server"   # zone containing homedwellers_server (where Semaphore lives)
    _test_vlan_zone_name: "Guest"    # zone containing homedwellers_test; change to "Test" if you create a dedicated zone
    _ssh_rule_name: "Allow Server to Test"
    _block_rule_name: "Block Test to Server"

  tasks:
    # ═══════════════════════════════════════════════════════════
    # STEP 0 — Prereq check: VLAN must already be in port profile
    # ═══════════════════════════════════════════════════════════
    - name: Get Unifi port profiles
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/portconf"
        method: GET
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        validate_certs: false
      register: _portconf
      check_mode: false
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"

    - name: Find Proxmox uplink port profile
      ansible.builtin.set_fact:
        _pve_profile: >-
          {{ _portconf.json.data
             | selectattr('name', 'equalto', vault_pve_port_profile_name)
             | list | first | default({}) }}

    - name: Assert port profile exists
      ansible.builtin.assert:
        that: _pve_profile | length > 0
        fail_msg: >-
          Port profile '{{ vault_pve_port_profile_name }}' not found in Unifi.
          Check vault_pve_port_profile_name matches the profile name exactly.

    - name: Get all Unifi networks
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/networkconf"
        method: GET
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        validate_certs: false
      register: _all_networks
      check_mode: false
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"

    - name: Find test VLAN network _id
      ansible.builtin.set_fact:
        _test_vlan_net_id: >-
          {{ (_all_networks.json.data
             | selectattr('vlan', 'defined')
             | selectattr('vlan', 'equalto', vault_test_vlan_id | int)
             | list | first | default({})).get('_id', '') }}

    - name: Assert VLAN network exists and is not excluded from port profile
      ansible.builtin.assert:
        that:
          - _test_vlan_net_id | length > 0
          - _test_vlan_net_id not in (_pve_profile.excluded_networkconf_ids | default([]))
        fail_msg: >-
          VLAN {{ vault_test_vlan_id }} is not tagged on port profile '{{ vault_pve_port_profile_name }}'.
          Add it manually in Unifi UI first:
            Settings → Profiles → Port Profiles → {{ vault_pve_port_profile_name }}
            → Tagged Networks → add test-isolation (VLAN {{ vault_test_vlan_id }})
          Then re-run this playbook.

    # ═══════════════════════════════════════════════════════════
    # STEP 1 — Create test-isolation VLAN network (if missing)
    # ═══════════════════════════════════════════════════════════
    - name: Check if test-isolation VLAN already exists
      ansible.builtin.set_fact:
        _test_vlan_exists: >-
          {{ _all_networks.json.data
             | selectattr('vlan', 'defined')
             | selectattr('vlan', 'equalto', vault_test_vlan_id | int)
             | list | length > 0 }}

    - name: Create test-isolation VLAN network
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/networkconf"
        method: POST
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        body_format: json
        body:
          name: "test-isolation"
          purpose: "corporate"
          vlan: "{{ vault_test_vlan_id | int }}"
          vlan_enabled: true
          ip_subnet: "{{ vault_test_vlan_gateway }}/24"
          dhcpd_enabled: false
          ipv6_interface_type: "none"
        validate_certs: false
        status_code: [200, 201]
      when: not _test_vlan_exists and not ansible_check_mode
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"
      register: _create_vlan

    - name: Record VLAN status
      ansible.builtin.set_fact:
        _vlan_status: "{{ 'created' if not _test_vlan_exists else 'already existed' }}"

    # ═══════════════════════════════════════════════════════════
    # STEP 2a — Resolve zone IDs (zone-based mode only)
    # ═══════════════════════════════════════════════════════════
    - name: Get Unifi firewall zones (v2 API)
      ansible.builtin.uri:
        url: "https://{{ inventory_hostname }}/proxy/network/v2/api/site/default/firewall/zones"
        method: GET
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        validate_certs: false
      register: _firewall_zones
      check_mode: false
      failed_when: false
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"
      when: use_zone_rules | bool

    - name: Warn if zone API unavailable — will fall back to address-based rules
      ansible.builtin.debug:
        msg: >-
          WARNING: Zone API returned {{ _firewall_zones.status | default('no response') }} —
          falling back to address-based firewall rules.
          (use_zone_rules=true but zone API unavailable; requires Unifi Network 8.2+.)
      when:
        - use_zone_rules | bool
        - _firewall_zones.status | default(0) != 200

    - name: Resolve zone IDs and set effective rule mode
      ansible.builtin.set_fact:
        _effective_zone_rules: "{{ (use_zone_rules | bool) and (_firewall_zones.status | default(0) == 200) }}"
        _semaphore_zone_id: >-
          {{ (((_firewall_zones.json.data
               if (_firewall_zones.json is mapping and 'data' in (_firewall_zones.json | default({})))
               else (_firewall_zones.json | default([]))))
             | selectattr('name', 'equalto', _semaphore_zone_name)
             | list | first | default({})).get('_id', '') }}
        _test_vlan_zone_id: >-
          {{ (((_firewall_zones.json.data
               if (_firewall_zones.json is mapping and 'data' in (_firewall_zones.json | default({})))
               else (_firewall_zones.json | default([]))))
             | selectattr('name', 'equalto', _test_vlan_zone_name)
             | list | first | default({})).get('_id', '') }}

    - name: Assert zone IDs resolved
      ansible.builtin.assert:
        that:
          - _semaphore_zone_id | length > 0
          - _test_vlan_zone_id | length > 0
        fail_msg: >-
          Zone fetch succeeded but could not resolve zone IDs.
          Expected zones: '{{ _semaphore_zone_name }}' and '{{ _test_vlan_zone_name }}'.
          Check _semaphore_zone_name and _test_vlan_zone_name match zone names exactly in Unifi UI
          (Settings → Firewall & Security → Zones).
      when: _effective_zone_rules | bool

    # ═══════════════════════════════════════════════════════════
    # STEP 2b — Create firewall rules (if missing)
    # ═══════════════════════════════════════════════════════════
    - name: Get existing Unifi firewall rules
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/firewallrule"
        method: GET
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        validate_certs: false
      register: _firewall_rules
      check_mode: false
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"

    - name: Check which rules already exist and compute insertion indices
      ansible.builtin.set_fact:
        _existing_rule_names: >-
          {{ _firewall_rules.json.data | map(attribute='name') | list }}
        _ssh_rule_index: >-
          {{ ([(_firewall_rules.json.data
                | selectattr('ruleset', 'equalto', 'LAN_IN')
                | map(attribute='rule_index')
                | map('int') | list | sort | last | default(3999) | int) + 1,
               4000] | max) }}
        _block_rule_index: >-
          {{ ([(_firewall_rules.json.data
                | selectattr('ruleset', 'equalto', 'LAN_IN')
                | map(attribute='rule_index')
                | map('int') | list | sort | last | default(3999) | int) + 2,
               4001] | max) }}

    # Zone-based rules
    - name: "Create rule — {{ _ssh_rule_name }} [zone-based]"
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/firewallrule"
        method: POST
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        body_format: json
        body:
          name: "{{ _ssh_rule_name }}"
          ruleset: "LAN_IN"
          rule_index: "{{ _ssh_rule_index | int }}"
          action: "accept"
          protocol: "tcp"
          protocol_match_excepted: false
          enabled: true
          ip_version: "ipv4"
          logging: false
          ipsec: ""
          src_firewallzone_id: "{{ _semaphore_zone_id }}"
          dst_firewallzone_id: "{{ _test_vlan_zone_id }}"
          dst_port: "22"
          src_mac_address: ""
          src_firewallgroup_ids: []
          dst_firewallgroup_ids: []
        validate_certs: false
        status_code: [200, 201]
      when: _ssh_rule_name not in _existing_rule_names and not ansible_check_mode and _effective_zone_rules | bool
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"
      register: _create_ssh_rule_zone

    - name: "Create rule — {{ _block_rule_name }} [zone-based]"
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/firewallrule"
        method: POST
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        body_format: json
        body:
          name: "{{ _block_rule_name }}"
          ruleset: "LAN_IN"
          rule_index: "{{ _block_rule_index | int }}"
          action: "drop"
          protocol: "all"
          protocol_match_excepted: false
          enabled: true
          ip_version: "ipv4"
          logging: false
          ipsec: ""
          src_firewallzone_id: "{{ _test_vlan_zone_id }}"
          dst_firewallzone_id: "{{ _semaphore_zone_id }}"
          src_mac_address: ""
          src_firewallgroup_ids: []
          dst_firewallgroup_ids: []
        validate_certs: false
        status_code: [200, 201]
      when: _block_rule_name not in _existing_rule_names and not ansible_check_mode and _effective_zone_rules | bool
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"
      register: _create_block_rule_zone

    # Address-based rules
    - name: "Create rule — {{ _ssh_rule_name }} [address-based]"
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/firewallrule"
        method: POST
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        body_format: json
        body:
          name: "{{ _ssh_rule_name }}"
          ruleset: "LAN_IN"
          rule_index: "{{ _ssh_rule_index | int }}"
          action: "accept"
          protocol: "tcp"
          protocol_match_excepted: false
          enabled: true
          ip_version: "ipv4"
          logging: false
          ipsec: ""
          src_address: "{{ _semaphore_ip }}/32"
          dst_address: "{{ vault_test_vlan_subnet }}"
          dst_port: "22"
          src_mac_address: ""
          src_firewallgroup_ids: []
          dst_firewallgroup_ids: []
        validate_certs: false
        status_code: [200, 201]
      when: _ssh_rule_name not in _existing_rule_names and not ansible_check_mode and not (_effective_zone_rules | bool)
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"
      register: _create_ssh_rule_addr

    - name: "Create rule — {{ _block_rule_name }} [address-based]"
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/firewallrule"
        method: POST
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        body_format: json
        body:
          name: "{{ _block_rule_name }}"
          ruleset: "LAN_IN"
          rule_index: "{{ _block_rule_index | int }}"
          action: "drop"
          protocol: "all"
          protocol_match_excepted: false
          enabled: true
          ip_version: "ipv4"
          logging: false
          ipsec: ""
          src_address: "{{ vault_test_vlan_subnet }}"
          dst_address: "{{ _prod_lan_subnet }}"
          src_mac_address: ""
          src_firewallgroup_ids: []
          dst_firewallgroup_ids: []
        validate_certs: false
        status_code: [200, 201]
      when: _block_rule_name not in _existing_rule_names and not ansible_check_mode and not (_effective_zone_rules | bool)
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"
      register: _create_block_rule_addr

    - name: Consolidate rule creation results
      ansible.builtin.set_fact:
        _create_ssh_rule: "{{ _create_ssh_rule_zone if _effective_zone_rules | bool else _create_ssh_rule_addr }}"
        _create_block_rule: "{{ _create_block_rule_zone if _effective_zone_rules | bool else _create_block_rule_addr }}"

    # ═══════════════════════════════════════════════════════════
    # CHECK MODE — Report what would change (no writes made)
    # ═══════════════════════════════════════════════════════════
    - name: "[CHECK MODE] Report what would be created"
      ansible.builtin.debug:
        msg:
          - "=== CHECK MODE — No changes made ==="
          - "Rule mode: {{ 'zone-based (' + _semaphore_zone_name + ' → ' + _test_vlan_zone_name + ')' if _effective_zone_rules | bool else 'address-based' }}"
          - "VLAN {{ vault_test_vlan_id }} (test-isolation): {{ 'would be created' if not _test_vlan_exists else 'already exists — no action needed' }}"
          - "Rule '{{ _ssh_rule_name }}': {{ 'would be created' if _ssh_rule_name not in _existing_rule_names else 'already exists — no action needed' }}"
          - "Rule '{{ _block_rule_name }}': {{ 'would be created' if _block_rule_name not in _existing_rule_names else 'already exists — no action needed' }}"
          - ""
          - "Derived values that would be used:"
          - "  Semaphore IP (address-based SSH allow source): {{ _semaphore_ip }}/32"
          - "  Prod LAN CIDR (address-based block destination): {{ _prod_lan_subnet }}"
          - "  Server zone ID: {{ _semaphore_zone_id | default('n/a') }} ({{ 'zone mode active' if _effective_zone_rules | bool else 'zone mode inactive — using address-based' }})"
          - "  Guest/Test zone ID: {{ _test_vlan_zone_id | default('n/a') }}"
          - ""
          - "Re-run without --check to apply."
      when: ansible_check_mode

    # ═══════════════════════════════════════════════════════════
    # STEP 3 — Verify all resources exist
    # ═══════════════════════════════════════════════════════════
    - name: Re-fetch networks for verification
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/networkconf"
        method: GET
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        validate_certs: false
      register: _verify_networks
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"
      when: not ansible_check_mode

    - name: Assert test-isolation VLAN exists
      ansible.builtin.assert:
        that: >-
          _verify_networks.json.data
          | selectattr('vlan', 'defined')
          | selectattr('vlan', 'equalto', vault_test_vlan_id | int)
          | list | length > 0
        fail_msg: "test-isolation VLAN {{ vault_test_vlan_id }} not found after creation"
      when: not ansible_check_mode

    - name: Re-fetch firewall rules for verification
      ansible.builtin.uri:
        url: "{{ _unifi_api }}/rest/firewallrule"
        method: GET
        headers:
          x-api-key: "{{ unifi_network_api_key }}"
        validate_certs: false
      register: _verify_rules
      no_log: "{{ not (debug_no_log | default(false) | bool) }}"
      when: not ansible_check_mode

    - name: Assert both firewall rules exist
      ansible.builtin.assert:
        that:
          - "_ssh_rule_name in (_verify_rules.json.data | map(attribute='name') | list)"
          - "_block_rule_name in (_verify_rules.json.data | map(attribute='name') | list)"
        fail_msg: "One or more firewall rules missing after creation"
      when: not ansible_check_mode

    - name: Print summary
      ansible.builtin.debug:
        msg:
          - "=== Test Network Isolation Setup Complete ==="
          - "Rule mode: {{ 'zone-based (' + _semaphore_zone_name + ' → ' + _test_vlan_zone_name + ')' if _effective_zone_rules | bool else 'address-based' }}"
          - "VLAN {{ vault_test_vlan_id }} (test-isolation): {{ _vlan_status }}"
          - "Rule '{{ _ssh_rule_name }}': {{ 'created' if _create_ssh_rule.changed | default(false) else 'already existed' }}"
          - "Rule '{{ _block_rule_name }}': {{ 'created' if _create_block_rule.changed | default(false) else 'already existed' }}"
          - ""
          - "Next steps:"
          - "  1. Run build_ubuntu.yaml -e vm_name=test-vm to provision a test VM"
          - "  2. Verify: VLAN tag on net0 in Proxmox UI, IP in {{ vault_test_vlan_subnet }}"
          - "  3. From test VM: ping prod host → timeout; curl https://hub.docker.com → 200"
      when: not ansible_check_mode
