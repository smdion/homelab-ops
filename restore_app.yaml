---
# Restore a single app (stack appdata + databases) to a production host.
# Stops the stack, restores each DB, restores appdata inplace, restarts, verifies health.
#
# Required extra vars:
#   restore_app    — key in app_info dict (e.g., 'authentik', 'jellyseerr')
#   restore_target — inventory_hostname of the production host to restore on
#   confirm=yes    — required safety gate (intentional: prevents accidental production runs)
#
# Semaphore templates:
#   Restore — App [Production]  (Maintenance view) — pass restore_app, restore_target, confirm=yes
#   Test — Backup Restore [VM]     (Testing view)     — see test_backup_restore.yaml

# ═══════════════════════════════════════════════════════════════════
# Play 1 — Validate and find backup files
# ═══════════════════════════════════════════════════════════════════
- name: Validate and locate app backups
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/host_definitions.yaml
    - vars/docker_stacks.yaml
    - vars/semaphore_check.yaml

  pre_tasks:
    - name: Assert required vars and safety gate
      ansible.builtin.assert:
        that:
          - restore_app is defined
          - restore_target is defined
          - confirm | default('no') == 'yes'
        fail_msg: >-
          Missing required vars or safety gate not set.
          Usage: -e restore_app=<app> -e restore_target=<host> -e confirm=yes

    - name: Assert restore_app exists in app_info config
      ansible.builtin.assert:
        that: restore_app in app_info
        fail_msg: >-
          '{{ restore_app }}' not found in app_info.
          Valid apps: {{ app_info.keys() | list | join(', ') }}

    - name: Run standard pre-flight assertions
      include_tasks: tasks/pre_task_assertions.yaml
      vars:
        pre_playbook: "restore_app.yaml"
        pre_hostname: "{{ controller_fqdn }}"
        pre_run_vars: "{{ {'restore_app': restore_app, 'restore_target': restore_target} | to_json }}"

  tasks:
    - name: Set app config
      ansible.builtin.set_fact:
        _app_cfg: "{{ app_info[restore_app] }}"

    - name: Find latest stack archive
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ _app_cfg.stack }}/backup_{{ _app_cfg.stack }}_*.tar.gz 2>/dev/null | head -1
      register: _stack_archive
      become: false
      changed_when: false
      check_mode: false

    - name: Assert stack archive found
      ansible.builtin.assert:
        that: _stack_archive.stdout | length > 0
        fail_msg: >-
          No stack archive found for stack '{{ _app_cfg.stack }}'.
          Expected: {{ backup_base_dir }}/{{ _app_cfg.stack }}/backup_{{ _app_cfg.stack }}_*.tar.gz

    - name: Find latest DB backup — {{ item }}
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ _app_cfg.db_stack }}/backup_{{ item }}_*.sql.gz 2>/dev/null | head -1
      loop: "{{ _app_cfg.db_names | default([]) }}"
      register: _db_archive_results
      become: false
      changed_when: false
      check_mode: false
      when: _app_cfg.db_names | default([]) | length > 0

    - name: Assert DB backup found — {{ item.item }}
      ansible.builtin.assert:
        that: item.stdout | length > 0
        fail_msg: "No DB backup found for '{{ item.item }}' in {{ _app_cfg.db_stack }} stack"
      loop: "{{ _db_archive_results.results | default([]) }}"
      when: _app_cfg.db_names | default([]) | length > 0

    - name: Set backup path facts
      ansible.builtin.set_fact:
        _stack_archive_path: "{{ _stack_archive.stdout }}"
        _db_archive_map: >-
          {{ dict(_app_cfg.db_names | default([]) | zip(
               _db_archive_results.results | default([]) | map(attribute='stdout') | list)) }}

# ═══════════════════════════════════════════════════════════════════
# Play 2 — Restore app on target host
# ═══════════════════════════════════════════════════════════════════
- name: Restore app on target host
  hosts: "{{ restore_target }}"
  become: true
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/host_definitions.yaml
    - vars/docker_stacks.yaml
    - vars/semaphore_check.yaml
  vars:
    maintenance_name: "Docker"
    _app_restore_tmp: "/tmp/restore_{{ restore_app }}"

  tasks:
    - name: Initialize restore state
      ansible.builtin.set_fact:
        _restore_failed: false
        _restore_detail: ""

    - block:
        - name: Discover restore config from labels — {{ restore_app }}
          become: true
          ansible.builtin.shell: |
            ids=$(docker ps -a -q \
              --filter "label=homelab.restore.app={{ restore_app }}")
            [ -z "$ids" ] && exit 0
            echo "$ids" | xargs docker inspect \
              --format '{% raw %}{{index .Config.Labels "homelab.restore.db_config"}}|{{index .Config.Labels "homelab.restore.health_url"}}|{{index .Config.Labels "homelab.restore.health_status"}}{% endraw %}'
          register: _app_label_raw
          changed_when: false

        - name: Parse label config — {{ restore_app }}
          ansible.builtin.set_fact:
            _r_db_config:     "{{ _app_label_raw.stdout.split('|')[0] }}"
            _r_health_url:    "{{ _app_label_raw.stdout.split('|')[1] }}"
            _r_health_status: "{{ _app_label_raw.stdout.split('|')[2] | default('200') }}"

        - name: Load DB engine config — {{ restore_app }}
          ansible.builtin.include_vars:
            file: "vars/{{ _r_db_config }}.yaml"
          when: _r_db_config | default('') | length > 0

        - name: Ensure staging dir exists
          ansible.builtin.file:
            path: "{{ _app_restore_tmp }}"
            state: directory
            mode: "0755"
          when: not ansible_check_mode

        - name: Copy DB backup to staging — {{ item }}
          ansible.builtin.copy:
            src: "{{ hostvars['localhost']._db_archive_map[item] }}"
            dest: "{{ _app_restore_tmp }}/{{ item }}.sql.gz"
          loop: "{{ hostvars['localhost']._app_cfg.db_names | default([]) }}"
          when:
            - hostvars['localhost']._app_cfg.db_names | default([]) | length > 0
            - not ansible_check_mode

        - name: Stop stack — {{ hostvars['localhost']._app_cfg.stack }}
          include_tasks: tasks/docker_stop.yaml
          vars:
            _docker_selective_stacks: ["{{ hostvars['localhost']._app_cfg.stack }}"]

        - name: Restore DB — {{ item }}
          include_tasks: tasks/db_restore.yaml
          loop: "{{ hostvars['localhost']._app_cfg.db_names | default([]) }}"
          loop_control:
            loop_var: item
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_source_file: "{{ _app_restore_tmp }}/{{ item }}.sql.gz"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
            _db_tmp_dir: "{{ _app_restore_tmp }}"
          when:
            - hostvars['localhost']._app_cfg.db_names | default([]) | length > 0
            - not ansible_check_mode

        - name: Restore appdata
          include_tasks: tasks/restore_appdata.yaml
          vars:
            backup_tmp_dir: "{{ _app_restore_tmp }}"
            _restore_archive_path: "{{ hostvars['localhost']._stack_archive_path }}"
            _restore_app_name: "{{ restore_app }}"

        - name: Start stack — {{ hostvars['localhost']._app_cfg.stack }}
          include_tasks: tasks/docker_start.yaml
          vars:
            _docker_selective_stacks: ["{{ hostvars['localhost']._app_cfg.stack }}"]

        - name: Verify container health
          include_tasks: tasks/verify_docker_health.yaml

        - name: Verify HTTP health — {{ restore_app }}
          include_tasks: tasks/verify_app_http.yaml
          vars:
            _health_check_urls:
              - name: "{{ restore_app }}"
                url: "{{ _r_health_url }}"
                status_code: "{{ _r_health_status | default('200') }}"
          when:
            - _r_health_url | default('') | length > 0
            - not ansible_check_mode

        - name: Set success detail
          ansible.builtin.set_fact:
            _restore_detail: >-
              {{ restore_app }} restored — {{ hostvars['localhost']._app_cfg.stack }} stack healthy

      rescue:
        - name: Set failure state
          ansible.builtin.set_fact:
            _restore_failed: true
            _restore_detail: "{{ ansible_failed_result.msg | default('check Semaphore logs') }}"

        - name: Restart stack after failure (best effort)
          include_tasks: tasks/docker_start.yaml
          vars:
            _docker_selective_stacks: ["{{ hostvars['localhost']._app_cfg.stack }}"]
            _docker_ignore_errors: true

      always:
        - name: Cleanup staging dir
          ansible.builtin.file:
            path: "{{ _app_restore_tmp }}"
            state: absent
          when: not ansible_check_mode

        - name: Send Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ maintenance_name }}"
            discord_operation: "App Restore"
            discord_status: "{{ 'failed' if _restore_failed else 'successful' }}"
            discord_detail: "{{ restore_app }}"
            discord_color: "{{ discord_color_failure if _restore_failed else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Detail"
                value: "{{ _restore_detail }}"

        - name: Log restore to MariaDB
          include_tasks: tasks/log_restore.yaml
          vars:
            log_hostname: "{{ restore_target }}"
            restore_application: "{{ restore_app }}"
            restore_source_file: "{{ hostvars['localhost']._stack_archive_path | basename }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "Appdata"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if _restore_failed else 'success' }}"
            restore_detail: "{{ _restore_detail | default('check Semaphore logs') }}"

    - name: Fail if restore failed
      ansible.builtin.fail:
        msg: "App restore failed for {{ restore_app }}: {{ _restore_detail }}"
      when: _restore_failed
