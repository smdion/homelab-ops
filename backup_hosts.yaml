---
# Back up host configurations and appdata.
# Docker stacks: per-stack archives (stop one stack at a time, minimize downtime).
# Other hosts: monolithic archive (stop Docker, archive all paths, restart).
# Sends Discord notification + logs each backup to MariaDB.
#
# Usage:
#   ansible-playbook backup_hosts.yaml -e hosts_variable=proxmox
#   ansible-playbook backup_hosts.yaml -e hosts_variable=docker_stacks

- name: Back up host configurations and appdata
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  serial: 1
  vars_files:
    - vars/secrets.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"
  hosts: "{{ hosts_variable }}"

  pre_tasks:
    - name: Assert config_file is defined and non-empty
      include_tasks: tasks/assert_config_file.yaml

    - name: Put device in RW mode
      raw: rw
      when:
        - inventory_hostname in groups["pikvm"]
        - not ansible_check_mode
      tags: [always]

    - name: Assert sufficient disk space on remote backup dir
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_tmp_dir }}"
        assert_disk_min_gb: 2

    - name: Assert sufficient disk space on controller
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_base_dir }}"
        assert_disk_min_gb: 2
        assert_disk_delegate_to: localhost
        assert_disk_become: false

    - name: Assert MariaDB logging database is reachable
      include_tasks: tasks/assert_db_connectivity.yaml

  tasks:
    - name: Delete temp backup directory
      become: true
      ansible.builtin.file:
        state: absent
        path: "{{ backup_tmp_dir }}"
      tags: [always]

    - name: Create temp backup directory
      become: true
      ansible.builtin.file:
        state: directory
        path: "{{ backup_tmp_dir }}"
      tags: [always]

    - name: Find old backup files
      become: true
      ansible.builtin.find:
        paths: "{{ item }}"
        age: "{{ unifi_backup_retention }}"
        age_stamp: mtime
        recurse: false
      register: _old_backups
      loop: "{{ src_raw_files }}"
      when: inventory_hostname in groups["unifi_network"]
      tags: [always]

    - name: Delete old backup files
      become: true
      ansible.builtin.file:
        path: "{{ found_file.path }}"
        state: absent
      loop: "{{ _old_backups.results | default([]) | map(attribute='files') | flatten }}"
      loop_control:
        loop_var: found_file
      when: inventory_hostname in groups["unifi_network"]
      tags: [always]

    - name: Extract WireGuard VPS config
      become: true
      ansible.builtin.shell: >
        awk '/"address": "{{ vps_address }}",/ {found=1; count=0} found && count<8 {gsub(/^[ \t]+/, "", $0); print; count++}'
        {{ unifi_state_file }} > {{ src_raw_files | first }}/{{ wg_config_file }}
      when: inventory_hostname in groups["unifi_network"]
      tags: [always]

    - name: Initialize file size and failure state
      ansible.builtin.set_fact:
        file_size: {stat: {size: 0}}
        backup_failed: false
        _stack_backup_results: []
      tags: [always]

    - block:
        # ===== PER-STACK BACKUP (docker_stacks hosts) =====
        - name: Back up per-stack archives
          include_tasks: tasks/backup_single_stack.yaml
          loop: "{{ backup_stack_order[inventory_hostname] | default(stack_assignments[inventory_hostname] | default([]) | reverse | list) }}"
          loop_control:
            loop_var: _backup_stack
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not ansible_check_mode
          tags: [always]

        - name: Set failed flag from per-stack results
          ansible.builtin.set_fact:
            backup_failed: "{{ _stack_backup_results | selectattr('failed') | list | length > 0 }}"
          when: inventory_hostname in groups["docker_stacks"] | default([])
          tags: [always]

        # ===== MONOLITHIC BACKUP (non-docker_stacks hosts) =====
        # ===== STOP DOCKER =====
        - include_tasks: tasks/docker_stop.yaml
          vars:
            _docker_exclude_containers: "{{ backup_exclude_containers | default([]) }}"
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname in groups["docker_run"] | default([])
          tags: [docker]

        # ===== UNVR PROTECT BACKUP VIA API =====
        - name: Trigger UNVR backup
          ansible.builtin.uri:
            url: "https://{{ inventory_hostname }}{{ protect_api_backup_path }}"
            method: POST
            body_format: json
            body:
              cmd: "backup"
              days: "-1"
            validate_certs: false  # UNVR uses a self-signed cert; vendor API prevents proper TLS cert management
            headers:
              x-api-key: "{{ unvr_api_key }}"
            status_code: 200
          register: unvr_backup
          delegate_to: localhost
          when:
            - inventory_hostname in groups["unifi_protect"]
            - not ansible_check_mode
          tags: [always]

        - name: Download UNVR backup file
          ansible.builtin.get_url:
            url: "https://{{ inventory_hostname }}{{ unvr_backup.json.data[0].url }}"
            dest: "{{ protect_temp_file }}"
            mode: "0600"
            validate_certs: false  # UNVR uses a self-signed cert; vendor API prevents proper TLS cert management
            headers:
              x-api-key: "{{ unvr_api_key }}"
          delegate_to: localhost
          when:
            - inventory_hostname in groups["unifi_protect"]
            - not ansible_check_mode
          tags: [always]

        - name: Copy backup to UNVR
          ansible.builtin.copy:
            src: "{{ protect_temp_file }}"
            dest: "{{ backup_tmp_file }}"
          when:
            - inventory_hostname in groups["unifi_protect"]
            - not ansible_check_mode
          tags: [always]

        # ===== CREATE BACKUP (non-docker_stacks, non-UNVR hosts) =====
        - name: Filter backup paths to only existing directories
          become: true
          ansible.builtin.stat:
            path: "{{ item }}"
          loop: "{{ src_raw_files }}"
          register: _backup_paths_stat
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
          tags: [always]

        - name: Set validated backup paths
          ansible.builtin.set_fact:
            _validated_backup_paths: >-
              {{ _backup_paths_stat.results | default([])
                 | selectattr('stat', 'defined')
                 | selectattr('stat.exists')
                 | map(attribute='item') | list }}
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
          tags: [always]

        # When exclude dirs are defined, convert directory paths to globs (e.g. /opt → /opt/*)
        # so community.general.archive expands them to individual items that exclude_path can match.
        - name: Convert paths to globs for exclusion support
          ansible.builtin.set_fact:
            _archive_paths: >-
              {{ (_validated_backup_paths | default(src_raw_files))
                 | map('regex_replace', '/?$', '/*') | list }}
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
            - backup_exclude_dirs | default([]) | length > 0
          tags: [always]

        # === unRAID: snapshot disk assignments to boot config (included in /boot archive) ===
        - name: Snapshot disk assignments to boot config
          ansible.builtin.copy:
            src: /var/local/emhttp/disks.ini
            dest: /boot/config/DISK_ASSIGNMENTS.ini
            remote_src: true
            mode: "0644"
          when:
            - inventory_hostname in groups['unraid'] | default([])
            - not ansible_check_mode

        # === unRAID: file inventory of all array shares (monthly — pass -e run_tree_index=true) ===
        - name: Assert find command is available
          ansible.builtin.shell: command -v find
          changed_when: false
          register: _find_check
          failed_when: _find_check.rc != 0
          check_mode: false
          when:
            - inventory_hostname in groups['unraid'] | default([])
            - run_tree_index | default(false) | bool

        - name: Generate file inventory of all array shares
          ansible.builtin.shell: |
            SAVEPATH="/mnt/user/Backup/{{ inventory_hostname }}/tree/array"
            for f in /mnt/user/*/; do
              share=$(basename "$f")
              mkdir -p "$SAVEPATH/$share"
              find "$f" | sort > "$SAVEPATH/$share/$(date +%Y%m%d).txt"
            done
          args:
            executable: /bin/bash
          changed_when: true
          when:
            - inventory_hostname in groups['unraid'] | default([])
            - run_tree_index | default(false) | bool
            - not ansible_check_mode

        - name: Create compressed backup archive
          become: true
          community.general.archive:
            path: "{{ _archive_paths | default(_validated_backup_paths) | default(src_raw_files) }}"
            dest: "{{ backup_tmp_file }}"
            format: gz
            remove: false
            exclude_path: "{{ backup_exclude_dirs | default([]) }}"
          timeout: 3600
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
          tags: [always]

        - name: Get backup file size
          ansible.builtin.stat:
            path: "{{ backup_tmp_file }}"
          register: file_size
          changed_when: false
          when: inventory_hostname not in groups["docker_stacks"] | default([])
          tags: [always]

        - name: Verify backup archive integrity
          become: true
          ansible.builtin.shell: gunzip -t "{{ backup_tmp_file }}"
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
          changed_when: false
          check_mode: false
          tags: [always]

        # ===== START DOCKER =====
        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_wait_ssh: true
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname in groups["docker_run"] | default([])
          tags: [docker]

        # ===== FETCH AND CLEANUP =====
        - name: Fetch backup to controller
          ansible.builtin.fetch:
            src: "{{ backup_tmp_file }}"
            dest: "{{ backup_dest_path }}"
            flat: true
          become: false
          when: inventory_hostname not in groups["docker_stacks"] | default([])
          tags: [always]

        - name: Delete source backup
          become: true
          ansible.builtin.file:
            path: "{{ backup_tmp_file }}"
            state: absent
          when: inventory_hostname not in groups["docker_stacks"] | default([])
          tags: [always]

        - name: Put PiKVM back in RO mode
          raw: ro
          when:
            - inventory_hostname in groups["pikvm"]
            - not ansible_check_mode
          tags: [always]

      rescue:
        - name: Set backup failed flag
          ansible.builtin.set_fact:
            backup_failed: true

      always:
        # ===== SAFETY NET: ENSURE DOCKER IS RUNNING =====
        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_ignore_errors: true
          when: inventory_hostname in groups["docker_run"] | default([])
          tags: [docker]

        # ===== WAIT FOR MARIADB AFTER DOCKER RESTART =====
        - name: Wait for MariaDB logging database after Docker restart
          vars:
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          become: false
          connection: local
          community.mysql.mysql_query:
            login_host: "{{ logging_db_host }}"
            login_port: "{{ logging_db_port }}"
            login_user: "{{ logging_db_user }}"
            login_password: "{{ logging_db_password }}"
            login_db: "{{ logging_db_name }}"
            query: "SELECT 1"
          register: _mariadb_post_restart
          retries: 40
          delay: 10
          until: _mariadb_post_restart is succeeded
          when: inventory_hostname in groups["docker_stacks"] or inventory_hostname in groups["docker_run"]
          changed_when: false
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
          check_mode: false
          ignore_errors: true
          tags: [always]

        # ===== REPORTING (per-stack) =====
        - name: Build per-stack Discord fields
          ansible.builtin.set_fact:
            _stack_discord_fields: >-
              [
               {% for r in _stack_backup_results %}
               {% if not loop.first %},{% endif %}
               {"name": "{{ r.stack }}", "value": "{{ 'FAILED' if r.failed else ('Nothing to back up' if r.file_size == 0 else ((r.file_size / 1024 / 1024) | round(2) | string + 'MB')) }}"}
               {% endfor %}]
          when: inventory_hostname in groups["docker_stacks"] | default([])
          tags: [always]

        - name: Send per-stack Discord notification
          include_tasks: tasks/notify_discord.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Backup"
            discord_status: >-
              {{ 'successful' if not (backup_failed | bool)
                 else ('failed' if (_stack_backup_results | rejectattr('failed') | list | length == 0)
                       else 'partial') }}
            discord_color: >-
              {{ discord_color_success if not (backup_failed | bool)
                 else (discord_color_failure if (_stack_backup_results | rejectattr('failed') | list | length == 0)
                       else discord_color_warning) }}
            discord_url: "{{ backup_url }}"
            discord_fields: "{{ _stack_discord_fields }}"
          when: inventory_hostname in groups["docker_stacks"] | default([])
          tags: [always]

        # ===== REPORTING (monolithic) =====
        - name: Send Discord notification
          include_tasks: tasks/notify_discord.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Backup"
            discord_status: "{{ 'failed' if backup_failed else 'successful' }}"
            discord_color: "{{ discord_color_failure if backup_failed else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Stacks"
                value: "{{ stack_assignments[inventory_hostname] | default([]) | join(', ') }}"
              - name: "Backup Name"
                value: "{{ backup_file }}"
              - name: "Backup Size"
                value: "{{ (file_size.stat.size / 1024 / 1024) | round(2) }}MB"
          when: inventory_hostname not in groups["docker_stacks"] | default([])
          tags: [always]

        - name: Send Docker recovery failure alert
          include_tasks: tasks/notify_discord.yaml
          when:
            - backup_failed | bool
            - (_docker_start_stacks is defined and _docker_start_stacks is failed) or
              (_docker_start_containers is defined and _docker_start_containers is failed)
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Backup"
            discord_status: "failed"
            discord_detail: "containers could not be restarted"
            discord_color: "{{ discord_color_failure }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Docker Recovery"
                value: "Manual intervention required"
          tags: [always]

        - name: Clean up UNVR temp backup file
          ansible.builtin.file:
            path: "{{ protect_temp_file }}"
            state: absent
          delegate_to: localhost
          when: inventory_hostname in groups["unifi_protect"]
          tags: [always]

        # ===== MARIADB LOGGING (per-stack — one row per stack) =====
        - name: Log per-stack backups to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          loop: "{{ _stack_backup_results }}"
          loop_control:
            loop_var: _stack_result
          vars:
            log_table: backups
            log_application: "{{ _stack_result.stack }}"
            log_hostname: "{{ inventory_hostname }}"
            log_file_name: "{{ ('FAILED_' if _stack_result.failed else '') + _stack_result.file }}"
            log_file_size: "{{ (_stack_result.file_size / 1024 / 1024) | round(2) }}"
          when: inventory_hostname in groups["docker_stacks"] | default([])
          tags: [always]

        # ===== MARIADB LOGGING (monolithic — single row) =====
        - name: Log backup to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          vars:
            log_table: backups
            log_application: "{{ backup_name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_file_name: "{{ ('FAILED_' if backup_failed else '') + backup_file }}"
            log_file_size: "{{ (file_size.stat.size / 1024 / 1024) | round(2) }}"
          when: inventory_hostname not in groups["docker_stacks"] | default([])
          tags: [always]
