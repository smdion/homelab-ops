---
# Back up host configurations and appdata.
# Docker stacks: per-stack archives (stop one stack at a time, minimize downtime).
# Other hosts: monolithic archive (stop Docker, archive all paths, restart).
# Sends Discord notification + logs each backup to MariaDB.
#
# Scope selectors (docker_stacks only):
#   stack=<name>  — back up a single stack (auto-resolves host)
#   app=<name>    — back up a single app's stack (resolves via app_definitions)
#   role=<name>   — back up all stacks in a role (auto-resolves host)
#
# Usage:
#   ansible-playbook backup_hosts.yaml -e hosts_variable=proxmox
#   ansible-playbook backup_hosts.yaml -e hosts_variable=docker_stacks
#   ansible-playbook backup_hosts.yaml -e hosts_variable=docker_stacks -e stack=auth
#   ansible-playbook backup_hosts.yaml -e hosts_variable=docker_stacks -e app=authentik
#   ansible-playbook backup_hosts.yaml -e hosts_variable=docker_stacks -e role=core

- name: Back up host configurations and appdata
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  serial: 1
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/host_definitions.yaml
    - vars/app_definitions.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"
  hosts: "{{ hosts_variable }}"

  pre_tasks:
    - name: Resolve scope (role injection + stack/role filtering)
      include_tasks: tasks/resolve_scope.yaml

    - name: Put device in RW mode
      raw: rw
      when:
        - inventory_hostname in groups["pikvm"]
        - not ansible_check_mode

    - name: Assert sufficient disk space on remote backup dir
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_tmp_dir }}"
        assert_disk_min_gb: "{{ backup_assert_disk_min_gb | default(2) }}"

    - name: Assert sufficient disk space on controller
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_base_dir }}"
        assert_disk_min_gb: "{{ controller_assert_disk_min_gb | default(2) }}"
        assert_disk_delegate_to: localhost
        assert_disk_become: false

    - name: Run standard pre-flight assertions
      include_tasks: tasks/pre_task_assertions.yaml
      vars:
        pre_assert_config_file: true
        pre_playbook: "backup_hosts.yaml"
        pre_run_vars: "{{ {'config_file': config_file | default('')} | to_json }}"

  tasks:
    - name: Delete temp backup directory
      become: true
      ansible.builtin.file:
        state: absent
        path: "{{ backup_tmp_dir }}"

    - name: Create temp backup directory
      become: true
      ansible.builtin.file:
        state: directory
        path: "{{ backup_tmp_dir }}"

    - name: Find old backup files
      become: true
      ansible.builtin.find:
        paths: "{{ item }}"
        age: "{{ unifi_backup_retention }}"
        age_stamp: mtime
        recurse: false
      register: _old_backups
      loop: "{{ src_raw_files }}"
      when: inventory_hostname in groups["unifi_network"]

    - name: Delete old backup files
      become: true
      ansible.builtin.file:
        path: "{{ found_file.path }}"
        state: absent
      loop: "{{ _old_backups.results | default([]) | map(attribute='files') | flatten }}"
      loop_control:
        loop_var: found_file
      when: inventory_hostname in groups["unifi_network"]

    - name: Extract WireGuard VPS config
      become: true
      ansible.builtin.shell: >
        awk '/"address": "{{ vps_address }}",/ {found=1; count=0} found && count<8 {gsub(/^[ \t]+/, "", $0); print; count++}'
        {{ unifi_state_file }} > {{ src_raw_files | first }}/{{ wg_config_file }}
      when: inventory_hostname in groups["unifi_network"]

    - name: Initialize file size and failure state
      ansible.builtin.set_fact:
        file_size: {stat: {size: 0}}
        backup_failed: false
        _stack_backup_results: []
        _amp_backup_results: []
        _target_stacks: >-
          {{ [stack] if stack is defined
             else backup_stack_order[inventory_hostname]
                  | default(stack_assignments[inventory_hostname] | default([]) | reverse | list) }}

    - block:
        # ===== PER-STACK BACKUP (docker_stacks hosts) =====
        - name: Back up per-stack archives
          include_tasks: tasks/backup_single_stack.yaml
          loop: "{{ _target_stacks }}"
          loop_control:
            loop_var: _backup_stack
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not ansible_check_mode

        - name: Set failed flag from per-stack results
          ansible.builtin.set_fact:
            backup_failed: "{{ _stack_backup_results | selectattr('failed') | list | length > 0 }}"
          when: inventory_hostname in groups["docker_stacks"] | default([])

        # ===== MONOLITHIC BACKUP (non-docker_stacks hosts) =====
        # ===== STOP DOCKER =====
        - include_tasks: tasks/docker_stop.yaml
          vars:
            _docker_exclude_containers: "{{ backup_exclude_containers | default([]) }}"
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname in groups["docker_run"] | default([])

        # ===== UNVR PROTECT BACKUP VIA API =====
        - name: Trigger UNVR backup
          ansible.builtin.uri:
            url: "https://{{ inventory_hostname }}{{ unifi_protect_api_backup_path }}"
            method: POST
            body_format: json
            body:
              cmd: "backup"
              days: "-1"
            validate_certs: false  # UNVR uses a self-signed cert; vendor API prevents proper TLS cert management
            headers:
              x-api-key: "{{ unvr_api_key }}"
            status_code: 200
          register: unvr_backup
          delegate_to: localhost
          ignore_errors: true  # TODO: API endpoint 404 — silence until correct path is found (IMP-10)
          when:
            - inventory_hostname in groups["unifi_protect"]
            - not ansible_check_mode

        - name: Download UNVR backup file
          ansible.builtin.get_url:
            url: "https://{{ inventory_hostname }}{{ unvr_backup.json.data[0].url }}"
            dest: "{{ unifi_protect_temp_file }}"
            mode: "0600"
            validate_certs: false  # UNVR uses a self-signed cert; vendor API prevents proper TLS cert management
            headers:
              x-api-key: "{{ unvr_api_key }}"
          delegate_to: localhost
          ignore_errors: true  # TODO: file retrieval broken — silence until fixed
          register: _unvr_download
          when:
            - inventory_hostname in groups["unifi_protect"]
            - not ansible_check_mode

        - name: Copy backup to UNVR
          ansible.builtin.copy:
            src: "{{ unifi_protect_temp_file }}"
            dest: "{{ backup_tmp_file }}"
          when:
            - inventory_hostname in groups["unifi_protect"]
            - not (_unvr_download.failed | default(false))
            - not ansible_check_mode

        # ===== UNVR: camera inventory export =====
        - name: Export Unifi Protect camera inventory
          ansible.builtin.uri:
            url: "https://{{ inventory_hostname }}/proxy/protect/api/cameras"
            method: GET
            validate_certs: false  # UNVR uses a self-signed cert
            headers:
              x-api-key: "{{ unvr_api_key }}"
            status_code: 200
          register: _protect_cameras
          delegate_to: localhost
          ignore_errors: true
          when:
            - inventory_hostname in groups["unifi_protect"]
            - not ansible_check_mode

        - name: Save camera inventory to controller
          ansible.builtin.copy:
            content: "{{ _protect_cameras.json | to_nice_json }}"
            dest: "{{ backup_base_dir }}/{{ inventory_hostname }}/protect_camera_inventory_{{ ansible_date_time.date }}.json"
            mode: "0600"
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname in groups["unifi_protect"]
            - _protect_cameras is defined
            - not (_protect_cameras.failed | default(false))
            - not ansible_check_mode

        # ===== Unifi Network: device inventory export =====
        - name: Export Unifi Network device inventory
          ansible.builtin.uri:
            url: "https://{{ inventory_hostname }}/proxy/network/api/s/default/stat/device"
            method: GET
            validate_certs: false  # UDM uses a self-signed cert
            headers:
              x-api-key: "{{ unifi_network_api_key }}"
            status_code: 200
          register: _unifi_devices
          delegate_to: localhost
          ignore_errors: true
          when:
            - inventory_hostname in groups["unifi_network"]
            - not ansible_check_mode

        - name: Save Unifi Network device inventory to controller
          ansible.builtin.copy:
            content: "{{ _unifi_devices.json | to_nice_json }}"
            dest: "{{ backup_base_dir }}/{{ inventory_hostname }}/unifi_device_inventory_{{ ansible_date_time.date }}.json"
            mode: "0600"
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname in groups["unifi_network"]
            - _unifi_devices is defined
            - not (_unifi_devices.failed | default(false))
            - not ansible_check_mode

        # ===== AMP PER-INSTANCE BACKUP =====
        # Step 1: slurp instances.json (become: true to read root-protected home dir)
        # then copy to controller via delegate_to (avoids fetch + FUSE mount issue)
        - name: Slurp instances.json registry
          become: true
          ansible.builtin.slurp:
            src: "{{ amp_home }}/.ampdata/instances.json"
          register: _amp_instances_json
          ignore_errors: true  # non-fatal — per-instance backups must still run
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not ansible_check_mode

        - name: Save instances.json registry to controller
          ansible.builtin.copy:
            content: "{{ _amp_instances_json.content | b64decode }}"
            dest: "{{ backup_base_dir }}/{{ inventory_hostname }}/amp_instances_{{ ansible_date_time.date }}.json"
            mode: "0600"
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname in groups["amp"] | default([])
            - _amp_instances_json is defined
            - not (_amp_instances_json.failed | default(false))
            - not ansible_check_mode

        # Step 2: discover and back up each instance
        - name: Discover AMP instances
          become: true
          ansible.builtin.find:
            paths: "{{ amp_home }}/.ampdata/instances"
            file_type: directory
            recurse: false
          register: _amp_instances_found
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not ansible_check_mode

        - name: Set AMP instance list
          ansible.builtin.set_fact:
            _amp_instances: "{{ _amp_instances_found.files | map(attribute='path') | map('basename') | sort | list }}"
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not ansible_check_mode

        - name: Save AMP instance inventory to controller
          ansible.builtin.copy:
            content: "{{ _amp_instances | default([]) | to_nice_json }}"
            dest: "{{ backup_base_dir }}/{{ inventory_hostname }}/amp_instance_inventory_{{ ansible_date_time.date }}.json"
            mode: "0600"
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname in groups["amp"] | default([])
            - _amp_instances is defined
            - not ansible_check_mode

        - name: Back up AMP instances
          include_tasks: tasks/backup_single_amp_instance.yaml
          loop: "{{ _amp_instances | default([]) }}"
          loop_control:
            loop_var: _amp_instance
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not ansible_check_mode
            - amp_instance_filter is not defined or _amp_instance == amp_instance_filter

        - name: Set failed flag from per-instance AMP results
          ansible.builtin.set_fact:
            backup_failed: "{{ _amp_backup_results | selectattr('failed') | list | length > 0 }}"
          when: inventory_hostname in groups["amp"] | default([])

        # ===== CREATE BACKUP (non-docker_stacks, non-UNVR, non-AMP hosts) =====
        - name: Filter backup paths to only existing directories
          become: true
          ansible.builtin.stat:
            path: "{{ item }}"
          loop: "{{ src_raw_files }}"
          register: _backup_paths_stat
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
            - inventory_hostname not in groups["amp"] | default([])

        - name: Set validated backup paths
          ansible.builtin.set_fact:
            _validated_backup_paths: >-
              {{ _backup_paths_stat.results | default([])
                 | selectattr('stat', 'defined')
                 | selectattr('stat.exists')
                 | map(attribute='item') | list }}
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
            - inventory_hostname not in groups["amp"] | default([])

        # When exclude dirs are defined, convert directory paths to globs (e.g. /opt → /opt/*)
        # so community.general.archive expands them to individual items that exclude_path can match.
        - name: Convert paths to globs for exclusion support
          ansible.builtin.set_fact:
            _archive_paths: >-
              {{ (_validated_backup_paths | default(src_raw_files))
                 | map('regex_replace', '/?$', '/*') | list }}
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
            - inventory_hostname not in groups["amp"] | default([])
            - backup_exclude_dirs | default([]) | length > 0

        # === unRAID: snapshot disk assignments to boot config (included in /boot archive) ===
        - name: Snapshot disk assignments to boot config
          ansible.builtin.copy:
            src: /var/local/emhttp/disks.ini
            dest: /boot/config/DISK_ASSIGNMENTS.ini
            remote_src: true
            mode: "0644"
          when:
            - inventory_hostname in groups['unraid'] | default([])
            - not ansible_check_mode

        # === unRAID: file inventory of all array shares (monthly — pass -e run_tree_index=true) ===
        - name: Assert find command is available
          ansible.builtin.shell: command -v find
          changed_when: false
          register: _find_check
          failed_when: _find_check.rc != 0
          check_mode: false
          when:
            - inventory_hostname in groups['unraid'] | default([])
            - run_tree_index | default(false) | bool

        - name: Generate file inventory of all array shares
          ansible.builtin.shell: |
            SAVEPATH="/mnt/user/Backup/{{ inventory_hostname }}/tree/array"
            for f in /mnt/user/*/; do
              share=$(basename "$f")
              mkdir -p "$SAVEPATH/$share"
              find "$f" | sort > "$SAVEPATH/$share/$(date +%Y%m%d).txt"
            done
          args:
            executable: /bin/bash
          changed_when: true
          when:
            - inventory_hostname in groups['unraid'] | default([])
            - run_tree_index | default(false) | bool
            - not ansible_check_mode

        # === PBS: export job and datastore configs into /etc so they're included in the archive ===
        - name: Create PBS DR export directory
          become: true
          ansible.builtin.file:
            path: /etc/proxmox-backup/dr-export
            state: directory
            mode: "0700"
          when:
            - inventory_hostname in groups['pbs'] | default([])
            - not ansible_check_mode

        - name: Export PBS job and datastore configurations
          become: true
          ansible.builtin.shell: |
            for job_type in sync-job backup-job prune-job verify-job; do
              proxmox-backup-manager ${job_type} list --output-format json \
                > /etc/proxmox-backup/dr-export/${job_type}-list.json 2>/dev/null || true
            done
            proxmox-backup-manager datastore list --output-format json \
              > /etc/proxmox-backup/dr-export/datastore-list.json 2>/dev/null || true
          args:
            executable: /bin/bash
          changed_when: true
          when:
            - inventory_hostname in groups['pbs'] | default([])
            - not ansible_check_mode

        - name: Create compressed backup archive
          become: true
          community.general.archive:
            path: "{{ _archive_paths | default(_validated_backup_paths) | default(src_raw_files) }}"
            dest: "{{ backup_tmp_file }}"
            format: gz
            remove: false
            exclude_path: "{{ backup_exclude_dirs | default([]) }}"
          timeout: 3600
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["unifi_protect"]
            - inventory_hostname not in groups["amp"] | default([])

        - name: Get backup file size
          ansible.builtin.stat:
            path: "{{ backup_tmp_file }}"
          register: file_size
          changed_when: false
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["amp"] | default([])

        # ===== START DOCKER =====
        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_wait_ssh: true
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname in groups["docker_run"] | default([])

        # ===== FETCH AND CLEANUP =====
        - name: Delete stale archive on controller
          ansible.builtin.file:
            path: "{{ backup_dest_path }}"
            state: absent
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["amp"] | default([])

        - name: Fetch backup to controller
          ansible.builtin.fetch:
            src: "{{ backup_tmp_file }}"
            dest: "{{ backup_dest_path }}"
            flat: true
          become: false
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["amp"] | default([])

        - name: Delete source backup
          become: true
          ansible.builtin.file:
            path: "{{ backup_tmp_file }}"
            state: absent
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["amp"] | default([])

        - name: Put PiKVM back in RO mode
          raw: ro
          when:
            - inventory_hostname in groups["pikvm"]
            - not ansible_check_mode

      rescue:
        - name: Set backup failed flag
          ansible.builtin.set_fact:
            backup_failed: true

      always:
        # ===== SAFETY NET: ENSURE DOCKER IS RUNNING =====
        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_ignore_errors: true
          when: inventory_hostname in groups["docker_run"] | default([])

        # ===== WAIT FOR MARIADB AFTER DOCKER RESTART =====
        - name: Wait for MariaDB logging database after Docker restart
          vars:
            ansible_python_interpreter: "{{ ansible_playbook_python }}"
          become: false
          connection: local
          community.mysql.mysql_query:
            login_host: "{{ logging_db_host }}"
            login_port: "{{ logging_db_port }}"
            login_user: "{{ logging_db_user }}"
            login_password: "{{ logging_db_password }}"
            login_db: "{{ logging_db_name }}"
            query: "SELECT 1"
          register: _mariadb_post_restart
          retries: 40
          delay: 10
          until: _mariadb_post_restart is succeeded
          when: inventory_hostname in groups["docker_stacks"] or inventory_hostname in groups["docker_run"]
          changed_when: false
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
          check_mode: false
          ignore_errors: true

        # ===== REPORTING (per-stack) =====
        - name: Build per-stack Discord fields
          ansible.builtin.set_fact:
            _stack_discord_fields: >-
              [
               {% for r in _stack_backup_results %}
               {% if not loop.first %},{% endif %}
               {"name": "{{ ('❌ ' if r.failed else '✅ ') + r.stack }}", "value": "{{ 'FAILED' if r.failed else ('empty' if r.file_size == 0 else ((r.file_size / 1024 / 1024) | round(2) | string + ' MB')) }}", "inline": true}
               {% endfor %}]
          when: inventory_hostname in groups["docker_stacks"] | default([])

        - name: Send per-stack Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Backup"
            discord_status: >-
              {{ 'successful' if not (backup_failed | bool)
                 else ('failed' if (_stack_backup_results | rejectattr('failed') | list | length == 0)
                       else 'partial') }}
            discord_color: >-
              {{ discord_color_success if not (backup_failed | bool)
                 else (discord_color_failure if (_stack_backup_results | rejectattr('failed') | list | length == 0)
                       else discord_color_warning) }}
            discord_url: "{{ backup_url }}"
            discord_fields: "{{ _stack_discord_fields }}"
          when: inventory_hostname in groups["docker_stacks"] | default([])

        # ===== REPORTING (per-AMP-instance) =====
        - name: Build per-instance AMP Discord fields
          ansible.builtin.set_fact:
            _amp_discord_fields: >-
              [
               {% for r in _amp_backup_results %}
               {% if not loop.first %},{% endif %}
               {"name": "{{ ('❌ ' if r.failed else '✅ ') + r.instance }}", "value": "{{ 'FAILED' if r.failed else ('empty' if r.file_size == 0 else ((r.file_size / 1024 / 1024) | round(2) | string + ' MB')) }}", "inline": true}
               {% endfor %}]
          when: inventory_hostname in groups["amp"] | default([])

        - name: Send per-instance AMP Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Backup"
            discord_status: >-
              {{ 'successful' if not (backup_failed | bool)
                 else ('failed' if (_amp_backup_results | rejectattr('failed') | list | length == 0)
                       else 'partial') }}
            discord_color: >-
              {{ discord_color_success if not (backup_failed | bool)
                 else (discord_color_failure if (_amp_backup_results | rejectattr('failed') | list | length == 0)
                       else discord_color_warning) }}
            discord_url: "{{ backup_url }}"
            discord_fields: "{{ _amp_discord_fields }}"
          when: inventory_hostname in groups["amp"] | default([])

        # ===== REPORTING (monolithic) =====
        - name: Send Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Backup"
            discord_status: "{{ 'failed' if backup_failed else 'successful' }}"
            discord_color: "{{ discord_color_failure if backup_failed else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Stacks"
                value: "{{ stack_assignments[inventory_hostname] | default([]) | join(', ') }}"
              - name: "Backup Name"
                value: "{{ backup_file }}"
              - name: "Backup Size"
                value: "{{ (file_size.stat.size / 1024 / 1024) | round(2) }}MB"
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["amp"] | default([])
            - inventory_hostname not in groups["unifi_protect"]  # TODO: file retrieval broken — silence until fixed

        - name: Send Docker recovery failure alert
          include_tasks: tasks/notify.yaml
          when:
            - backup_failed | bool
            - (_docker_start_stacks is defined and _docker_start_stacks is failed) or
              (_docker_start_containers is defined and _docker_start_containers is failed)
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Backup"
            discord_status: "failed"
            discord_detail: "containers could not be restarted"
            discord_color: "{{ discord_color_failure }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Docker Recovery"
                value: "Manual intervention required"

        - name: Clean up UNVR temp backup file
          ansible.builtin.file:
            path: "{{ unifi_protect_temp_file }}"
            state: absent
          delegate_to: localhost
          when: inventory_hostname in groups["unifi_protect"]

        # ===== MARIADB LOGGING (per-stack — one row per stack) =====
        - name: Log per-stack backups to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          loop: "{{ _stack_backup_results }}"
          loop_control:
            loop_var: _stack_result
          vars:
            log_table: backups
            log_application: "{{ _stack_result.stack }}"
            log_hostname: "{{ inventory_hostname }}"
            log_file_name: "{{ ('FAILED_' if _stack_result.failed else '') + _stack_result.file }}"
            log_file_size: "{{ (_stack_result.file_size / 1024 / 1024) | round(2) }}"
            log_backup_level: "stack"
          when: inventory_hostname in groups["docker_stacks"] | default([])

        # ===== MARIADB LOGGING (per-AMP-instance — one row per instance) =====
        - name: Log per-instance AMP backups to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          loop: "{{ _amp_backup_results }}"
          loop_control:
            loop_var: _amp_result
          vars:
            log_table: backups
            log_application: "{{ backup_name }} — {{ _amp_result.instance }}"
            log_hostname: "{{ inventory_hostname }}"
            log_file_name: "{{ ('FAILED_' if _amp_result.failed else '') + _amp_result.file }}"
            log_file_size: "{{ (_amp_result.file_size / 1024 / 1024) | round(2) }}"
            log_backup_level: "instance"
          when: inventory_hostname in groups["amp"] | default([])

        # ===== MARIADB LOGGING (monolithic — single row) =====
        - name: Log backup to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          vars:
            log_table: backups
            log_application: "{{ backup_name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_file_name: "{{ ('FAILED_' if backup_failed else '') + backup_file }}"
            log_file_size: "{{ (file_size.stat.size / 1024 / 1024) | round(2) }}"
            log_backup_level: "host"
          when:
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - inventory_hostname not in groups["amp"] | default([])
            - inventory_hostname not in groups["unifi_protect"]  # TODO: file retrieval broken — silence until fixed
