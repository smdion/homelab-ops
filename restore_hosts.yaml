---
# Restore config/appdata archives from backup.
# Two modes: staging (inspect) and inplace (restore). Supports selective app restore,
# per-stack restore, and coordinated DB+appdata restore with cross-host delegate_to.
# Sends Discord notification and logs result to restores table.
#
# Usage:
#   # Stage full backup for inspection (default, safe)
#   ansible-playbook restore_hosts.yaml -e hosts_variable=proxmox
#
#   # Restore a specific stack's appdata (per-stack archives)
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_stacks --limit <hostname> -e restore_stack=auth -e restore_mode=inplace -e confirm=yes -e with_docker=yes
#
#   # Stage just one app's appdata from the full archive
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_run --limit <hostname> -e restore_app=sonarr
#
#   # In-place restore of ONE specific app's appdata only
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_run --limit <hostname> -e restore_app=sonarr -e restore_mode=inplace -e confirm=yes -e with_docker=yes
#
#   # COORDINATED RESTORE â€” appdata + databases together (cross-host via delegate_to)
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_run --limit <hostname> -e restore_app=sonarr -e with_databases=yes -e restore_mode=inplace -e confirm=yes -e with_docker=yes

- name: Restore config/appdata from backup
  hosts: "{{ hosts_variable }}"
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  serial: 1
  vars_files:
    - vars/secrets.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"
    restore_mode: staging

  pre_tasks:
    - name: Assert config_file is defined and non-empty
      include_tasks: tasks/assert_config_file.yaml

    - name: Assert UNVR not targeted
      ansible.builtin.assert:
        that: inventory_hostname not in groups["unifi_protect"] | default([])
        fail_msg: "UNVR .unf backups require manual restore via the Protect UI"

    - name: Assert confirm for inplace mode
      ansible.builtin.assert:
        that: confirm | default('no') == 'yes'
        fail_msg: >-
          In-place restore requires -e confirm=yes.
          Run without restore_mode=inplace for safe staging mode.
      when: restore_mode == 'inplace'

    - name: Assert sufficient disk space
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_tmp_dir if restore_mode == 'staging' else '/' }}"
        assert_disk_min_gb: "{{ backup_assert_disk_min_gb | default(2) }}"

    - name: Assert MariaDB logging database is reachable
      include_tasks: tasks/assert_db_connectivity.yaml

    - name: Put PiKVM in RW mode
      raw: rw
      when:
        - inventory_hostname in groups["pikvm"]
        - not ansible_check_mode
      tags: [always]

  tasks:
    - name: Initialize restore state
      ansible.builtin.set_fact:
        restore_failed: false
        _restore_source_file: "unknown"
        _restore_detail: ""
      tags: [always]

    - block:
        # ===== FIND AND VERIFY BACKUP ARCHIVE =====
        - name: Find per-stack backup archive on controller
          ansible.builtin.shell: >
            ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_{{ restore_stack }}_{{ restore_date | default('') }}*.tar.gz 2>/dev/null | head -1
          register: _archive_file
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when: restore_stack | default('') | length > 0
          tags: [always]

        - name: Find backup archive on controller
          ansible.builtin.shell: >
            ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_*{{ restore_date | default('') }}*.tar.gz 2>/dev/null | head -1
          register: _archive_file
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when: restore_stack | default('') | length == 0
          tags: [always]

        - name: Assert backup archive exists
          ansible.builtin.assert:
            that: _archive_file.stdout | length > 0
            fail_msg: >-
              No backup archive found for {{ inventory_hostname }} on controller
              {{ '(stack: ' + restore_stack + ')' if restore_stack | default('') | length > 0 else '' }}
              {{ ' for date ' + restore_date if restore_date | default('') | length > 0 else '' }}
          tags: [always]

        - name: Set source file fact
          ansible.builtin.set_fact:
            _restore_source_file: "{{ _archive_file.stdout | basename }}"
          tags: [always]

        - name: Verify archive integrity
          ansible.builtin.shell: gunzip -t "{{ _archive_file.stdout }}"
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          tags: [always]

        # ===== SELECTIVE APP EXTRACTION PATH =====
        - name: Compute extract path for selective app restore
          ansible.builtin.set_fact:
            _extract_path: "{{ (src_raw_files[0] | regex_replace('^/', '')) + '/' + restore_app }}"
          when:
            - restore_app | default('') | length > 0
            - restore_stack | default('') | length == 0
          tags: [always]

        - name: Verify app directory exists in archive
          ansible.builtin.shell: tar tzf "{{ _archive_file.stdout }}" | grep -q "^{{ _extract_path }}/"
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when:
            - restore_app | default('') | length > 0
            - restore_stack | default('') | length == 0
          tags: [always]

        # ===== STOP DOCKER =====
        - include_tasks: tasks/docker_stop.yaml
          vars:
            _docker_selective_stacks: ["{{ restore_stack }}"]
          when:
            - with_docker | default('') == 'yes'
            - restore_stack | default('') | length > 0
            - not ansible_check_mode
          tags: [always]

        - include_tasks: tasks/docker_stop.yaml
          vars:
            _docker_selective_containers: "{{ app_restore[restore_app].containers }}"
          when:
            - with_docker | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
            - not ansible_check_mode
          tags: [always]

        - include_tasks: tasks/docker_stop.yaml
          when:
            - with_docker | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length == 0
            - not ansible_check_mode
          tags: [docker]

        # ===== COORDINATED DB RESTORE (cross-host via delegate_to) =====
        - name: Load DB vars into namespace
          ansible.builtin.include_vars:
            file: "vars/{{ app_restore[restore_app].db_config_file }}.yaml"
            name: _db_vars
          when:
            - with_databases | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
          tags: [always]

        - name: Find DB backup files on controller
          ansible.builtin.shell: >
            ls -t {{ backup_base_dir }}/{{ app_restore[restore_app].db_host }}/backup_{{ item }}_{{ restore_date | default('*') }}.sql 2>/dev/null | head -1
          loop: "{{ app_restore[restore_app].db_names }}"
          register: _db_backup_files
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when:
            - with_databases | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
          tags: [always]

        - name: Assert DB backup files exist
          ansible.builtin.assert:
            that: _db_backup_files.results[idx].stdout | length > 0
            fail_msg: "No backup found for database {{ item }}"
          loop: "{{ app_restore[restore_app].db_names }}"
          loop_control:
            index_var: idx
          when:
            - with_databases | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
          tags: [always]

        - name: Copy DB backup files to DB host
          ansible.builtin.copy:
            src: "{{ _db_backup_files.results[idx].stdout }}"
            dest: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.sql"
          loop: "{{ app_restore[restore_app].db_names }}"
          loop_control:
            index_var: idx
          delegate_to: "{{ app_restore[restore_app].db_host }}"
          become: true
          when:
            - with_databases | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
            - not ansible_check_mode
          tags: [always]

        - name: Restore databases on DB host
          include_tasks: tasks/db_restore.yaml
          loop: "{{ app_restore[restore_app].db_names }}"
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ _db_vars.db_container_name }}"
            _db_username: "{{ _db_vars.db_username }}"
            _db_password: "{{ db_password }}"
            _db_source_file: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.sql"
            _db_is_postgres: "{{ _db_vars.is_postgres | default(false) }}"
            _db_is_mariadb: "{{ _db_vars.is_mariadb | default(false) }}"
            _db_is_influxdb: false
            _db_tmp_dir: "{{ _db_vars.backup_tmp_dir }}"
          delegate_to: "{{ app_restore[restore_app].db_host }}"
          when:
            - with_databases | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
            - not ansible_check_mode
          tags: [always]

        - name: Validate restored databases on DB host
          include_tasks: tasks/db_count.yaml
          loop: "{{ app_restore[restore_app].db_names }}"
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ _db_vars.db_container_name }}"
            _db_username: "{{ _db_vars.db_username }}"
            _db_password: "{{ db_password }}"
            _db_is_postgres: "{{ _db_vars.is_postgres | default(false) }}"
            _db_is_mariadb: "{{ _db_vars.is_mariadb | default(false) }}"
            _db_is_influxdb: false
          delegate_to: "{{ app_restore[restore_app].db_host }}"
          when:
            - with_databases | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
            - not ansible_check_mode
          tags: [always]

        - name: Clean up DB temp files on DB host
          ansible.builtin.file:
            path: "{{ _db_vars.backup_tmp_dir }}/restore_{{ item }}.sql"
            state: absent
          loop: "{{ app_restore[restore_app].db_names }}"
          delegate_to: "{{ app_restore[restore_app].db_host }}"
          become: true
          when:
            - with_databases | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
          tags: [always]

        # ===== RESTORE APPDATA =====
        - include_tasks: tasks/restore_appdata.yaml
          vars:
            _restore_archive_path: "{{ _archive_file.stdout }}"
            _restore_mode: "{{ restore_mode }}"
            _restore_extract_path: "{{ _extract_path | default('') }}"
            _restore_app_name: "{{ restore_stack | default(restore_app | default('')) }}"
          tags: [always]

        - name: Append DB restore detail
          ansible.builtin.set_fact:
            _restore_detail: >-
              {{ _restore_detail }}
              + {{ app_restore[restore_app].db_names | join(', ') }} DB(s) restored
          when:
            - restore_mode == 'inplace'
            - with_databases | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
            - not ansible_check_mode
          tags: [always]

        # ===== START DOCKER =====
        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_selective_stacks: ["{{ restore_stack }}"]
          when:
            - with_docker | default('') == 'yes'
            - restore_stack | default('') | length > 0
            - not ansible_check_mode
          tags: [always]

        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_selective_containers: "{{ app_restore[restore_app].containers }}"
          when:
            - with_docker | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
            - not ansible_check_mode
          tags: [always]

        - include_tasks: tasks/docker_start.yaml
          when:
            - with_docker | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length == 0
            - not ansible_check_mode
          tags: [docker]

        # ===== CLEANUP =====
        - name: Clean up temp archive
          ansible.builtin.file:
            path: "{{ backup_tmp_dir }}/restore_{{ restore_mode }}.tar.gz"
            state: absent
          become: true
          tags: [always]

      rescue:
        - name: Set restore failed flag
          ansible.builtin.set_fact:
            restore_failed: true

        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_ignore_errors: true
          when: with_docker | default('') == 'yes'
          tags: [docker]

        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_selective_stacks: ["{{ restore_stack }}"]
            _docker_ignore_errors: true
          when:
            - with_docker | default('') == 'yes'
            - restore_stack | default('') | length > 0
          tags: [always]

        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_selective_containers: "{{ app_restore[restore_app].containers }}"
            _docker_ignore_errors: true
          when:
            - with_docker | default('') == 'yes'
            - restore_stack | default('') | length == 0
            - restore_app | default('') | length > 0
            - app_restore is defined
            - app_restore[restore_app] is defined
          tags: [always]

      always:
        - name: Send Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: "{{ 'failed' if restore_failed else 'successful' }}"
            discord_detail: >-
              {{ ('stack: ' + restore_stack) if restore_stack | default('') | length > 0
                 else (restore_app if restore_app | default('') | length > 0 else '') }}
            discord_color: "{{ discord_color_failure if restore_failed else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Mode"
                value: "{{ restore_mode | capitalize }}"
              - name: "Source File"
                value: "{{ _restore_source_file | regex_replace('^.*_(\\d{4}-\\d{2}-\\d{2}).*$', '\\1') }}"
              - name: "Detail"
                value: "{{ _restore_detail | default('check Semaphore logs') }}"
          tags: [always]

        - name: Log restore to MariaDB
          include_tasks: tasks/log_restore.yaml
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ restore_stack | default(restore_app | default(backup_name)) }}"
            restore_source_file: "{{ _restore_source_file }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if restore_failed else 'success' }}"
            restore_detail: "{{ _restore_detail | default('check Semaphore logs') }}"
          tags: [always]

        - name: Put PiKVM back in RO mode
          raw: ro
          when:
            - inventory_hostname in groups["pikvm"]
            - not ansible_check_mode
          tags: [always]
