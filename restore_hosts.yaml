---
# Restore config/appdata archives from backup.
# Three paths: per-stack (docker_stacks), selective app (docker_run), monolithic (full host).
# Sends Discord notification and logs result to restores table.
#
# Safety-gated: requires -e confirm=yes to proceed.
# Containers are always stopped before restore and restarted after.
#
# Scope selectors (docker_stacks only):
#   stack=<name>  — restore a single stack (auto-resolves host)
#   role=<name>   — restore all stacks in a role (auto-resolves host)
#
# Usage:
#   # Restore a specific stack's appdata
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_stacks -e stack=auth -e confirm=yes
#
#   # Restore all stacks in a role
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_stacks -e role=core -e confirm=yes
#
#   # Restore ONE specific app's appdata (monolithic archive)
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_run --limit <hostname> -e restore_app=sonarr -e confirm=yes
#
#   # COORDINATED RESTORE — appdata + databases together (cross-host via delegate_to)
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_run --limit <hostname> -e restore_app=sonarr -e with_databases=yes -e confirm=yes

- name: Restore config/appdata from backup
  hosts: "{{ hosts_variable }}"
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  serial: 1
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/host_definitions.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"

  pre_tasks:
    - name: Resolve restore_stack → stack alias
      ansible.builtin.set_fact:
        stack: "{{ restore_stack }}"
      when:
        - restore_stack is defined
        - stack is not defined

    - name: Resolve scope (role injection + stack/role filtering)
      include_tasks: tasks/resolve_scope.yaml

    - name: Assert UNVR not targeted
      ansible.builtin.assert:
        that: inventory_hostname not in groups["unifi_protect"] | default([])
        fail_msg: "UNVR .unf backups require manual restore via the Protect UI"

    - name: Assert confirm for restore
      ansible.builtin.assert:
        that: confirm | default('no') == 'yes'
        fail_msg: >-
          Restore requires -e confirm=yes.
          Use verify_backups.yaml to inspect archives without restoring.

    - name: Assert sufficient disk space
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "/"
        assert_disk_min_gb: "{{ backup_assert_disk_min_gb | default(2) }}"

    - name: Run standard pre-flight assertions
      include_tasks: tasks/pre_task_assertions.yaml
      vars:
        pre_assert_config_file: true
        pre_playbook: "restore_hosts.yaml"
        pre_run_vars: "{{ {'config_file': config_file | default('')} | to_json }}"

    - name: Put PiKVM in RW mode
      raw: rw
      when:
        - inventory_hostname in groups["pikvm"]
        - not ansible_check_mode

  tasks:
    - name: Initialize restore state
      ansible.builtin.set_fact:
        restore_failed: false
        _restore_source_file: "unknown"
        _restore_detail: ""
        _stack_restore_results: []
        _target_stacks: >-
          {{ [stack] if stack is defined
             else (stack_assignments[inventory_hostname] | default([])) if role is defined
             else (stack_assignments[inventory_hostname] | default([])) if inventory_hostname in groups['docker_stacks'] | default([])
             else [] }}

    - name: Compute restore path
      ansible.builtin.set_fact:
        _restore_path: >-
          {{ 'stack' if _target_stacks | length > 0
             else 'app' if restore_app | default('') | length > 0
             else 'monolithic' }}

    - block:
        # ===== PER-STACK PATH (docker_stacks — single stack or role) =====
        - name: Restore stack — {{ _restore_stack_item }}
          include_tasks: tasks/restore_single_stack.yaml
          loop: "{{ _target_stacks }}"
          loop_control:
            loop_var: _restore_stack_item
          when: _restore_path == 'stack'

        - name: Set failed flag from per-stack results
          ansible.builtin.set_fact:
            restore_failed: "{{ _stack_restore_results | selectattr('failed') | list | length > 0 }}"
          when: _restore_path == 'stack'

        # ===== SELECTIVE APP PATH (docker_run with restore_app) =====
        - include_tasks: tasks/restore_selective_app.yaml
          when: _restore_path == 'app'

        # ===== MONOLITHIC PATH (full host archive) =====
        - include_tasks: tasks/restore_monolithic.yaml
          when: _restore_path == 'monolithic'

      rescue:
        - name: Set restore failed flag
          ansible.builtin.set_fact:
            restore_failed: true

        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_ignore_errors: true
          when: inventory_hostname in groups["docker_stacks"] | default([]) or inventory_hostname in groups["docker_run"] | default([])

      always:
        # ===== REPORTING (per-stack) =====
        - name: Build per-stack Discord fields
          ansible.builtin.set_fact:
            _stack_restore_discord_fields: >-
              [
               {% for r in _stack_restore_results %}
               {% if not loop.first %},{% endif %}
               {"name": "{{ ('❌ ' if r.failed else '✅ ') + r.stack }}", "value": "{{ 'FAILED' if r.failed else (r.archive | regex_replace('^.*_(\\d{4}-\\d{2}-\\d{2})\\.tar\\.gz$', '\\1')) }}", "inline": true}
               {% endfor %}]
          when: _restore_path == 'stack'

        - name: Send per-stack Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: >-
              {{ 'successful' if not (restore_failed | bool)
                 else ('failed' if (_stack_restore_results | rejectattr('failed') | list | length == 0)
                       else 'partial') }}
            discord_detail: "Restore"
            discord_color: >-
              {{ discord_color_success if not (restore_failed | bool)
                 else (discord_color_failure if (_stack_restore_results | rejectattr('failed') | list | length == 0)
                       else discord_color_warning) }}
            discord_url: "{{ backup_url }}"
            discord_fields: "{{ _stack_restore_discord_fields }}"
          when: _restore_path == 'stack'

        - name: Log per-stack restores to MariaDB
          include_tasks: tasks/log_restore.yaml
          loop: "{{ _stack_restore_results }}"
          loop_control:
            loop_var: _stack_result
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ _stack_result.stack }}"
            restore_source_file: "{{ _stack_result.archive }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if _stack_result.failed else 'success' }}"
            restore_detail: >-
              {{ 'restore failed — check Semaphore logs' if _stack_result.failed
                 else 'restore of ' + _stack_result.stack }}
          when: _restore_path == 'stack'

        # ===== REPORTING (single result — app / monolithic) =====
        - name: Send Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: "{{ 'failed' if restore_failed else 'successful' }}"
            discord_detail: >-
              {{ restore_app if restore_app | default('') | length > 0 else '' }}
            discord_color: "{{ discord_color_failure if restore_failed else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Source File"
                value: "{{ _restore_source_file | regex_replace('^.*_(\\d{4}-\\d{2}-\\d{2}).*$', '\\1') }}"
              - name: "Detail"
                value: "{{ _restore_detail | default('check Semaphore logs') }}"
          when: _restore_path != 'stack'

        - name: Log restore to MariaDB
          include_tasks: tasks/log_restore.yaml
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ restore_app | default(backup_name) }}"
            restore_source_file: "{{ _restore_source_file }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if restore_failed else 'success' }}"
            restore_detail: "{{ _restore_detail | default('check Semaphore logs') }}"
          when: _restore_path != 'stack'

        - name: Put PiKVM back in RO mode
          raw: ro
          when:
            - inventory_hostname in groups["pikvm"]
            - not ansible_check_mode
