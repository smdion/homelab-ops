---
# Restore config/appdata archives from backup.
# Three paths: per-stack (docker_stacks), selective app (docker_run), monolithic (full host).
# Sends Discord notification and logs result to restores table.
#
# Scope selectors (docker_stacks only):
#   stack=<name>  — restore a single stack (auto-resolves host)
#   role=<name>   — restore all stacks in a role (auto-resolves host)
#
# Usage:
#   # Stage full backup for inspection (default, safe)
#   ansible-playbook restore_hosts.yaml -e hosts_variable=proxmox
#
#   # Restore a specific stack's appdata (per-stack archives)
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_stacks -e stack=auth -e restore_mode=inplace -e confirm=yes -e with_docker=yes
#
#   # Restore all stacks in a role
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_stacks -e role=core -e restore_mode=inplace -e confirm=yes -e with_docker=yes
#
#   # Stage just one app's appdata from the full archive
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_run --limit <hostname> -e restore_app=sonarr
#
#   # In-place restore of ONE specific app's appdata only
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_run --limit <hostname> -e restore_app=sonarr -e restore_mode=inplace -e confirm=yes -e with_docker=yes
#
#   # COORDINATED RESTORE — appdata + databases together (cross-host via delegate_to)
#   ansible-playbook restore_hosts.yaml -e hosts_variable=docker_run --limit <hostname> -e restore_app=sonarr -e with_databases=yes -e restore_mode=inplace -e confirm=yes -e with_docker=yes

- name: Restore config/appdata from backup
  hosts: "{{ hosts_variable }}"
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  serial: 1
  vars_files:
    - vars/secrets.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"
    restore_mode: staging

  pre_tasks:
    - name: Assert config_file is defined and non-empty
      include_tasks: tasks/assert_config_file.yaml

    - name: Resolve restore_stack → stack alias
      ansible.builtin.set_fact:
        stack: "{{ restore_stack }}"
      when:
        - restore_stack is defined
        - stack is not defined

    - name: Resolve scope (role injection + stack/role filtering)
      include_tasks: tasks/resolve_scope.yaml

    - name: Assert UNVR not targeted
      ansible.builtin.assert:
        that: inventory_hostname not in groups["unifi_protect"] | default([])
        fail_msg: "UNVR .unf backups require manual restore via the Protect UI"

    - name: Assert confirm for inplace mode
      ansible.builtin.assert:
        that: confirm | default('no') == 'yes'
        fail_msg: >-
          In-place restore requires -e confirm=yes.
          Run without restore_mode=inplace for safe staging mode.
      when: restore_mode == 'inplace'

    - name: Assert sufficient disk space
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_tmp_dir if restore_mode == 'staging' else '/' }}"
        assert_disk_min_gb: "{{ backup_assert_disk_min_gb | default(2) }}"

    - name: Assert MariaDB logging database is reachable
      include_tasks: tasks/assert_db_connectivity.yaml

    - name: Log playbook run context to MariaDB
      include_tasks: tasks/log_run_context.yaml
      vars:
        log_playbook: "restore_hosts.yaml"
        log_hostname: "{{ inventory_hostname }}"
        log_run_vars: "{{ {'config_file': config_file | default('')} | to_json }}"

    - name: Put PiKVM in RW mode
      raw: rw
      when:
        - inventory_hostname in groups["pikvm"]
        - not ansible_check_mode
      tags: [always]

  tasks:
    - name: Initialize restore state
      ansible.builtin.set_fact:
        restore_failed: false
        _restore_source_file: "unknown"
        _restore_detail: ""
        _stack_restore_results: []
        _target_stacks: >-
          {{ [stack] if stack is defined
             else (stack_assignments[inventory_hostname] | default([])) if role is defined
             else (stack_assignments[inventory_hostname] | default([])) if inventory_hostname in groups['docker_stacks'] | default([])
             else [] }}
      tags: [always]

    - name: Compute restore path
      ansible.builtin.set_fact:
        _restore_path: >-
          {{ 'stack' if _target_stacks | length > 0
             else 'app' if restore_app | default('') | length > 0
             else 'monolithic' }}
      tags: [always]

    - block:
        # ===== PER-STACK PATH (docker_stacks — single stack or role) =====
        - name: Restore stack — {{ _restore_stack_item }}
          include_tasks: tasks/restore_single_stack.yaml
          loop: "{{ _target_stacks }}"
          loop_control:
            loop_var: _restore_stack_item
          when: _restore_path == 'stack'

        - name: Set failed flag from per-stack results
          ansible.builtin.set_fact:
            restore_failed: "{{ _stack_restore_results | selectattr('failed') | list | length > 0 }}"
          when: _restore_path == 'stack'

        # ===== SELECTIVE APP PATH (docker_run with restore_app) =====
        - include_tasks: tasks/restore_selective_app.yaml
          when: _restore_path == 'app'

        # ===== MONOLITHIC PATH (full host archive) =====
        - include_tasks: tasks/restore_monolithic.yaml
          when: _restore_path == 'monolithic'

      rescue:
        - name: Set restore failed flag
          ansible.builtin.set_fact:
            restore_failed: true

        - include_tasks: tasks/docker_start.yaml
          vars:
            _docker_ignore_errors: true
          when: with_docker | default('') == 'yes'
          tags: [docker]

      always:
        # ===== REPORTING (per-stack) =====
        - name: Build per-stack Discord fields
          ansible.builtin.set_fact:
            _stack_restore_discord_fields: >-
              [
               {% for r in _stack_restore_results %}
               {% if not loop.first %},{% endif %}
               {"name": "{{ ('❌ ' if r.failed else '✅ ') + r.stack }}", "value": "{{ 'FAILED' if r.failed else (r.archive | regex_replace('^.*_(\\d{4}-\\d{2}-\\d{2})\\.tar\\.gz$', '\\1')) }}", "inline": true}
               {% endfor %}]
          when: _restore_path == 'stack'
          tags: [always]

        - name: Send per-stack Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: >-
              {{ 'successful' if not (restore_failed | bool)
                 else ('failed' if (_stack_restore_results | rejectattr('failed') | list | length == 0)
                       else 'partial') }}
            discord_detail: "{{ restore_mode | capitalize }}"
            discord_color: >-
              {{ discord_color_success if not (restore_failed | bool)
                 else (discord_color_failure if (_stack_restore_results | rejectattr('failed') | list | length == 0)
                       else discord_color_warning) }}
            discord_url: "{{ backup_url }}"
            discord_fields: "{{ _stack_restore_discord_fields }}"
          when: _restore_path == 'stack'
          tags: [always]

        - name: Log per-stack restores to MariaDB
          include_tasks: tasks/log_restore.yaml
          loop: "{{ _stack_restore_results }}"
          loop_control:
            loop_var: _stack_result
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ _stack_result.stack }}"
            restore_source_file: "{{ _stack_result.archive }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if _stack_result.failed else 'success' }}"
            restore_detail: >-
              {{ 'restore failed — check Semaphore logs' if _stack_result.failed
                 else restore_mode + ' restore of ' + _stack_result.stack }}
          when: _restore_path == 'stack'
          tags: [always]

        # ===== REPORTING (single result — app / monolithic) =====
        - name: Send Discord notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: "{{ 'failed' if restore_failed else 'successful' }}"
            discord_detail: >-
              {{ restore_app if restore_app | default('') | length > 0 else '' }}
            discord_color: "{{ discord_color_failure if restore_failed else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Mode"
                value: "{{ restore_mode | capitalize }}"
              - name: "Source File"
                value: "{{ _restore_source_file | regex_replace('^.*_(\\d{4}-\\d{2}-\\d{2}).*$', '\\1') }}"
              - name: "Detail"
                value: "{{ _restore_detail | default('check Semaphore logs') }}"
          when: _restore_path != 'stack'
          tags: [always]

        - name: Log restore to MariaDB
          include_tasks: tasks/log_restore.yaml
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ restore_app | default(backup_name) }}"
            restore_source_file: "{{ _restore_source_file }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if restore_failed else 'success' }}"
            restore_detail: "{{ _restore_detail | default('check Semaphore logs') }}"
          when: _restore_path != 'stack'
          tags: [always]

        - name: Put PiKVM back in RO mode
          raw: ro
          when:
            - inventory_hostname in groups["pikvm"]
            - not ansible_check_mode
          tags: [always]
