---
# Restore database dumps from backup.
# Safety-gated with confirm=yes. Supports restoring a single DB
# on a shared instance, or all DBs. Creates pre-restore safety backup by default.
# Sends notification and logs result to restores table.
#
# Usage:
#   # Dry run (omit confirm)
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres
#
#   # Restore all postgres DBs (latest backup)
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres -e confirm=yes
#
#   # Restore ONE specific DB on the shared MariaDB instance
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_mariadb -e confirm=yes -e restore_db=nextcloud
#
#   # Restore specific DB from specific date
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres -e confirm=yes -e restore_db=authentik -e restore_date=2026-02-20
#
#   # Restore InfluxDB
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_influxdb -e confirm=yes
#
#   # Skip pre-restore safety backup
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres -e confirm=yes -e skip_pre_backup=yes

- name: Resolve database target host
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - "vars/{{ hosts_variable }}.yaml"
  tasks:
    - name: Assert hosts_variable is not both a DB config and inventory group
      ansible.builtin.assert:
        that: groups[hosts_variable] | default([]) | length == 0
        fail_msg: "hosts_variable '{{ hosts_variable }}' collides with an existing inventory group"
      when: db_host is defined

    - name: Add resolved DB host to in-memory inventory
      ansible.builtin.add_host:
        name: "{{ db_host }}"
        groups: "{{ hosts_variable }}"
      when: db_host is defined
      changed_when: false

- name: Restore databases from backup
  hosts: "{{ hosts_variable }}"
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"

  pre_tasks:
    - name: Assert confirm is set
      ansible.builtin.assert:
        that: confirm | default('no') == 'yes'
        fail_msg: >-
          Restore operations require -e confirm=yes.
          Run without it first for a dry-run that shows which files would be restored.

    - name: Assert sufficient disk space on target
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_tmp_dir }}"
        assert_disk_min_gb: "{{ backup_assert_disk_min_gb | default(2) }}"

    - name: Run standard pre-flight assertions
      include_tasks: tasks/pre_task_assertions.yaml
      vars:
        pre_assert_config_file: true
        pre_playbook: "restore_databases.yaml"

  tasks:
    - name: Initialize restore state
      ansible.builtin.set_fact:
        restore_failed: false
        combined_results: []
        _restore_db_list: "{{ [restore_db] if restore_db | default('') | length > 0 else db_names }}"

    - block:
        - name: Find backup files on controller
          ansible.builtin.shell: >
            ls -t {{ backup_base_dir }}/{{ backup_stack | default(inventory_hostname) }}/backup_{{ item }}_{{ restore_date | default('*') }}.{{ backup_ext | default('sql') }} 2>/dev/null | head -1
          loop: "{{ _restore_db_list }}"
          register: _backup_files
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false

        - name: Assert backup files exist
          ansible.builtin.assert:
            that: _backup_files.results[_idx].stdout | length > 0
            fail_msg: "No backup found for database {{ item }} on controller{{ ' for date ' + restore_date if restore_date | default('') | length > 0 else '' }}"
          loop: "{{ _restore_db_list }}"
          loop_control:
            index_var: _idx

        - name: Create pre-restore safety backup
          include_tasks: tasks/pre_restore_safety_dump.yaml
          vars:
            _safety_db_list: "{{ _restore_db_list }}"
            _safety_container: "{{ db_container_name }}"
            _safety_username: "{{ db_username }}"
            _safety_password: "{{ db_password | default('') }}"
            _safety_dest_dir: "{{ backup_tmp_dir }}"
            _safety_ext: "{{ backup_ext | default('sql.gz') }}"
            _safety_is_postgres: "{{ is_postgres | default(false) }}"
            _safety_is_mariadb: "{{ is_mariadb | default(false) }}"
            _safety_is_influxdb: "{{ is_influxdb | default(false) }}"
          when:
            - not (skip_pre_backup | default(false) | bool)
            - not ansible_check_mode

        - name: Copy backup files to target host
          ansible.builtin.copy:
            src: "{{ _backup_files.results[_idx].stdout }}"
            dest: "{{ backup_tmp_dir }}/restore_{{ item }}.{{ backup_ext | default('sql') }}"
          loop: "{{ _restore_db_list }}"
          loop_control:
            index_var: _idx
          become: true
          when: not ansible_check_mode

        # NOTE: Multi-DB restores are not atomic. If restore fails mid-list,
        # earlier DBs are already restored. Pre-restore backups exist for manual recovery.

        - name: Stop dependent containers
          ansible.builtin.command:
            argv: "{{ ['docker', 'stop'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0
            - not ansible_check_mode

        - name: Restore databases
          include_tasks: tasks/db_restore.yaml
          loop: "{{ _restore_db_list }}"
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_source_file: "{{ backup_tmp_dir }}/restore_{{ item }}.{{ backup_ext | default('sql') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
            _db_tmp_dir: "{{ backup_tmp_dir }}"
          when: not ansible_check_mode

        - name: Validate restored databases
          include_tasks: tasks/db_count.yaml
          loop: "{{ _restore_db_list }}"
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
          when: not ansible_check_mode

        - name: Start dependent containers
          ansible.builtin.command:
            argv: "{{ ['docker', 'start'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0
            - not ansible_check_mode

        - name: Clean up temp files on target
          ansible.builtin.file:
            path: "{{ backup_tmp_dir }}/restore_{{ item }}.{{ backup_ext | default('sql') }}"
            state: absent
          loop: "{{ _restore_db_list }}"
          become: true

        - name: Collect restore results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': _restore_db_list[_idx],
                  'source_file': _backup_files.results[_idx].stdout | basename,
                  'table_count': _db_count_results[_restore_db_list[_idx]] | default('0'),
                  'status': 'success'
                }]
              }}
          loop: "{{ range(0, _restore_db_list | length) | list }}"
          loop_control:
            loop_var: _idx
          when: not ansible_check_mode

      rescue:
        - name: Set restore failed flag
          ansible.builtin.set_fact:
            restore_failed: true

        - name: Restart dependent containers on failure (safety net)
          ansible.builtin.command:
            argv: "{{ ['docker', 'start'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          ignore_errors: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0

      always:
        - name: Build combined notification fields for restore results
          ansible.builtin.set_fact:
            _restore_discord_fields: >-
              [
               {% for r in combined_results %}
               {% if not loop.first %},{% endif %}
               {"name": "{{ ('❌ ' if restore_failed else '✅ ') + r.db_name }}",
                "value": "{{ 'FAILED' if restore_failed else (r.table_count | string + ' ' + ('measurements' if is_influxdb | default(false) | bool else 'tables')) }}",
                "inline": true}
               {% endfor %}]
          when: combined_results | length > 0

        - name: Send combined restore notification
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: "{{ 'failed' if restore_failed else 'successful' }}"
            discord_color: "{{ discord_color_failure if restore_failed else discord_color_success }}"
            discord_url: "{{ backup_url }}"
            discord_fields: "{{ _restore_discord_fields }}"
          when: combined_results | length > 0

        - name: Send notification for unhandled block error
          include_tasks: tasks/notify.yaml
          when: restore_failed and combined_results | length == 0
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: "failed"
            discord_detail: "check Semaphore logs"
            discord_color: "{{ discord_color_failure }}"
            discord_url: "{{ backup_url }}"

        - name: Log restore results to MariaDB
          include_tasks: tasks/log_restore.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: _restore_result
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ _restore_result.db_name }}-db"
            restore_source_file: "{{ _restore_result.source_file }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if restore_failed else 'success' }}"
            restore_detail: "{{ _restore_result.table_count }} {{ 'measurements' if is_influxdb | default(false) | bool else 'tables' }} restored"

        - name: Log unhandled failure to MariaDB
          include_tasks: tasks/log_restore.yaml
          when: restore_failed and combined_results | length == 0
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ backup_name }}"
            restore_source_file: "unknown"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "failed"
            restore_detail: "Restore failed — check Semaphore logs"
