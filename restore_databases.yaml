---
# Restore database dumps from backup.
# Safety-gated with confirm_restore=yes. Supports restoring a single DB
# on a shared instance, or all DBs. Creates pre-restore safety backup by default.
# Sends Discord notification and logs result to restores table.
#
# Usage:
#   # Dry run (omit confirm_restore)
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres
#
#   # Restore all postgres DBs (latest backup)
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres -e confirm_restore=yes
#
#   # Restore ONE specific DB on the shared MariaDB instance
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_mariadb -e confirm_restore=yes -e restore_db=nextcloud
#
#   # Restore specific DB from specific date
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres -e confirm_restore=yes -e restore_db=authentik -e restore_date=2026-02-20

- name: Restore databases from backup
  hosts: "{{ hosts_variable }}"
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"
    pre_backup: "{{ pre_backup | default('yes') }}"

  pre_tasks:
    - name: Assert config_file is defined and non-empty
      include_tasks: tasks/assert_config_file.yaml

    - name: Assert confirm_restore is set
      ansible.builtin.assert:
        that: confirm_restore | default('') == 'yes'
        fail_msg: >-
          Restore operations require -e confirm_restore=yes.
          Run without it first for a dry-run that shows which files would be restored.

    - name: Assert sufficient disk space on target
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_tmp_dir }}"
        assert_disk_min_gb: 2

    - name: Assert MariaDB logging database is reachable
      include_tasks: tasks/assert_db_connectivity.yaml

  tasks:
    - name: Initialize restore state
      ansible.builtin.set_fact:
        restore_failed: false
        combined_results: []
        _restore_db_list: "{{ [restore_db] if restore_db | default('') | length > 0 else db_names }}"
      tags: [always]

    - block:
        - name: Find backup files on controller
          ansible.builtin.shell: >
            ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_{{ item }}_{{ restore_date | default('*') }}.sql 2>/dev/null | head -1
          loop: "{{ _restore_db_list }}"
          register: _backup_files
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          tags: [always]

        - name: Assert backup files exist
          ansible.builtin.assert:
            that: _backup_files.results[idx].stdout | length > 0
            fail_msg: "No backup found for database {{ item }} on controller{{ ' for date ' + restore_date if restore_date | default('') | length > 0 else '' }}"
          loop: "{{ _restore_db_list }}"
          loop_control:
            index_var: idx
          tags: [always]

        - name: Create pre-restore safety backup
          ansible.builtin.shell: |
            {% if is_postgres | default(false) | bool %}
            docker exec {{ container_name }} pg_dump {{ item }} --clean --if-exists --username={{ db_username }} | gzip > {{ backup_tmp_dir }}/pre_restore_{{ item }}_{{ ansible_date_time.date }}.sql
            {% elif is_mariadb | default(false) | bool %}
            docker exec -e MYSQL_PWD="$DB_PASSWORD" {{ container_name }} mysqldump --user {{ db_username }} {{ item }} | gzip > {{ backup_tmp_dir }}/pre_restore_{{ item }}_{{ ansible_date_time.date }}.sql
            {% endif %}
          environment:
            DB_PASSWORD: "{{ db_password }}"
          loop: "{{ _restore_db_list }}"
          become: true
          no_log: true
          when:
            - pre_backup | bool
            - not ansible_check_mode
          tags: [always]

        - name: Copy backup files to target host
          ansible.builtin.copy:
            src: "{{ _backup_files.results[idx].stdout }}"
            dest: "{{ backup_tmp_dir }}/restore_{{ item }}.sql"
          loop: "{{ _restore_db_list }}"
          loop_control:
            index_var: idx
          become: true
          when: not ansible_check_mode
          tags: [always]

        - name: Stop dependent containers
          ansible.builtin.command:
            argv: "{{ ['docker', 'stop'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0
            - not ansible_check_mode
          tags: [always]

        - name: Restore databases
          ansible.builtin.shell: |
            {% if is_postgres | default(false) | bool %}
            gunzip -cf {{ backup_tmp_dir }}/restore_{{ item }}.sql | docker exec -i {{ container_name }} psql -U {{ db_username }} {{ item }}
            {% elif is_mariadb | default(false) | bool %}
            gunzip -cf {{ backup_tmp_dir }}/restore_{{ item }}.sql | docker exec -i -e MYSQL_PWD="$DB_PASSWORD" {{ container_name }} mysql -u {{ db_username }} {{ item }}
            {% endif %}
          environment:
            DB_PASSWORD: "{{ db_password }}"
          loop: "{{ _restore_db_list }}"
          become: true
          no_log: true
          when: not ansible_check_mode
          tags: [always]

        - name: Validate restored databases (count tables)
          ansible.builtin.shell: |
            {% if is_postgres | default(false) | bool %}
            docker exec {{ container_name }} psql -U {{ db_username }} -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public';" {{ item }}
            {% elif is_mariadb | default(false) | bool %}
            docker exec -e MYSQL_PWD="$DB_PASSWORD" {{ container_name }} mysql -u {{ db_username }} -sN -e "SELECT count(*) FROM information_schema.tables WHERE table_schema = '{{ item }}';"
            {% endif %}
          environment:
            DB_PASSWORD: "{{ db_password }}"
          loop: "{{ _restore_db_list }}"
          register: _table_counts
          become: true
          changed_when: false
          no_log: true
          when: not ansible_check_mode
          tags: [always]

        - name: Start dependent containers
          ansible.builtin.command:
            argv: "{{ ['docker', 'start'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0
            - not ansible_check_mode
          tags: [always]

        - name: Clean up temp files on target
          ansible.builtin.file:
            path: "{{ backup_tmp_dir }}/restore_{{ item }}.sql"
            state: absent
          loop: "{{ _restore_db_list }}"
          become: true
          tags: [always]

        - name: Collect restore results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': _restore_db_list[idx],
                  'source_file': _backup_files.results[idx].stdout | basename,
                  'table_count': _table_counts.results[idx].stdout | default('0') | trim,
                  'status': 'success'
                }]
              }}
          loop: "{{ range(0, _restore_db_list | length) | list }}"
          loop_control:
            loop_var: idx
          when: not ansible_check_mode
          tags: [always]

      rescue:
        - name: Set restore failed flag
          ansible.builtin.set_fact:
            restore_failed: true

        - name: Restart dependent containers on failure (safety net)
          ansible.builtin.command:
            argv: "{{ ['docker', 'start'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          ignore_errors: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0
          tags: [always]

      always:
        - name: Send Discord notification for each result
          include_tasks: tasks/notify_discord.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: restore_result
          vars:
            discord_title: "{{ backup_name }}"
            discord_description: "Restore {{ 'Successful' if not restore_failed else 'Failed' }} — {{ restore_result.db_name }}"
            discord_color: "{{ 32768 if not restore_failed else 16711680 }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Description"
                value: "Database Restore"
              - name: "Host"
                value: "{{ inventory_hostname }}"
              - name: "Source File"
                value: "{{ restore_result.source_file }}"
              - name: "Tables"
                value: "{{ restore_result.table_count }}"
          tags: [always]

        - name: Send Discord notification for unhandled block error
          include_tasks: tasks/notify_discord.yaml
          when: restore_failed and combined_results | length == 0
          vars:
            discord_title: "{{ backup_name }}"
            discord_description: "Restore Failed — check Semaphore logs for details"
            discord_color: 16711680
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Description"
                value: "Database Restore"
              - name: "Host"
                value: "{{ inventory_hostname }}"
          tags: [always]

        - name: Log restore results to MariaDB
          include_tasks: tasks/log_restore.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: restore_result
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ restore_result.db_name }}-db"
            restore_source_file: "{{ restore_result.source_file }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if restore_failed else 'success' }}"
            restore_detail: "{{ restore_result.table_count }} tables restored"
          tags: [always]

        - name: Log unhandled failure to MariaDB
          include_tasks: tasks/log_restore.yaml
          when: restore_failed and combined_results | length == 0
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ backup_name }}"
            restore_source_file: "unknown"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "failed"
            restore_detail: "Restore failed — check Semaphore logs"
          tags: [always]
