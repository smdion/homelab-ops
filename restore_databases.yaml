---
# Restore database dumps from backup.
# Safety-gated with confirm=yes. Supports restoring a single DB
# on a shared instance, or all DBs. Creates pre-restore safety backup by default.
# Sends Discord notification and logs result to restores table.
#
# Usage:
#   # Dry run (omit confirm)
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres
#
#   # Restore all postgres DBs (latest backup)
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres -e confirm=yes
#
#   # Restore ONE specific DB on the shared MariaDB instance
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_mariadb -e confirm=yes -e restore_db=nextcloud
#
#   # Restore specific DB from specific date
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_postgres -e confirm=yes -e restore_db=authentik -e restore_date=2026-02-20
#
#   # Restore InfluxDB
#   ansible-playbook restore_databases.yaml -e hosts_variable=db_primary_influxdb -e confirm=yes

- name: Restore databases from backup
  hosts: "{{ hosts_variable }}"
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"
    pre_backup: "{{ pre_backup | default('yes') }}"

  pre_tasks:
    - name: Assert config_file is defined and non-empty
      include_tasks: tasks/assert_config_file.yaml

    - name: Assert confirm is set
      ansible.builtin.assert:
        that: confirm | default('no') == 'yes'
        fail_msg: >-
          Restore operations require -e confirm=yes.
          Run without it first for a dry-run that shows which files would be restored.

    - name: Assert sufficient disk space on target
      include_tasks: tasks/assert_disk_space.yaml
      vars:
        assert_disk_path: "{{ backup_tmp_dir }}"
        assert_disk_min_gb: "{{ backup_assert_disk_min_gb | default(2) }}"

    - name: Assert MariaDB logging database is reachable
      include_tasks: tasks/assert_db_connectivity.yaml

    - name: Log playbook run context to MariaDB
      include_tasks: tasks/log_run_context.yaml
      vars:
        log_playbook: "restore_databases.yaml"
        log_hostname: "{{ inventory_hostname }}"
        log_run_vars: "{}"

  tasks:
    - name: Initialize restore state
      ansible.builtin.set_fact:
        restore_failed: false
        combined_results: []
        _restore_db_list: "{{ [restore_db] if restore_db | default('') | length > 0 else db_names }}"
      tags: [always]

    - block:
        - name: Find backup files on controller
          ansible.builtin.shell: >
            ls -t {{ backup_base_dir }}/{{ backup_stack | default(inventory_hostname) }}/backup_{{ item }}_{{ restore_date | default('*') }}.{{ backup_ext | default('sql') }} 2>/dev/null | head -1
          loop: "{{ _restore_db_list }}"
          register: _backup_files
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          tags: [always]

        - name: Assert backup files exist
          ansible.builtin.assert:
            that: _backup_files.results[idx].stdout | length > 0
            fail_msg: "No backup found for database {{ item }} on controller{{ ' for date ' + restore_date if restore_date | default('') | length > 0 else '' }}"
          loop: "{{ _restore_db_list }}"
          loop_control:
            index_var: idx
          tags: [always]

        - name: Create pre-restore safety backup
          include_tasks: tasks/db_dump.yaml
          loop: "{{ _restore_db_list }}"
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_dest_file: "{{ backup_tmp_dir }}/pre_restore_{{ item }}_{{ ansible_date_time.date }}.{{ backup_ext | default('sql') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
            _db_tmp_dir: "{{ backup_tmp_dir }}"
          when:
            - pre_backup | bool
            - not ansible_check_mode
          tags: [always]

        - name: Copy backup files to target host
          ansible.builtin.copy:
            src: "{{ _backup_files.results[idx].stdout }}"
            dest: "{{ backup_tmp_dir }}/restore_{{ item }}.{{ backup_ext | default('sql') }}"
          loop: "{{ _restore_db_list }}"
          loop_control:
            index_var: idx
          become: true
          when: not ansible_check_mode
          tags: [always]

        # NOTE: Multi-DB restores are not atomic. If restore fails mid-list,
        # earlier DBs are already restored. Pre-restore backups exist for manual recovery.

        - name: Stop dependent containers
          ansible.builtin.command:
            argv: "{{ ['docker', 'stop'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0
            - not ansible_check_mode
          tags: [always]

        - name: Restore databases
          include_tasks: tasks/db_restore.yaml
          loop: "{{ _restore_db_list }}"
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_source_file: "{{ backup_tmp_dir }}/restore_{{ item }}.{{ backup_ext | default('sql') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
            _db_tmp_dir: "{{ backup_tmp_dir }}"
          when: not ansible_check_mode
          tags: [always]

        - name: Validate restored databases
          include_tasks: tasks/db_count.yaml
          loop: "{{ _restore_db_list }}"
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
          when: not ansible_check_mode
          tags: [always]

        - name: Start dependent containers
          ansible.builtin.command:
            argv: "{{ ['docker', 'start'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0
            - not ansible_check_mode
          tags: [always]

        - name: Clean up temp files on target
          ansible.builtin.file:
            path: "{{ backup_tmp_dir }}/restore_{{ item }}.{{ backup_ext | default('sql') }}"
            state: absent
          loop: "{{ _restore_db_list }}"
          become: true
          tags: [always]

        - name: Collect restore results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': _restore_db_list[idx],
                  'source_file': _backup_files.results[idx].stdout | basename,
                  'table_count': _db_count_results[_restore_db_list[idx]] | default('0'),
                  'status': 'success'
                }]
              }}
          loop: "{{ range(0, _restore_db_list | length) | list }}"
          loop_control:
            loop_var: idx
          when: not ansible_check_mode
          tags: [always]

      rescue:
        - name: Set restore failed flag
          ansible.builtin.set_fact:
            restore_failed: true

        - name: Restart dependent containers on failure (safety net)
          ansible.builtin.command:
            argv: "{{ ['docker', 'start'] + db_container_deps[item] }}"
          loop: "{{ _restore_db_list }}"
          become: true
          ignore_errors: true
          when:
            - db_container_deps is defined
            - db_container_deps[item] | default([]) | length > 0
          tags: [always]

      always:
        - name: Send Discord notification for each result
          include_tasks: tasks/notify.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: restore_result
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: "{{ 'failed' if restore_failed else 'successful' }}"
            discord_detail: "{{ restore_result.db_name }}"
            discord_color: "{{ discord_color_success if not restore_failed else discord_color_failure }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Source File"
                value: "{{ restore_result.source_file | regex_replace('^.*_(\\d{4}-\\d{2}-\\d{2}).*$', '\\1') }}"
              - name: "{{ 'Measurements' if is_influxdb | default(false) | bool else 'Tables' }}"
                value: "{{ restore_result.table_count }}"
          tags: [always]

        - name: Send Discord notification for unhandled block error
          include_tasks: tasks/notify.yaml
          when: restore_failed and combined_results | length == 0
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Restore"
            discord_status: "failed"
            discord_detail: "check Semaphore logs"
            discord_color: "{{ discord_color_failure }}"
            discord_url: "{{ backup_url }}"
          tags: [always]

        - name: Log restore results to MariaDB
          include_tasks: tasks/log_restore.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: restore_result
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ restore_result.db_name }}-db"
            restore_source_file: "{{ restore_result.source_file }}"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "{{ 'failed' if restore_failed else 'success' }}"
            restore_detail: "{{ restore_result.table_count }} {{ 'measurements' if is_influxdb | default(false) | bool else 'tables' }} restored"
          tags: [always]

        - name: Log unhandled failure to MariaDB
          include_tasks: tasks/log_restore.yaml
          when: restore_failed and combined_results | length == 0
          vars:
            log_hostname: "{{ inventory_hostname }}"
            restore_application: "{{ backup_name }}"
            restore_source_file: "unknown"
            restore_type: "{{ backup_type }}"
            restore_subtype: "{{ backup_subtype }}"
            restore_operation: "restore"
            restore_status: "failed"
            restore_detail: "Restore failed â€” check Semaphore logs"
          tags: [always]
