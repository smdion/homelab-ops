---
# Test all app restores on a disposable VM.
# Provisions VM, restores each app from production backups, verifies health, reverts.
#
# Usage:
#   # Test all apps
#   ansible-playbook test_backup_restore.yaml -e source_host=<fqdn>
#
#   # Test a subset of apps
#   ansible-playbook test_backup_restore.yaml -e source_host=<fqdn> -e test_apps=authentik,jellyseerr
#
# Required extra vars:
#   source_host  — inventory_hostname of source host whose backups to test
#
# Optional extra vars:
#   vm_name      — key in vm_definitions (default: test-vm)
#   test_apps    — comma-separated subset of app_info keys (default: all)

# ═══════════════════════════════════════════════════════════════════
# Play 1 — Validate, find backups, provision VM
# ═══════════════════════════════════════════════════════════════════
- name: Prepare app restore test
  hosts: localhost
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/docker_stacks.yaml
    - vars/vm_definitions.yaml
    - vars/semaphore_check.yaml
  vars:
    maintenance_name: "Docker"
    maintenance_type: "Servers"
    maintenance_subtype: "Test Backup Restore"

  pre_tasks:
    - name: Assert source_host is defined
      ansible.builtin.assert:
        that: source_host is defined
        fail_msg: "source_host is required — pass -e source_host=<fqdn>"

    - name: Assert vm_name exists in vm_definitions
      ansible.builtin.assert:
        that: (vm_name | default('test-vm')) in vm_definitions
        fail_msg: >-
          vm_name '{{ vm_name | default('test-vm') }}' not found in vm_definitions.
          Valid names: {{ vm_definitions.keys() | list | join(', ') }}

    - name: Assert MariaDB logging database is reachable
      include_tasks: tasks/assert_db_connectivity.yaml

  tasks:
    - name: Resolve VM and effective vm_name
      ansible.builtin.set_fact:
        _vm_name: "{{ vm_name | default('test-vm') }}"
        _vm: "{{ vm_definitions[vm_name | default('test-vm')] }}"

    - name: Resolve test apps list
      ansible.builtin.set_fact:
        _test_apps: >-
          {{ (test_apps | default('') | string).split(',') | map('trim') | select('ne', '') | list
             if test_apps | default('') | length > 0
             else app_info.keys() | list }}

    - name: Assert all test_apps exist in app_info
      ansible.builtin.assert:
        that: item in app_info
        fail_msg: "'{{ item }}' not found in app_info. Valid apps: {{ app_info.keys() | list | join(', ') }}"
      loop: "{{ _test_apps }}"

    # ===== FIND STACK ARCHIVES =====
    - name: Find latest stack archive — {{ item }}
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ source_host }}/backup_{{ app_info[item].stack }}_*.tar.gz 2>/dev/null | head -1
      loop: "{{ _test_apps }}"
      register: _stack_archive_results
      become: false
      changed_when: false
      check_mode: false

    - name: Assert stack archive found — {{ item.item }}
      ansible.builtin.assert:
        that: item.stdout | length > 0
        fail_msg: >-
          No stack archive found for app '{{ item.item }}'
          (stack '{{ app_info[item.item].stack }}') on {{ source_host }}.
          Expected: {{ backup_base_dir }}/{{ source_host }}/backup_{{ app_info[item.item].stack }}_*.tar.gz
      loop: "{{ _stack_archive_results.results }}"

    - name: Build stack archive map
      ansible.builtin.set_fact:
        _stack_archive_map: >-
          {{ dict(_test_apps | zip(_stack_archive_results.results | map(attribute='stdout') | list)) }}

    # ===== FIND DB ARCHIVES =====
    - name: Gather all test DB names
      ansible.builtin.set_fact:
        _all_test_db_names: >-
          {{ _test_apps | map('extract', app_info)
             | map(attribute='db_names', default=[]) | flatten | unique | list }}

    - name: Find latest DB backup — {{ item }}
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ source_host }}/backup_{{ item }}_*.sql.gz 2>/dev/null | head -1
      loop: "{{ _all_test_db_names }}"
      register: _db_archive_results
      become: false
      changed_when: false
      check_mode: false
      when: _all_test_db_names | length > 0

    - name: Assert DB backup found — {{ item.item }}
      ansible.builtin.assert:
        that: item.stdout | length > 0
        fail_msg: "No DB backup found for '{{ item.item }}' on {{ source_host }}"
      loop: "{{ _db_archive_results.results | default([]) }}"
      when: _all_test_db_names | length > 0

    - name: Build DB archive map
      ansible.builtin.set_fact:
        _db_archive_map: >-
          {{ dict(_all_test_db_names | zip(
               _db_archive_results.results | default([]) | map(attribute='stdout') | list)) }}

    # ===== CHECK IF VM EXISTS =====
    # Use cluster resources API (VIP-safe — discovers the actual node regardless of which PVE node is MASTER)
    - name: Check if VM exists in cluster
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/cluster/resources?type=vm"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      register: _cluster_vms
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

    - name: Set VM existence and node facts
      ansible.builtin.set_fact:
        _vm_exists: "{{ _cluster_vms.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | length > 0 }}"
        _vm_actual_node: >-
          {{ (_cluster_vms.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | first).node
             if (_cluster_vms.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | length > 0)
             else _vm.pve_target_node }}
        _vm_cluster_status: >-
          {{ (_cluster_vms.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | first).status
             if (_cluster_vms.json.data | selectattr('vmid', 'equalto', _vm.vm_id | int) | list | length > 0)
             else 'unknown' }}

    # ===== BUILD VM IF NEEDED =====
    - name: Provision VM on Proxmox
      include_tasks: tasks/provision_vm.yaml
      vars:
        _provision_target_group: test_target
      when: not _vm_exists

    - name: Add existing VM to inventory
      ansible.builtin.add_host:
        name: "{{ _vm.vm_hostname }}"
        ansible_host: "{{ _vm.vm_ip }}"
        ansible_user: "{{ vm_user }}"
        groups: test_target
        _needs_bootstrap: false
      when: _vm_exists

    - name: Start existing VM if stopped
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ _vm_actual_node }}/qemu/{{ _vm.vm_id }}/status/start"
        method: POST
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
        status_code: [200, 500]
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when:
        - _vm_exists
        - _vm_cluster_status == 'stopped'

    - name: Wait for SSH on existing VM
      ansible.builtin.wait_for:
        host: "{{ _vm.vm_ip }}"
        port: 22
        delay: 10
        timeout: 300
      when:
        - _vm_exists
        - _vm_cluster_status == 'stopped'

# ═══════════════════════════════════════════════════════════════════
# Play 2 — Bootstrap (new VM or Docker missing)
# ═══════════════════════════════════════════════════════════════════
- name: Bootstrap test VM
  hosts: test_target
  become: true
  gather_facts: true
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml

  tasks:
    - name: Check if Docker is installed
      ansible.builtin.command: docker --version
      register: _docker_check
      failed_when: false
      changed_when: false
      become: false

    - name: Bootstrap Ubuntu with Docker and security hardening
      include_tasks: tasks/bootstrap_vm.yaml
      vars:
        _vm: "{{ hostvars['localhost']._vm }}"
      when: hostvars[inventory_hostname]._needs_bootstrap | default(false) or _docker_check.rc != 0

# ═══════════════════════════════════════════════════════════════════
# Play 3 — Snapshot clean post-bootstrap state for revert
# ═══════════════════════════════════════════════════════════════════
- name: Create pre-test snapshot
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars/secrets.yaml

  tasks:
    - name: Get existing snapshots
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ hostvars['localhost']._vm_actual_node }}/qemu/{{ hostvars['localhost']._vm.vm_id }}/snapshot"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      register: _vm_snapshots

    - name: Delete existing pre-test snapshot if present
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ hostvars['localhost']._vm_actual_node }}/qemu/{{ hostvars['localhost']._vm.vm_id }}/snapshot/pre-test-restore"
        method: DELETE
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when: _vm_snapshots.json.data | selectattr('name', 'equalto', 'pre-test-restore') | list | length > 0

    - name: Wait for VM lock to clear after snapshot delete
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ hostvars['localhost']._vm_actual_node }}/qemu/{{ hostvars['localhost']._vm.vm_id }}/status/current"
        method: GET
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        validate_certs: false
      register: _vm_lock_status
      until: _vm_lock_status.json.data.lock is not defined
      retries: 20
      delay: 3
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when: _vm_snapshots.json.data | selectattr('name', 'equalto', 'pre-test-restore') | list | length > 0

    - name: Create pre-test snapshot (post-bootstrap clean state)
      ansible.builtin.uri:
        url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ hostvars['localhost']._vm_actual_node }}/qemu/{{ hostvars['localhost']._vm.vm_id }}/snapshot"
        method: POST
        headers:
          Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
        body_format: form-urlencoded
        body:
          snapname: pre-test-restore
          vmstate: 0
        validate_certs: false
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

# ═══════════════════════════════════════════════════════════════════
# Play 4 — Restore and verify each app
# ═══════════════════════════════════════════════════════════════════
- name: Test app restores on VM
  hosts: test_target
  become: true
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/docker_stacks.yaml

  tasks:
    - name: Set archive maps from controller facts
      ansible.builtin.set_fact:
        _stack_archive_map: "{{ hostvars['localhost']._stack_archive_map }}"
        _db_archive_map: "{{ hostvars['localhost']._db_archive_map | default({}) }}"

    - name: Initialize app restore results
      ansible.builtin.set_fact:
        _app_restore_results: []

    - name: Restore and verify — {{ _test_app }}
      include_tasks: tasks/restore_app_step.yaml
      loop: "{{ hostvars['localhost']._test_apps }}"
      loop_control:
        loop_var: _test_app

    # ===== OOM RECOVERY =====
    - name: Identify OOM-failed apps
      ansible.builtin.set_fact:
        _oom_apps: >-
          {{ _app_restore_results
             | selectattr('oom', 'default', false) | selectattr('oom', 'equalto', true)
             | map(attribute='app') | list }}

    - name: OOM recovery — increase VM memory and retry
      when: _oom_apps | length > 0
      block:
        - name: Save non-OOM results and OOM app list to controller
          ansible.builtin.set_fact:
            _saved_app_restore_results: >-
              {{ _app_restore_results | rejectattr('app', 'in', _oom_apps) | list }}
            _oom_apps_to_retry: "{{ _oom_apps }}"
          delegate_to: localhost

        - name: Increase VM memory ({{ (hostvars['localhost']._vm.vm_memory_mb | int * 2) }} MB)
          ansible.builtin.uri:
            url: "https://{{ hostvars['localhost'].pve_api_host }}:8006/api2/json/nodes/{{ hostvars['localhost']._vm_actual_node }}/qemu/{{ hostvars['localhost']._vm.vm_id }}/config"
            method: PUT
            headers:
              Authorization: "PVEAPIToken={{ hostvars['localhost'].pve_api_user }}!{{ hostvars['localhost'].pve_api_token_id }}={{ hostvars['localhost'].pve_api_token_secret }}"
            body_format: form-urlencoded
            body:
              memory: "{{ (hostvars['localhost']._vm.vm_memory_mb | int * 2) | int }}"
            validate_certs: false
          delegate_to: localhost
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

        - name: Reboot VM to apply increased memory
          ansible.builtin.reboot:
            reboot_timeout: 300

        - name: Restore archive maps and results after reboot
          ansible.builtin.set_fact:
            _stack_archive_map: "{{ hostvars['localhost']._stack_archive_map }}"
            _db_archive_map: "{{ hostvars['localhost']._db_archive_map | default({}) }}"
            _app_restore_results: "{{ hostvars['localhost']._saved_app_restore_results }}"

        - name: Retry restore after OOM recovery — {{ _test_app }}
          include_tasks: tasks/restore_app_step.yaml
          loop: "{{ hostvars['localhost']._oom_apps_to_retry }}"
          loop_control:
            loop_var: _test_app

# ═══════════════════════════════════════════════════════════════════
# Play 5 — Report results and revert VM
# ═══════════════════════════════════════════════════════════════════
- name: Report results and revert VM
  hosts: localhost
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - vars/semaphore_check.yaml
  vars:
    maintenance_name: "Docker"
    maintenance_type: "Servers"
    maintenance_subtype: "Test Backup Restore"

  tasks:
    - name: Collect app restore results
      ansible.builtin.set_fact:
        _all_results: >-
          {{ hostvars[hostvars['localhost']._vm.vm_hostname]._app_restore_results | default([]) }}

    - name: Set overall pass/fail and summary
      ansible.builtin.set_fact:
        _any_failed: >-
          {{ _all_results | selectattr('passed', 'equalto', false) | list | length > 0 }}
        _result_summary: >-
          {{ _all_results | map(attribute='app')
             | zip(_all_results | map(attribute='passed') | map('ternary', 'PASS', 'FAIL'))
             | list | map('join', ': ') | list | join(' | ') }}

    - name: Build per-app Discord fields
      ansible.builtin.set_fact:
        _app_discord_fields: >-
          [
           {% for r in _all_results %}
           {% if not loop.first %},{% endif %}
           {"name": "{{ ('❌ ' if not r.passed else '✅ ') + r.app }}", "value": "{{ r.detail if not r.passed else 'OK' }}", "inline": true}
           {% endfor %}]

    - name: Send Discord summary
      include_tasks: tasks/notify.yaml
      vars:
        discord_name: "{{ maintenance_name }}"
        discord_operation: "App Restore Test"
        discord_status: "{{ 'failed' if _any_failed else 'successful' }}"
        discord_detail: "{{ source_host }}"
        discord_color: "{{ discord_color_failure if _any_failed else discord_color_success }}"
        discord_url: "{{ semaphore_ext_url }}"
        discord_author: "{{ controller_fqdn }}"
        discord_fields: "{{ _app_discord_fields }}"

    - name: Log app restore test to MariaDB
      include_tasks: tasks/log_mariadb.yaml
      vars:
        log_table: maintenance
        log_application: "{{ maintenance_name }}"
        log_hostname: "{{ controller_fqdn }}"
        log_type: "{{ maintenance_type }}"
        log_subtype: "{{ maintenance_subtype }}"
        log_status: "{{ 'failed' if _any_failed else 'success' }}"

    - name: Revert VM to pre-test snapshot
      block:
        - name: Stop VM
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ hostvars['localhost']._vm_actual_node }}"
            vmid: "{{ hostvars['localhost']._vm.vm_id }}"
            state: stopped
            force: true
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
          ignore_errors: true

        - name: Revert to pre-test snapshot
          ansible.builtin.uri:
            url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ hostvars['localhost']._vm_actual_node }}/qemu/{{ hostvars['localhost']._vm.vm_id }}/snapshot/pre-test-restore/rollback"
            method: POST
            headers:
              Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
            validate_certs: false
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

        - name: Wait for rollback to complete
          ansible.builtin.pause:
            seconds: 20

        - name: Delete pre-test snapshot
          ansible.builtin.uri:
            url: "https://{{ pve_api_host }}:8006/api2/json/nodes/{{ hostvars['localhost']._vm_actual_node }}/qemu/{{ hostvars['localhost']._vm.vm_id }}/snapshot/pre-test-restore"
            method: DELETE
            headers:
              Authorization: "PVEAPIToken={{ pve_api_user }}!{{ pve_api_token_id }}={{ pve_api_token_secret }}"
            validate_certs: false
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

    - name: Fail if any app restore failed
      ansible.builtin.fail:
        msg: "App restore test failed: {{ _result_summary }}"
      when: _any_failed | bool
