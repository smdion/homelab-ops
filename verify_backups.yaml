---
# Verify that the latest backups are restorable.
# Database backups: restore to a temp DB on the same container, count tables/measurements, drop.
# Config backups: verify gzip integrity, extract to staging dir, count files.
# Sends Discord notification and logs result to restores table.
#
# Usage:
#   ansible-playbook verify_backups.yaml -e hosts_variable=db_primary_postgres
#   ansible-playbook verify_backups.yaml -e hosts_variable=db_primary_influxdb
#   ansible-playbook verify_backups.yaml -e hosts_variable=proxmox

- name: Verify latest backups are restorable
  hosts: "{{ hosts_variable }}"
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"

  pre_tasks:
    - name: Assert config_file is defined and non-empty
      include_tasks: tasks/assert_config_file.yaml

    - name: Assert MariaDB logging database is reachable
      include_tasks: tasks/assert_db_connectivity.yaml

  tasks:
    - name: Initialize verify state
      ansible.builtin.set_fact:
        verify_failed: false
        combined_results: []
        _is_db_verify: "{{ is_postgres | default(false) | bool or is_mariadb | default(false) | bool or is_influxdb | default(false) | bool }}"
      tags: [always]

    - block:
        # ===== DATABASE VERIFICATION =====
        - name: Find latest backup file per database on controller
          ansible.builtin.shell: ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_{{ item }}_*.{{ backup_ext | default('sql') }} 2>/dev/null | head -1
          loop: "{{ db_names }}"
          register: _db_backup_files
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when: _is_db_verify | bool
          tags: [always]

        - name: Assert backup files exist
          ansible.builtin.assert:
            that: _db_backup_files.results[idx].stdout | length > 0
            fail_msg: "No backup found for database {{ item }} on controller"
          loop: "{{ db_names }}"
          loop_control:
            index_var: idx
          when: _is_db_verify | bool
          tags: [always]

        - name: Copy backup files to target host
          ansible.builtin.copy:
            src: "{{ _db_backup_files.results[idx].stdout }}"
            dest: "{{ backup_tmp_dir }}/verify_{{ item }}.{{ backup_ext | default('sql') }}"
          loop: "{{ db_names }}"
          loop_control:
            index_var: idx
          become: true
          when: _is_db_verify | bool
          tags: [always]

        - name: Create temp verification databases and restore
          ansible.builtin.shell: |
            {% if is_postgres | default(false) | bool %}
            docker exec {{ container_name }} psql -U {{ db_username }} -c 'CREATE DATABASE "_restore_test_{{ item }}";' postgres
            gunzip -cf {{ backup_tmp_dir }}/verify_{{ item }}.sql | docker exec -i {{ container_name }} psql -U {{ db_username }} "_restore_test_{{ item }}"
            {% elif is_mariadb | default(false) | bool %}
            docker exec -e MYSQL_PWD="$DB_PASSWORD" {{ container_name }} mysql -u {{ db_username }} -e "CREATE DATABASE \`_restore_test_{{ item }}\`;"
            gunzip -cf {{ backup_tmp_dir }}/verify_{{ item }}.sql | docker exec -i -e MYSQL_PWD="$DB_PASSWORD" {{ container_name }} mysql -u {{ db_username }} _restore_test_{{ item }}
            {% elif is_influxdb | default(false) | bool %}
            tar xzf {{ backup_tmp_dir }}/verify_{{ item }}.tar.gz -C {{ backup_tmp_dir }}
            docker cp {{ backup_tmp_dir }}/backup_{{ item }} {{ container_name }}:/tmp/influx_verify_{{ item }}
            docker exec {{ container_name }} influxd restore -portable -database {{ item }} -newdb _restore_test_{{ item }} /tmp/influx_verify_{{ item }}
            rm -rf {{ backup_tmp_dir }}/backup_{{ item }}
            {% endif %}
          environment:
            DB_PASSWORD: "{{ db_password | default('') }}"
          loop: "{{ db_names }}"
          become: true
          no_log: "{{ not (is_influxdb | default(false) | bool) }}"
          when:
            - _is_db_verify | bool
            - not ansible_check_mode
          tags: [always]

        - name: Count tables/measurements in temp databases
          ansible.builtin.shell: |
            {% if is_postgres | default(false) | bool %}
            docker exec {{ container_name }} psql -U {{ db_username }} -t -c "SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public';" "_restore_test_{{ item }}"
            {% elif is_mariadb | default(false) | bool %}
            docker exec -e MYSQL_PWD="$DB_PASSWORD" {{ container_name }} mysql -u {{ db_username }} -sN -e "SELECT count(*) FROM information_schema.tables WHERE table_schema = '_restore_test_{{ item }}';"
            {% elif is_influxdb | default(false) | bool %}
            docker exec {{ container_name }} influx -database _restore_test_{{ item }} -execute "SHOW MEASUREMENTS" -format csv | tail -n +2 | wc -l
            {% endif %}
          environment:
            DB_PASSWORD: "{{ db_password | default('') }}"
          loop: "{{ db_names }}"
          register: _table_counts
          become: true
          changed_when: false
          no_log: "{{ not (is_influxdb | default(false) | bool) }}"
          when:
            - _is_db_verify | bool
            - not ansible_check_mode
          tags: [always]

        - name: Drop temp verification databases
          ansible.builtin.shell: |
            {% if is_postgres | default(false) | bool %}
            docker exec {{ container_name }} psql -U {{ db_username }} -c 'DROP DATABASE IF EXISTS "_restore_test_{{ item }}";' postgres
            {% elif is_mariadb | default(false) | bool %}
            docker exec -e MYSQL_PWD="$DB_PASSWORD" {{ container_name }} mysql -u {{ db_username }} -e "DROP DATABASE IF EXISTS \`_restore_test_{{ item }}\`;"
            {% elif is_influxdb | default(false) | bool %}
            docker exec {{ container_name }} influx -execute "DROP DATABASE \"_restore_test_{{ item }}\""
            docker exec {{ container_name }} rm -rf /tmp/influx_verify_{{ item }}
            {% endif %}
          environment:
            DB_PASSWORD: "{{ db_password | default('') }}"
          loop: "{{ db_names }}"
          become: true
          no_log: "{{ not (is_influxdb | default(false) | bool) }}"
          when:
            - _is_db_verify | bool
            - not ansible_check_mode
          tags: [always]

        - name: Clean up temp backup files on target
          ansible.builtin.file:
            path: "{{ backup_tmp_dir }}/verify_{{ item }}.{{ backup_ext | default('sql') }}"
            state: absent
          loop: "{{ db_names }}"
          become: true
          when: _is_db_verify | bool
          tags: [always]

        - name: Collect database verification results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': db_names[idx],
                  'source_file': _db_backup_files.results[idx].stdout | basename,
                  'table_count': _table_counts.results[idx].stdout | default('0') | trim,
                  'status': 'success'
                }]
              }}
          loop: "{{ range(0, db_names | length) | list }}"
          loop_control:
            loop_var: idx
          when:
            - _is_db_verify | bool
            - not ansible_check_mode
          tags: [always]

        # ===== CONFIG BACKUP VERIFICATION =====
        - name: Find latest config backup on controller
          ansible.builtin.shell: ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_*.tar.gz 2>/dev/null | head -1
          register: _config_backup_file
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when: src_raw_files is defined and not (_is_db_verify | bool)
          tags: [always]

        - name: Assert config backup file exists
          ansible.builtin.assert:
            that: _config_backup_file.stdout | length > 0
            fail_msg: "No config backup found for {{ inventory_hostname }} on controller"
          when: src_raw_files is defined and not (_is_db_verify | bool)
          tags: [always]

        - name: Verify config backup integrity
          ansible.builtin.shell: gunzip -t "{{ _config_backup_file.stdout }}"
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when: src_raw_files is defined and not (_is_db_verify | bool)
          tags: [always]

        - name: Create staging directory on controller
          ansible.builtin.file:
            state: directory
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}"
          delegate_to: localhost
          become: false
          when:
            - src_raw_files is defined and not (_is_db_verify | bool)
            - not ansible_check_mode
          tags: [always]

        - name: Extract backup to staging directory
          ansible.builtin.shell: tar xzf "{{ _config_backup_file.stdout }}" -C "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}"
          register: _tar_extract
          delegate_to: localhost
          become: false
          failed_when: _tar_extract.rc != 0 and 'Cannot hard link' not in _tar_extract.stderr
          when:
            - src_raw_files is defined and not (_is_db_verify | bool)
            - not ansible_check_mode
          tags: [always]

        - name: Count extracted files
          ansible.builtin.shell: find "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}" -type f | wc -l
          register: _extracted_count
          delegate_to: localhost
          become: false
          changed_when: false
          when:
            - src_raw_files is defined and not (_is_db_verify | bool)
            - not ansible_check_mode
          tags: [always]

        - name: Clean up staging directory
          ansible.builtin.file:
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}"
            state: absent
          delegate_to: localhost
          become: false
          when: src_raw_files is defined and not (_is_db_verify | bool)
          tags: [always]

        - name: Collect config verification results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': backup_name,
                  'source_file': _config_backup_file.stdout | basename,
                  'table_count': _extracted_count.stdout | default('0') | trim,
                  'status': 'success'
                }]
              }}
          when:
            - src_raw_files is defined and not (_is_db_verify | bool)
            - not ansible_check_mode
          tags: [always]

      rescue:
        - name: Set verify failed flag
          ansible.builtin.set_fact:
            verify_failed: true

        - name: Drop any leftover temp databases (cleanup on failure)
          ansible.builtin.shell: |
            {% if is_postgres | default(false) | bool %}
            docker exec {{ container_name }} psql -U {{ db_username }} -c 'DROP DATABASE IF EXISTS "_restore_test_{{ item }}";' postgres
            {% elif is_mariadb | default(false) | bool %}
            docker exec -e MYSQL_PWD="$DB_PASSWORD" {{ container_name }} mysql -u {{ db_username }} -e "DROP DATABASE IF EXISTS \`_restore_test_{{ item }}\`;"
            {% elif is_influxdb | default(false) | bool %}
            docker exec {{ container_name }} influx -execute "DROP DATABASE \"_restore_test_{{ item }}\"" || true
            docker exec {{ container_name }} rm -rf /tmp/influx_verify_{{ item }} || true
            {% endif %}
          environment:
            DB_PASSWORD: "{{ db_password | default('') }}"
          loop: "{{ db_names | default([]) }}"
          become: true
          ignore_errors: true
          no_log: "{{ not (is_influxdb | default(false) | bool) }}"
          when: _is_db_verify | bool
          tags: [always]

        - name: Clean up staging directory on failure
          ansible.builtin.file:
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}"
            state: absent
          delegate_to: localhost
          become: false
          ignore_errors: true
          when: src_raw_files is defined and not (_is_db_verify | bool)
          tags: [always]

      always:
        - name: Send Discord notification for each result
          include_tasks: tasks/notify_discord.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: verify_result
          vars:
            discord_title: "{{ backup_name }}"
            discord_description: "Verification {{ 'Successful' if not verify_failed else 'Failed' }} — {{ verify_result.db_name }}"
            discord_color: "{{ discord_color_success if not verify_failed else discord_color_failure }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Description"
                value: "Backup Verification"
              - name: "Host"
                value: "{{ inventory_hostname }}"
              - name: "Source File"
                value: "{{ verify_result.source_file }}"
              - name: "Detail"
                value: "{{ verify_result.table_count }} {{ 'measurements' if is_influxdb | default(false) | bool else 'tables' if is_postgres | default(false) | bool or is_mariadb | default(false) | bool else 'files' }} verified"
          tags: [always]

        - name: Send Discord notification for unhandled block error
          include_tasks: tasks/notify_discord.yaml
          when: verify_failed and combined_results | length == 0
          vars:
            discord_title: "{{ backup_name }}"
            discord_description: "Verification Failed — check Semaphore logs for details"
            discord_color: "{{ discord_color_failure }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Description"
                value: "Backup Verification"
              - name: "Host"
                value: "{{ inventory_hostname }}"
          tags: [always]

        - name: Log verification results to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: verify_result
          vars:
            log_table: maintenance
            log_application: "{{ verify_result.db_name }}{{ '-db' if _is_db_verify | bool else '' }}"
            log_hostname: "{{ inventory_hostname }}"
            log_type: "{{ backup_type }}"
            log_subtype: "Verify"
            log_status: "{{ 'failed' if verify_failed else 'success' }}"
          tags: [always]

        - name: Log unhandled failure to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          when: verify_failed and combined_results | length == 0
          vars:
            log_table: maintenance
            log_application: "{{ backup_name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_type: "{{ backup_type }}"
            log_subtype: "Verify"
            log_status: "failed"
          tags: [always]
