---
# Verify that the latest backups are restorable.
# Database backups: restore to a temp DB on the same container, count tables/measurements, drop.
# Config backups (per-stack): verify each stack's archive, extract to staging, count files.
# Config backups (monolithic): verify gzip integrity, extract to staging dir, count files.
# Sends Discord notification and logs result to restores table.
#
# Scope selectors (docker_stacks only):
#   stack=<name>  — verify a single stack's archive
#   role=<name>   — verify all stacks in a role
#
# Usage:
#   ansible-playbook verify_backups.yaml -e hosts_variable=db_primary_postgres
#   ansible-playbook verify_backups.yaml -e hosts_variable=db_primary_influxdb
#   ansible-playbook verify_backups.yaml -e hosts_variable=proxmox
#   ansible-playbook verify_backups.yaml -e hosts_variable=docker_stacks
#   ansible-playbook verify_backups.yaml -e hosts_variable=docker_stacks -e stack=auth
#   ansible-playbook verify_backups.yaml -e hosts_variable=docker_stacks -e role=core

- name: Verify latest backups are restorable
  hosts: "{{ hosts_variable }}"
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/host_definitions.yaml
    - vars/{{ config_file }}.yaml
  vars:
    config_file: "{{ hosts_variable }}"

  pre_tasks:
    - name: Resolve scope (role injection + stack/role filtering)
      include_tasks: tasks/resolve_scope.yaml

    - name: Run standard pre-flight assertions
      include_tasks: tasks/pre_task_assertions.yaml
      vars:
        pre_assert_config_file: true
        pre_playbook: "verify_backups.yaml"

  tasks:
    - name: Initialize verify state
      ansible.builtin.set_fact:
        verify_failed: false
        combined_results: []
        _is_db_verify: "{{ is_postgres | default(false) | bool or is_mariadb | default(false) | bool or is_influxdb | default(false) | bool }}"
        _target_stacks: >-
          {{ [stack] if stack is defined
             else stack_assignments[inventory_hostname] | default([]) }}

    - block:
        # ===== DATABASE VERIFICATION =====
        - name: Find latest backup file per database on controller
          ansible.builtin.shell: ls -t {{ backup_base_dir }}/{{ backup_stack | default(inventory_hostname) }}/backup_{{ item }}_*.{{ backup_ext | default('sql') }} 2>/dev/null | head -1
          loop: "{{ db_names }}"
          register: _db_backup_files
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when: _is_db_verify | bool

        - name: Assert backup files exist
          ansible.builtin.assert:
            that: _db_backup_files.results[idx].stdout | length > 0
            fail_msg: "No backup found for database {{ item }} on controller"
          loop: "{{ db_names }}"
          loop_control:
            index_var: idx
          when: _is_db_verify | bool

        - name: Copy backup files to target host
          ansible.builtin.copy:
            src: "{{ _db_backup_files.results[idx].stdout }}"
            dest: "{{ backup_tmp_dir }}/verify_{{ item }}.{{ backup_ext | default('sql') }}"
          loop: "{{ db_names }}"
          loop_control:
            index_var: idx
          become: true
          when: _is_db_verify | bool

        - name: Create temp verification databases and restore
          include_tasks: tasks/db_restore.yaml
          loop: "{{ db_names }}"
          vars:
            _db_name: "{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_source_file: "{{ backup_tmp_dir }}/verify_{{ item }}.{{ backup_ext | default('sql') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
            _db_tmp_dir: "{{ backup_tmp_dir }}"
            _db_target_name: "_restore_test_{{ item }}"
          when:
            - _is_db_verify | bool
            - not ansible_check_mode

        - name: Count tables/measurements in temp databases
          include_tasks: tasks/db_count.yaml
          loop: "{{ db_names }}"
          vars:
            _db_name: "_restore_test_{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
          when:
            - _is_db_verify | bool
            - not ansible_check_mode

        - name: Drop temp verification databases
          include_tasks: tasks/db_drop_temp.yaml
          loop: "{{ db_names }}"
          vars:
            _db_name: "_restore_test_{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
          when:
            - _is_db_verify | bool
            - not ansible_check_mode

        - name: Clean up temp backup files on target
          ansible.builtin.file:
            path: "{{ backup_tmp_dir }}/verify_{{ item }}.{{ backup_ext | default('sql') }}"
            state: absent
          loop: "{{ db_names }}"
          become: true
          when: _is_db_verify | bool

        - name: Collect database verification results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': db_names[idx],
                  'source_file': _db_backup_files.results[idx].stdout | basename,
                  'table_count': _db_count_results['_restore_test_' + db_names[idx]] | default('0'),
                  'status': 'success'
                }]
              }}
          loop: "{{ range(0, db_names | length) | list }}"
          loop_control:
            loop_var: idx
          when:
            - _is_db_verify | bool
            - not ansible_check_mode

        # ===== PER-STACK CONFIG VERIFICATION (docker_stacks hosts) =====
        - name: Find per-stack backup archives on controller
          ansible.builtin.shell: ls -t {{ backup_base_dir }}/{{ item }}/backup_{{ item }}_*.tar.gz 2>/dev/null | head -1
          loop: "{{ _target_stacks }}"
          register: _stack_backup_files
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)

        - name: Build valid stack archive list
          ansible.builtin.set_fact:
            _valid_stack_archives: "{{ _stack_backup_files.results | default([]) | selectattr('stdout', 'ne', '') | list }}"
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)

        - name: Assert at least one per-stack archive exists
          ansible.builtin.assert:
            that: _valid_stack_archives | length > 0
            fail_msg: "No per-stack backup archives found for {{ inventory_hostname }} on controller"
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)

        - name: Verify per-stack archive integrity
          ansible.builtin.shell: gunzip -t "{{ item.stdout }}"
          loop: "{{ _valid_stack_archives }}"
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)

        - name: Create per-stack staging directories
          ansible.builtin.file:
            state: directory
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_{{ item.item }}"
          loop: "{{ _valid_stack_archives }}"
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)
            - not ansible_check_mode

        - name: Extract per-stack archives to staging
          ansible.builtin.shell: tar xzf "{{ item.stdout }}" -C "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_{{ item.item }}"
          loop: "{{ _valid_stack_archives }}"
          register: _stack_tar_extract
          delegate_to: localhost
          become: false
          failed_when: item.rc is defined and item.rc != 0 and 'Cannot hard link' not in (item.stderr | default(''))
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)
            - not ansible_check_mode

        - name: Count per-stack extracted files
          ansible.builtin.shell: find "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_{{ item.item }}" -type f | wc -l
          loop: "{{ _valid_stack_archives }}"
          register: _stack_extracted_counts
          delegate_to: localhost
          become: false
          changed_when: false
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)
            - not ansible_check_mode

        - name: Clean up per-stack staging directories
          ansible.builtin.file:
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_{{ item.item }}"
            state: absent
          loop: "{{ _valid_stack_archives }}"
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)

        - name: Collect per-stack verification results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': _valid_stack_archives[idx].item,
                  'source_file': _valid_stack_archives[idx].stdout | basename,
                  'table_count': _stack_extracted_counts.results[idx].stdout | default('0') | trim,
                  'status': 'success'
                }]
              }}
          loop: "{{ range(0, _valid_stack_archives | default([]) | length) | list }}"
          loop_control:
            loop_var: idx
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)
            - not ansible_check_mode

        # ===== AMP PER-INSTANCE CONFIG VERIFICATION (amp hosts) =====
        - name: Discover AMP instances for verification
          become: true
          ansible.builtin.find:
            paths: "{{ amp_home }}/.ampdata/instances"
            file_type: directory
            recurse: false
          register: _amp_verify_instances_found
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)

        - name: Set AMP instance list for verification
          ansible.builtin.set_fact:
            _amp_verify_instances: >-
              {{ [amp_instance_filter] if amp_instance_filter is defined
                 else (_amp_verify_instances_found.files
                       | map(attribute='path') | map('basename') | sort | list) }}
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)

        - name: Find latest AMP instance archive on controller
          ansible.builtin.shell: >
            ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_amp_{{ item }}_*.tar.gz
            2>/dev/null | head -1
          loop: "{{ _amp_verify_instances | default([]) }}"
          register: _amp_archive_files
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)

        - name: Build valid AMP archive list
          ansible.builtin.set_fact:
            _valid_amp_archives: >-
              {{ _amp_archive_files.results | default([]) | selectattr('stdout', 'ne', '') | list }}
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)

        - name: Assert at least one AMP instance archive exists
          ansible.builtin.assert:
            that: _valid_amp_archives | length > 0
            fail_msg: "No AMP instance backup archives found for {{ inventory_hostname }} on controller"
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)

        - name: Verify AMP instance archive integrity
          ansible.builtin.shell: gunzip -t "{{ item.stdout }}"
          loop: "{{ _valid_amp_archives }}"
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)

        - name: Create per-instance AMP staging directories
          ansible.builtin.file:
            state: directory
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_{{ item.item }}"
          loop: "{{ _valid_amp_archives }}"
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)
            - not ansible_check_mode

        - name: Extract AMP instance archives to staging
          ansible.builtin.shell: >
            tar xzf "{{ item.stdout }}"
            -C "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_{{ item.item }}"
          loop: "{{ _valid_amp_archives }}"
          register: _amp_tar_extract
          delegate_to: localhost
          become: false
          failed_when: >-
            item.rc is defined and item.rc != 0
            and 'Cannot hard link' not in (item.stderr | default(''))
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)
            - not ansible_check_mode

        - name: Count per-instance AMP extracted files
          ansible.builtin.shell: >
            find "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_{{ item.item }}"
            -type f | wc -l
          loop: "{{ _valid_amp_archives }}"
          register: _amp_extracted_counts
          delegate_to: localhost
          become: false
          changed_when: false
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)
            - not ansible_check_mode

        - name: Clean up per-instance AMP staging directories
          ansible.builtin.file:
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_{{ item.item }}"
            state: absent
          loop: "{{ _valid_amp_archives }}"
          delegate_to: localhost
          become: false
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)

        - name: Collect AMP instance verification results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': _valid_amp_archives[idx].item,
                  'source_file': _valid_amp_archives[idx].stdout | basename,
                  'table_count': _amp_extracted_counts.results[idx].stdout | default('0') | trim,
                  'status': 'success'
                }]
              }}
          loop: "{{ range(0, _valid_amp_archives | default([]) | length) | list }}"
          loop_control:
            loop_var: idx
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)
            - not ansible_check_mode

        # ===== MONOLITHIC CONFIG VERIFICATION (non-docker_stacks hosts) =====
        - name: Find latest config backup on controller
          ansible.builtin.shell: ls -t {{ backup_base_dir }}/{{ inventory_hostname }}/backup_*.tar.gz 2>/dev/null | head -1
          register: _config_backup_file
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])

        - name: Assert config backup file exists
          ansible.builtin.assert:
            that: _config_backup_file.stdout | length > 0
            fail_msg: "No config backup found for {{ inventory_hostname }} on controller"
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])

        - name: Verify config backup integrity
          ansible.builtin.shell: gunzip -t "{{ _config_backup_file.stdout }}"
          delegate_to: localhost
          become: false
          changed_when: false
          check_mode: false
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])

        - name: Create staging directory on controller
          ansible.builtin.file:
            state: directory
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}"
          delegate_to: localhost
          become: false
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - not ansible_check_mode

        - name: Extract backup to staging directory
          ansible.builtin.shell: tar xzf "{{ _config_backup_file.stdout }}" -C "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}"
          register: _tar_extract
          delegate_to: localhost
          become: false
          failed_when: _tar_extract.rc != 0 and 'Cannot hard link' not in _tar_extract.stderr
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - not ansible_check_mode

        - name: Count extracted files
          ansible.builtin.shell: find "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}" -type f | wc -l
          register: _extracted_count
          delegate_to: localhost
          become: false
          changed_when: false
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - not ansible_check_mode

        - name: Clean up staging directory
          ansible.builtin.file:
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}"
            state: absent
          delegate_to: localhost
          become: false
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])

        - name: Collect config verification results
          ansible.builtin.set_fact:
            combined_results: >-
              {{
                combined_results + [{
                  'db_name': backup_name,
                  'source_file': _config_backup_file.stdout | basename,
                  'table_count': _extracted_count.stdout | default('0') | trim,
                  'status': 'success'
                }]
              }}
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])
            - not ansible_check_mode

      rescue:
        - name: Set verify failed flag
          ansible.builtin.set_fact:
            verify_failed: true

        - name: Drop any leftover temp databases (cleanup on failure)
          include_tasks: tasks/db_drop_temp.yaml
          loop: "{{ db_names | default([]) }}"
          vars:
            _db_name: "_restore_test_{{ item }}"
            _db_container: "{{ db_container_name }}"
            _db_username: "{{ db_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_is_postgres: "{{ is_postgres | default(false) }}"
            _db_is_mariadb: "{{ is_mariadb | default(false) }}"
            _db_is_influxdb: "{{ is_influxdb | default(false) }}"
            _db_influx_source_name: "{{ item }}"
          ignore_errors: true
          when: _is_db_verify | bool

        - name: Clean up per-stack staging directories on failure
          ansible.builtin.shell: rm -rf "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_"*
          delegate_to: localhost
          become: false
          ignore_errors: true
          when:
            - inventory_hostname in groups["docker_stacks"] | default([])
            - not (_is_db_verify | bool)

        - name: Clean up per-instance AMP staging directories on failure
          ansible.builtin.shell: rm -rf "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}_"*
          delegate_to: localhost
          become: false
          ignore_errors: true
          when:
            - inventory_hostname in groups["amp"] | default([])
            - not (_is_db_verify | bool)

        - name: Clean up staging directory on failure
          ansible.builtin.file:
            path: "{{ backup_base_dir }}/tmp/verify_staging_{{ inventory_hostname }}"
            state: absent
          delegate_to: localhost
          become: false
          ignore_errors: true
          when:
            - src_raw_files is defined
            - not (_is_db_verify | bool)
            - inventory_hostname not in groups["docker_stacks"] | default([])

      always:
        - name: Send Discord notification for each result
          include_tasks: tasks/notify.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: verify_result
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Verification"
            discord_status: "{{ 'failed' if verify_failed else 'successful' }}"
            discord_detail: "{{ verify_result.db_name }}"
            discord_color: "{{ discord_color_success if not verify_failed else discord_color_failure }}"
            discord_url: "{{ backup_url }}"
            discord_fields:
              - name: "Source File"
                value: "{{ verify_result.source_file | regex_replace('^.*_(\\d{4}-\\d{2}-\\d{2}).*$', '\\1') }}"
              - name: "Detail"
                value: "{{ verify_result.table_count }} {{ 'measurements' if is_influxdb | default(false) | bool else 'tables' if is_postgres | default(false) | bool or is_mariadb | default(false) | bool else 'files' }} verified"

        - name: Send Discord notification for unhandled block error
          include_tasks: tasks/notify.yaml
          when: verify_failed and combined_results | length == 0
          vars:
            discord_name: "{{ backup_name }}"
            discord_operation: "Verification"
            discord_status: "failed"
            discord_detail: "check Semaphore logs"
            discord_color: "{{ discord_color_failure }}"
            discord_url: "{{ backup_url }}"

        - name: Log verification results to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          loop: "{{ combined_results }}"
          loop_control:
            loop_var: verify_result
          vars:
            log_table: maintenance
            log_application: "{{ verify_result.db_name }}{{ '-db' if _is_db_verify | bool else '' }}"
            log_hostname: "{{ inventory_hostname }}"
            log_type: "{{ backup_type }}"
            log_subtype: "Verify"
            log_status: "{{ 'failed' if verify_failed else 'success' }}"

        - name: Log unhandled failure to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          when: verify_failed and combined_results | length == 0
          vars:
            log_table: maintenance
            log_application: "{{ backup_name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_type: "{{ backup_type }}"
            log_subtype: "Verify"
            log_status: "failed"
