---
# DR rebuild — build a VM and restore stack backups in one command.
# Chains: provision VM → bootstrap → restore appdata + DBs → deploy stacks → health check.
# Used for production migration (one-time) and ongoing DR recovery.
#
# Play 1 (localhost): Validate inputs, discover backup archives, provision/resolve VM.
# Play 2 (new VM):    Bootstrap (Docker, keepalived, security hardening).
# Play 3 (new VM):    Restore appdata + DBs, deploy stacks, health check.
#
# Usage:
#   # Production DR rebuild (vm_name derived from role)
#   ansible-playbook dr_rebuild.yaml -e role=core -e deploy_ssh_key=yes -e debug_no_log=yes
#   ansible-playbook dr_rebuild.yaml -e role=apps -e deploy_ssh_key=yes -e debug_no_log=yes
#   ansible-playbook dr_rebuild.yaml -e role=dev  -e deploy_ssh_key=yes -e debug_no_log=yes
#
#   # Test on CephFS-backed VM (override vm_name for test-pool)
#   ansible-playbook dr_rebuild.yaml -e role=core -e vm_name=cephfs-migrate-test -e deploy_ssh_key=yes
#
# Required extra vars:
#   role         — stack role name (core, apps, dev)
#
# Optional extra vars:
#   vm_name      — VM key from vm_definitions (default: same as role). Override for test VMs.
#   deploy_ssh_key=yes — install ansible SSH private key on VM
#   skip_dbs     — comma-separated DB names to skip restoring (e.g. -e skip_dbs=nextcloud)
#   restore_app  — single app name to selectively extract from archive
#   vm_index=N   — test-vm slot 0..9; auto-detected if omitted (only for test-pool VMs)
#   debug_no_log=yes — show template output in logs

# ═══════════════════════════════════════════════════════════════════
# Play 1 — Prepare: Validate, discover backups, provision/resolve VM
# ═══════════════════════════════════════════════════════════════════
- name: Build VM and prepare restore
  hosts: localhost
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/proxmox.yaml
    - vars/docker_stacks.yaml
    - vars/vm_definitions.yaml
    - vars/docker_vips.yaml
    - vars/semaphore_check.yaml
  vars:
    maintenance_name: "Docker"
    maintenance_type: "Servers"
    maintenance_subtype: "DR Rebuild"

  pre_tasks:
    - name: Assert role is defined
      ansible.builtin.assert:
        that: role is defined
        fail_msg: >-
          role is required. Pass -e role=core|apps|dev.

    - name: Default vm_name to role
      ansible.builtin.set_fact:
        vm_name: "{{ vm_name | default(role) }}"

    - name: Assert vm_name exists in vm_definitions
      ansible.builtin.assert:
        that: vm_name in vm_definitions
        fail_msg: >-
          vm_name '{{ vm_name }}' not found in vm_definitions.
          Valid names: {{ vm_definitions.keys() | list | join(', ') }}

    - name: Auto-detect free vm_index for test-vm pool
      include_tasks: tasks/resolve_test_vm_index.yaml
      when: vm_name in ['test-vm', 'cephfs-migrate-test']

    - name: Run standard pre-flight assertions
      include_tasks: tasks/pre_task_assertions.yaml
      vars:
        pre_playbook: "dr_rebuild.yaml"
        pre_hostname: "{{ controller_fqdn }}"
        pre_run_vars: "{{ {'role': role | default(''), 'vm_name': vm_name | default('')} | to_json }}"

  tasks:
    - name: Initialize build state
      ansible.builtin.set_fact:
        build_failed: false
        _build_detail: ""

    - name: Resolve VM and stack configuration
      ansible.builtin.set_fact:
        _vm: "{{ vm_definitions[vm_name] }}"
        _stacks: "{{ stack_roles[role] }}"

    # ===== AUTO-CREATE CEPHFS DIR (CephFS test VMs only) =====
    - name: Add PVE host to in-memory inventory (for CephFS dir creation)
      ansible.builtin.add_host:
        name: pve_builder
        ansible_host: "{{ pve_api_host }}"
        ansible_user: ansible
      when: _vm.cephfs_host_dir is defined

    - name: Ensure test VM CephFS directory exists (isolated from production)
      ansible.builtin.shell: |
        set -e
        MOUNT_DIR=$(mktemp -d)
        ADMIN_KEY=$(ceph auth print-key client.admin)
        mount -t ceph {{ vault_ceph_mons }}:/ "$MOUNT_DIR" \
          -o "name=admin,secret=${ADMIN_KEY}"
        if [ -d "$MOUNT_DIR/{{ _vm.cephfs_host_dir }}" ]; then
          echo "exists"
        else
          mkdir "$MOUNT_DIR/{{ _vm.cephfs_host_dir }}"
          echo "created"
        fi
        umount "$MOUNT_DIR"
        rmdir "$MOUNT_DIR"
      args:
        executable: /bin/bash
      delegate_to: pve_builder
      become: true
      register: _cephfs_dir_result
      changed_when: "'created' in _cephfs_dir_result.stdout"
      no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"
      when: _vm.cephfs_host_dir is defined

    # ===== FIND BACKUP ARCHIVES =====
    - name: Find per-stack backup archives from production backups (read-only)
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/{{ item }}/backup_{{ item }}_*.tar.gz 2>/dev/null | head -1
      loop: "{{ _stacks }}"
      register: _per_stack_archives
      become: false
      changed_when: false
      check_mode: false

    - name: Set per-stack archive list
      ansible.builtin.set_fact:
        _archive_files: "{{ _per_stack_archives.results | selectattr('stdout', 'ne', '') | map(attribute='stdout') | list }}"

    - name: Assert backup archives exist
      ansible.builtin.assert:
        that: _archive_files | length > 0
        fail_msg: "No per-stack backup archives found in {{ backup_base_dir }}/ for stacks: {{ _stacks | join(', ') }}"

    # ===== FIND DB SQL DUMP ARCHIVES =====
    - name: Load postgres DB config
      ansible.builtin.include_vars:
        file: vars/db_primary_postgres.yaml
      when: "'databases' in _stacks"

    - name: Save postgres DB config
      ansible.builtin.set_fact:
        _db_postgres_all_names: "{{ db_names }}"
        _db_postgres_container: "{{ db_container_name }}"
        _db_postgres_username: "{{ db_username }}"
      when: "'databases' in _stacks"

    - name: Load mariadb DB config
      ansible.builtin.include_vars:
        file: vars/db_primary_mariadb.yaml
      when: "'databases' in _stacks"

    - name: Save mariadb DB config
      ansible.builtin.set_fact:
        _db_mariadb_all_names: "{{ db_names }}"
        _db_mariadb_container: "{{ db_container_name }}"
        _db_mariadb_username: "{{ db_username }}"
      when: "'databases' in _stacks"

    - name: Filter skipped DBs from restore lists
      ansible.builtin.set_fact:
        _db_postgres_all_names: "{{ _db_postgres_all_names | difference(skip_dbs.split(',')) }}"
        _db_mariadb_all_names: "{{ _db_mariadb_all_names | difference(skip_dbs.split(',')) }}"
      when:
        - skip_dbs | default('') | length > 0
        - "'databases' in _stacks"

    - name: Default DB facts when databases stack absent
      ansible.builtin.set_fact:
        _db_postgres_all_names: []
        _db_mariadb_all_names: []
        _db_postgres_container: ""
        _db_mariadb_container: ""
        _db_postgres_username: ""
        _db_mariadb_username: ""
      when: "'databases' not in _stacks"

    - name: Find latest SQL dump per database — {{ item }}
      ansible.builtin.shell: >
        ls -t {{ backup_base_dir }}/databases/backup_{{ item }}_*.sql {{ backup_base_dir }}/databases/backup_{{ item }}_*.sql.gz 2>/dev/null | head -1
      loop: "{{ _db_postgres_all_names + _db_mariadb_all_names }}"
      register: _db_dump_results
      become: false
      changed_when: false
      check_mode: false
      when: (_db_postgres_all_names + _db_mariadb_all_names) | length > 0

    - name: Build DB archive map and name lists
      ansible.builtin.set_fact:
        _db_archive_map: >-
          {{ dict(_db_dump_results.results | default([])
                  | selectattr('stdout', 'defined')
                  | selectattr('stdout', 'ne', '')
                  | map(attribute='item') | list
                  | zip(_db_dump_results.results | default([])
                        | selectattr('stdout', 'defined')
                        | selectattr('stdout', 'ne', '')
                        | map(attribute='stdout') | list)) }}
        _db_postgres_names: >-
          {{ _db_dump_results.results | default([])
             | selectattr('stdout', 'defined')
             | selectattr('stdout', 'ne', '')
             | map(attribute='item') | list
             | intersect(_db_postgres_all_names) }}
        _db_mariadb_names: >-
          {{ _db_dump_results.results | default([])
             | selectattr('stdout', 'defined')
             | selectattr('stdout', 'ne', '')
             | map(attribute='item') | list
             | intersect(_db_mariadb_all_names) }}

    - name: Report DB backup discovery
      ansible.builtin.debug:
        msg: >-
          DB dumps found: {{ _db_archive_map | length }}/{{ (_db_postgres_all_names + _db_mariadb_all_names) | length }}.
          Postgres: {{ _db_postgres_names | join(', ') or 'none' }}.
          MariaDB: {{ _db_mariadb_names | join(', ') or 'none' }}.
          {{ _db_archive_map | to_nice_yaml if _db_archive_map | length > 0 else '' }}

    - name: Verify archive integrity
      ansible.builtin.shell: gunzip -t "{{ item }}"
      loop: "{{ _archive_files }}"
      become: false
      changed_when: false
      check_mode: false

    # ===== RESOLVE OR PROVISION VM =====
    - block:
        - name: Resolve or provision VM
          include_tasks: tasks/resolve_or_provision_vm.yaml
          vars:
            _provision_target_group: dr_target

        - name: Record build detail
          ansible.builtin.set_fact:
            _build_detail: >-
              VM {{ 'reused' if _vm_exists else 'provisioned' }}:
              {{ _vm.vm_name }} ({{ _vm.vm_ip }}) on {{ _vm_actual_node | default(_vm.pve_target_node) }}

      rescue:
        - name: Set build failed flag
          ansible.builtin.set_fact:
            build_failed: true
            _build_detail: "{{ ansible_failed_result.msg | default('check Semaphore logs') }}"

      always:
        - name: Send Discord notification (failure only; success deferred to Play 2)
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ maintenance_name }}"
            discord_operation: "DR Rebuild"
            discord_status: "failed"
            discord_color: "{{ discord_color_failure }}"
            discord_url: "{{ semaphore_ext_url }}"
            discord_author: "{{ controller_fqdn }}"
            discord_fields:
              - name: "Role"
                value: "{{ role }}"
                inline: true
              - name: "VM Name"
                value: "{{ _vm.vm_name }}"
                inline: true
              - name: "Detail"
                value: "{{ _build_detail }}"
          when: build_failed

        - name: Log build to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          vars:
            log_table: maintenance
            log_application: "{{ maintenance_name }}"
            log_hostname: "{{ controller_fqdn }}"
            log_type: "{{ maintenance_type }}"
            log_subtype: "{{ maintenance_subtype }}"
            log_status: "{{ 'failed' if build_failed else 'success' }}"

        - name: Stop test VM on build failure (free the slot)
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ _vm_actual_node | default(_vm.pve_target_node) }}"
            vmid: "{{ _vm.vm_id }}"
            state: stopped
            force: true
          when: >-
            build_failed | bool and
            (_vm.vm_id | int) >= (vm_test_slot_base | int) and
            (_vm.vm_id | int) <= ((vm_test_slot_base + vm_test_slot_count - 1) | int)
          ignore_errors: true
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

        - name: Fail play if build failed
          ansible.builtin.fail:
            msg: "Build failed: {{ _build_detail }}"
          when: build_failed

# ═══════════════════════════════════════════════════════════════════
# Play 2 — Bootstrap (Docker, keepalived, security hardening)
# ═══════════════════════════════════════════════════════════════════
- name: Bootstrap VM
  hosts: dr_target
  become: true
  gather_facts: false
  vars_files:
    - vars/secrets.yaml
    - vars/vm_definitions.yaml
    - vars/docker_vips.yaml
    - vars/semaphore_check.yaml
  vars:
    maintenance_name: "Docker"
    maintenance_type: "Servers"
    maintenance_subtype: "DR Rebuild"

  tasks:
    - name: Wait for system boot to complete
      ansible.builtin.wait_for_connection:
        delay: 5
        timeout: 300

    - name: Gather facts
      ansible.builtin.setup:

    - name: Resolve scope (role injection for unmapped hosts)
      include_tasks: tasks/resolve_scope.yaml

    - name: Inject VRRP priority for unmapped hosts (test VMs)
      ansible.builtin.set_fact:
        vault_docker_vrrp_priorities: >-
          {{ vault_docker_vrrp_priorities | default({})
             | combine({inventory_hostname.split('.')[0]: 100}) }}
      when: _role_injected | default(false)

    - name: Initialize bootstrap state
      ansible.builtin.set_fact:
        bootstrap_failed: false
        _bootstrap_detail: ""

    - name: Check if Docker is installed
      ansible.builtin.command: docker --version
      register: _docker_check
      failed_when: false
      changed_when: false
      become: false

    - block:
        - name: Bootstrap Ubuntu with Docker and security hardening
          include_tasks: tasks/bootstrap_vm.yaml
          vars:
            _vm: "{{ hostvars['localhost']._vm }}"
          when: hostvars[inventory_hostname]._needs_bootstrap | default(false) or _docker_check.rc != 0

        - name: Record bootstrap detail
          ansible.builtin.set_fact:
            _bootstrap_detail: "Bootstrap complete — Docker, security hardening"

      rescue:
        - name: Set bootstrap failed flag
          ansible.builtin.set_fact:
            bootstrap_failed: true
            _bootstrap_detail: "{{ ansible_failed_result.msg | default('check Semaphore logs') }}"

      always:
        - name: Send Discord notification (combined build + bootstrap result)
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ maintenance_name }}"
            discord_operation: "DR Rebuild"
            discord_status: "{{ 'failed' if bootstrap_failed else 'successful' }}"
            discord_color: "{{ discord_color_failure if bootstrap_failed else discord_color_success }}"
            discord_url: "{{ semaphore_ext_url }}"
            discord_author: "{{ controller_fqdn }}"
            discord_fields:
              - name: "Role"
                value: "{{ role }}"
                inline: true
              - name: "VM Name"
                value: "{{ hostvars['localhost']._vm.vm_name }}"
                inline: true
              - name: "Host IP"
                value: "{{ hostvars['localhost']._vm.vm_ip }}"
                inline: true
              - name: "Detail"
                value: "{{ hostvars['localhost']._build_detail }} | {{ _bootstrap_detail }}"

        - name: Log bootstrap to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          vars:
            log_table: maintenance
            log_application: "{{ maintenance_name }}"
            log_hostname: "{{ inventory_hostname }}"
            log_type: "{{ maintenance_type }}"
            log_subtype: "{{ maintenance_subtype }}"
            log_status: "{{ 'failed' if bootstrap_failed else 'success' }}"

        - name: Stop test VM on bootstrap failure (free the slot)
          community.general.proxmox_kvm:
            api_host: "{{ pve_api_host }}"
            api_user: "{{ pve_api_user }}"
            api_token_id: "{{ pve_api_token_id }}"
            api_token_secret: "{{ pve_api_token_secret }}"
            node: "{{ hostvars['localhost']._vm_actual_node | default(hostvars['localhost']._vm.pve_target_node) }}"
            vmid: "{{ hostvars['localhost']._vm.vm_id }}"
            state: stopped
            force: true
          delegate_to: localhost
          when: >-
            bootstrap_failed | bool and
            (hostvars['localhost']._vm.vm_id | int) >= (vm_test_slot_base | int) and
            (hostvars['localhost']._vm.vm_id | int) <= ((vm_test_slot_base + vm_test_slot_count - 1) | int)
          ignore_errors: true
          no_log: "{{ not (debug_no_log | default(false) | bool) and (ansible_verbosity | default(0) | int < 3) }}"

        - name: Fail play if bootstrap failed
          ansible.builtin.fail:
            msg: "Bootstrap failed: {{ _bootstrap_detail }}"
          when: bootstrap_failed

# ═══════════════════════════════════════════════════════════════════
# Play 3 — Restore appdata + DBs, deploy stacks, health check
# ═══════════════════════════════════════════════════════════════════
- name: Restore and deploy stacks
  hosts: dr_target
  become: true
  gather_facts: true
  gather_subset: ['!all', 'date_time']
  vars_files:
    - vars/secrets.yaml
    - vars/docker_stacks.yaml
    - vars/docker_vips.yaml
    - vars/vm_definitions.yaml
    - vars/semaphore_check.yaml
  vars:
    maintenance_name: "Docker"
    maintenance_type: "Servers"
    maintenance_subtype: "DR Rebuild"
    backup_tmp_dir: "/tmp"

  tasks:
    - name: Assert /opt is not production CephFS (safety gate)
      include_tasks: tasks/assert_test_vm.yaml

    - name: Resolve scope (role injection for unmapped hosts)
      include_tasks: tasks/resolve_scope.yaml

    - name: Inject VRRP priority for unmapped hosts (test VMs)
      ansible.builtin.set_fact:
        vault_docker_vrrp_priorities: >-
          {{ vault_docker_vrrp_priorities | default({})
             | combine({inventory_hostname.split('.')[0]: 100}) }}
      when: _role_injected | default(false)

    - name: Initialize restore state
      ansible.builtin.set_fact:
        _restore_test_failed: false
        _restore_test_detail: ""

    - name: Stop and remove all containers before CephFS cleanup
      ansible.builtin.shell: |
        docker ps -aq | xargs -r docker rm -f 2>/dev/null || true
      become: true
      when:
        - hostvars['localhost']._vm.cephfs_host_dir is defined

    - name: Clean test VM CephFS appdata (/opt on test VM only)
      become: true
      ansible.builtin.shell: |
        find /opt -mindepth 1 -maxdepth 1 -exec rm -rf {} +
      when:
        - hostvars['localhost']._vm.cephfs_host_dir is defined

    - name: Ensure shared Docker network exists
      community.docker.docker_network:
        name: homelab
        state: present
      become: true

    - block:
        # ===== EXTRACT APPDATA FROM BACKUP =====
        - name: Ensure backup_tmp_dir exists on VM
          ansible.builtin.file:
            path: "{{ backup_tmp_dir }}"
            state: directory
            mode: '0755'
          become: true

        - name: Compute selective extract path
          ansible.builtin.set_fact:
            _extract_path: "{{ (src_raw_files[0] | regex_replace('^/', '')) + '/' + restore_app }}"
          when: restore_app | default('') | length > 0

        - name: Restore appdata from production backup
          include_tasks: tasks/restore_appdata.yaml
          loop: "{{ hostvars['localhost']._archive_files }}"
          loop_control:
            loop_var: _current_archive
          vars:
            _restore_archive_path: "{{ _current_archive }}"
            _restore_extract_path: "{{ _extract_path | default('') }}"
            _restore_app_name: "{{ restore_app | default('') }}"

        # ===== PATCH SWAG SITE-CONFS FOR NEW VM LAYOUT =====
        - name: Resolve effective VIPs for SWAG patches
          include_tasks: tasks/resolve_effective_vips.yaml
          when: "'auth' in hostvars['localhost']._stacks"

        - name: Patch SWAG site-confs for core/apps/dev layout
          include_tasks: tasks/patch_swag_confs.yaml
          when: "'auth' in hostvars['localhost']._stacks"

        # ===== DEPLOY DATABASES STACK FIRST =====
        - name: Deploy databases stack first
          include_tasks: tasks/deploy_single_stack.yaml
          vars:
            _current_stack: databases
            patch_compose_networks: true
            _apps_vip: >-
              {% if _role_injected | default(false) %}{{ ansible_default_ipv4.address.rsplit('.', 1)[0] }}.{{ docker_test_vip_offsets['apps'] }}{% else %}{{ vault_apps_vip }}{% endif %}
          when: "'databases' in hostvars['localhost']._stacks"

        - name: Reset DB passwords to match vault (restored data may differ)
          include_tasks: tasks/reset_db_auth.yaml
          vars:
            _db_mariadb_password: "{{ db_password }}"
            _db_postgres_password: "{{ docker_postgres_password }}"
          when: "'databases' in hostvars['localhost']._stacks"

        # ===== RESTORE SQL DUMPS =====
        - name: Wait for database containers to accept authenticated connections
          ansible.builtin.shell: |
            found_any=false
            for i in $(seq 1 60); do
              all_ready=true
              if docker ps -q --filter "name=postgres" | grep -q .; then
                found_any=true
                docker exec postgres pg_isready -U postgres >/dev/null 2>&1 || all_ready=false
              fi
              if docker ps -q --filter "name=mariadb" | grep -q .; then
                found_any=true
                docker exec -e MYSQL_PWD="$DB_PASSWORD" mariadb mysql -u root -e "SELECT 1" >/dev/null 2>&1 || all_ready=false
              fi
              if $found_any && $all_ready; then
                echo "ready"
                exit 0
              fi
              sleep 2
            done
            echo "timeout — found_any=$found_any"
            exit 1
          environment:
            DB_PASSWORD: "{{ db_password | default('') }}"
          become: true
          changed_when: false
          when: hostvars['localhost']._db_archive_map | default({}) | length > 0

        - name: Create DB restore staging directory on VM
          ansible.builtin.file:
            path: /tmp/db_restore_staging
            state: directory
            mode: '0755'
          become: true
          when: hostvars['localhost']._db_archive_map | default({}) | length > 0

        - name: Copy production DB backup to VM — {{ item.key }}
          ansible.builtin.synchronize:
            src: "{{ item.value }}"
            dest: "/tmp/db_restore_staging/{{ item.value | basename }}"
            compress: false
            rsync_opts:
              - "--timeout=300"
              - "--whole-file"
          become: true
          ignore_errors: true
          register: _db_rsync_result
          loop: "{{ hostvars['localhost']._db_archive_map | default({}) | dict2items }}"
          loop_control:
            label: "{{ item.key }}"
          when: hostvars['localhost']._db_archive_map | default({}) | length > 0

        - name: "Rsync stalled — copy DB backup via Ansible — {{ item.key }}"
          ansible.builtin.copy:
            src: "{{ item.value }}"
            dest: "/tmp/db_restore_staging/{{ item.value | basename }}"
            mode: "0644"
          become: true
          loop: "{{ hostvars['localhost']._db_archive_map | default({}) | dict2items }}"
          loop_control:
            label: "{{ item.key }}"
          when:
            - hostvars['localhost']._db_archive_map | default({}) | length > 0
            - _db_rsync_result is failed

        - name: Restore postgres database — {{ _db_item }}
          include_tasks: tasks/db_restore.yaml
          loop: "{{ hostvars['localhost']._db_postgres_names | default([]) }}"
          loop_control:
            loop_var: _db_item
          vars:
            _db_name: "{{ _db_item }}"
            _db_container: "{{ hostvars['localhost']._db_postgres_container }}"
            _db_username: "{{ hostvars['localhost']._db_postgres_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_source_file: "/tmp/db_restore_staging/{{ hostvars['localhost']._db_archive_map[_db_item] | basename }}"
            _db_is_postgres: true
            _db_is_mariadb: false
            _db_is_influxdb: false
            _db_tmp_dir: "/tmp/db_restore_staging"
          when: hostvars['localhost']._db_postgres_names | default([]) | length > 0

        - name: Restore mariadb database — {{ _db_item }}
          include_tasks: tasks/db_restore.yaml
          loop: "{{ hostvars['localhost']._db_mariadb_names | default([]) }}"
          loop_control:
            loop_var: _db_item
          vars:
            _db_name: "{{ _db_item }}"
            _db_container: "{{ hostvars['localhost']._db_mariadb_container }}"
            _db_username: "{{ hostvars['localhost']._db_mariadb_username }}"
            _db_password: "{{ db_password | default('') }}"
            _db_source_file: "/tmp/db_restore_staging/{{ hostvars['localhost']._db_archive_map[_db_item] | basename }}"
            _db_is_postgres: false
            _db_is_mariadb: true
            _db_is_influxdb: false
            _db_tmp_dir: "/tmp/db_restore_staging"
          when: hostvars['localhost']._db_mariadb_names | default([]) | length > 0

        - name: Clean up DB restore staging directory
          ansible.builtin.file:
            path: /tmp/db_restore_staging
            state: absent
          become: true
          when: hostvars['localhost']._db_archive_map | default({}) | length > 0

        # ===== DEPLOY REMAINING STACKS =====
        - name: "Deploy stack — {{ _current_stack }}"
          include_tasks: tasks/deploy_single_stack.yaml
          loop: "{{ hostvars['localhost']._stacks | reject('equalto', 'databases') | list }}"
          loop_control:
            loop_var: _current_stack
          vars:
            patch_compose_networks: true
            _apps_vip: >-
              {% if _role_injected | default(false) %}{{ ansible_default_ipv4.address.rsplit('.', 1)[0] }}.{{ docker_test_vip_offsets['apps'] }}{% else %}{{ vault_apps_vip }}{% endif %}

        # ===== HEALTH CHECK =====
        - name: Verify container health
          include_tasks: tasks/verify_docker_health.yaml

        # ===== NETWORK VERIFICATION =====
        - name: Verify Docker network connectivity
          include_tasks: tasks/verify_docker_network.yaml

        # ===== NETWORK ISOLATION VERIFICATION =====
        - name: Verify test VLAN isolation from production
          include_tasks: tasks/verify_network_isolation.yaml
          vars:
            _vm: "{{ hostvars['localhost']._vm }}"

        # ===== VIP VERIFICATION =====
        - name: Verify VIP is active
          include_tasks: tasks/verify_vip.yaml

        - name: Record success detail
          ansible.builtin.set_fact:
            _restore_test_detail: >-
              {{ restore_app | default('full') }} restore verified
              — {{ hostvars['localhost']._stacks | join(', ') }} stack(s)

      rescue:
        - name: Set restore failed flag
          ansible.builtin.set_fact:
            _restore_test_failed: true
            _restore_test_detail: "{{ ansible_failed_result.msg | default('check Semaphore logs') }}{{ (' | ' + ansible_failed_result.stdout | trim) if ansible_failed_result.stdout | default('') | trim | length > 0 else '' }}"

      always:
        - name: Clean up temp archive
          ansible.builtin.file:
            path: "/tmp/restore_inplace.tar.gz"
            state: absent

        - name: Send Discord notification (final result)
          include_tasks: tasks/notify.yaml
          vars:
            discord_name: "{{ maintenance_name }}"
            discord_operation: "DR Rebuild"
            discord_status: "{{ 'failed' if _restore_test_failed else 'successful' }}"
            discord_detail: >-
              {{ role }}{{ ' (' + restore_app + ')' if restore_app | default('') | length > 0 else '' }}
            discord_color: "{{ discord_color_failure if _restore_test_failed else discord_color_success }}"
            discord_url: "{{ semaphore_ext_url }}"
            discord_author: "{{ controller_fqdn }}"
            discord_fields:
              - name: "Role"
                value: "{{ role }}"
                inline: true
              - name: "VM"
                value: "{{ hostvars['localhost']._vm.vm_name }}"
                inline: true
              - name: "Stacks"
                value: "{{ hostvars['localhost']._stacks | join(', ') }}"
              - name: "Detail"
                value: "{{ _restore_test_detail }}"

        - name: Log restore to MariaDB
          include_tasks: tasks/log_mariadb.yaml
          vars:
            log_table: maintenance
            log_application: "{{ maintenance_name }}"
            log_hostname: "{{ controller_fqdn }}"
            log_type: "{{ maintenance_type }}"
            log_subtype: "{{ maintenance_subtype }}"
            log_status: "{{ 'failed' if _restore_test_failed else 'success' }}"

        - name: Fail play if restore failed
          ansible.builtin.fail:
            msg: "Restore failed: {{ _restore_test_detail }}"
          when: _restore_test_failed
